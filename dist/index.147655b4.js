// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kAaS7":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "69f74e7f31319ffd";
module.bundle.HMR_BUNDLE_ID = "e80cae8e147655b4";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F1() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                } // Render the fancy html overlay
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
            document.body.appendChild(overlay);
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>\n          ").concat(stack, "\n        </pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>' + hint + '</div>';
            }).join(''), "\n        </div>\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') {
        reloadCSS();
        return;
    }
    var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
    if (deps) {
        var fn = new Function('require', 'module', 'exports', asset.output);
        modules[asset.id] = [
            fn,
            deps
        ];
    } else if (bundle.parent) hmrApply(bundle.parent, asset);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    return getParents(module.bundle.root, id).some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"i87aF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
//import 'babel-polyfill';
var _stable = require("core-js/stable");
var _uploader = require("./uploader");
var _uploaderDefault = parcelHelpers.interopDefault(_uploader);
var _faceApiJs = require("face-api.js");
const main = async ()=>{
    _uploaderDefault.default('.input-submit', '.images-list');
    const videoContainer = document.querySelector('.js-video');
    const canvas = document.querySelector('.js-canvas');
    const context = canvas.getContext('2d');
    const video = await navigator.mediaDevices.getUserMedia({
        video: true
    });
    videoContainer.srcObject = video;
    const reDraw = async ()=>{
        context.drawImage(videoContainer, 0, 0, 640, 480);
        requestAnimationFrame(reDraw);
    };
    requestAnimationFrame(reDraw);
};
main();

},{"core-js/stable":"eIyVg","./uploader":"pj5Me","face-api.js":"8MSAD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eIyVg":[function(require,module,exports) {
require('../modules/es.symbol');
require('../modules/es.symbol.description');
require('../modules/es.symbol.async-iterator');
require('../modules/es.symbol.has-instance');
require('../modules/es.symbol.is-concat-spreadable');
require('../modules/es.symbol.iterator');
require('../modules/es.symbol.match');
require('../modules/es.symbol.match-all');
require('../modules/es.symbol.replace');
require('../modules/es.symbol.search');
require('../modules/es.symbol.species');
require('../modules/es.symbol.split');
require('../modules/es.symbol.to-primitive');
require('../modules/es.symbol.to-string-tag');
require('../modules/es.symbol.unscopables');
require('../modules/es.aggregate-error');
require('../modules/es.array.concat');
require('../modules/es.array.copy-within');
require('../modules/es.array.every');
require('../modules/es.array.fill');
require('../modules/es.array.filter');
require('../modules/es.array.find');
require('../modules/es.array.find-index');
require('../modules/es.array.flat');
require('../modules/es.array.flat-map');
require('../modules/es.array.for-each');
require('../modules/es.array.from');
require('../modules/es.array.includes');
require('../modules/es.array.index-of');
require('../modules/es.array.is-array');
require('../modules/es.array.iterator');
require('../modules/es.array.join');
require('../modules/es.array.last-index-of');
require('../modules/es.array.map');
require('../modules/es.array.of');
require('../modules/es.array.reduce');
require('../modules/es.array.reduce-right');
require('../modules/es.array.reverse');
require('../modules/es.array.slice');
require('../modules/es.array.some');
require('../modules/es.array.sort');
require('../modules/es.array.species');
require('../modules/es.array.splice');
require('../modules/es.array.unscopables.flat');
require('../modules/es.array.unscopables.flat-map');
require('../modules/es.array-buffer.constructor');
require('../modules/es.array-buffer.is-view');
require('../modules/es.array-buffer.slice');
require('../modules/es.data-view');
require('../modules/es.date.get-year');
require('../modules/es.date.now');
require('../modules/es.date.set-year');
require('../modules/es.date.to-gmt-string');
require('../modules/es.date.to-iso-string');
require('../modules/es.date.to-json');
require('../modules/es.date.to-primitive');
require('../modules/es.date.to-string');
require('../modules/es.escape');
require('../modules/es.function.bind');
require('../modules/es.function.has-instance');
require('../modules/es.function.name');
require('../modules/es.global-this');
require('../modules/es.json.stringify');
require('../modules/es.json.to-string-tag');
require('../modules/es.map');
require('../modules/es.math.acosh');
require('../modules/es.math.asinh');
require('../modules/es.math.atanh');
require('../modules/es.math.cbrt');
require('../modules/es.math.clz32');
require('../modules/es.math.cosh');
require('../modules/es.math.expm1');
require('../modules/es.math.fround');
require('../modules/es.math.hypot');
require('../modules/es.math.imul');
require('../modules/es.math.log10');
require('../modules/es.math.log1p');
require('../modules/es.math.log2');
require('../modules/es.math.sign');
require('../modules/es.math.sinh');
require('../modules/es.math.tanh');
require('../modules/es.math.to-string-tag');
require('../modules/es.math.trunc');
require('../modules/es.number.constructor');
require('../modules/es.number.epsilon');
require('../modules/es.number.is-finite');
require('../modules/es.number.is-integer');
require('../modules/es.number.is-nan');
require('../modules/es.number.is-safe-integer');
require('../modules/es.number.max-safe-integer');
require('../modules/es.number.min-safe-integer');
require('../modules/es.number.parse-float');
require('../modules/es.number.parse-int');
require('../modules/es.number.to-fixed');
require('../modules/es.number.to-precision');
require('../modules/es.object.assign');
require('../modules/es.object.create');
require('../modules/es.object.define-getter');
require('../modules/es.object.define-properties');
require('../modules/es.object.define-property');
require('../modules/es.object.define-setter');
require('../modules/es.object.entries');
require('../modules/es.object.freeze');
require('../modules/es.object.from-entries');
require('../modules/es.object.get-own-property-descriptor');
require('../modules/es.object.get-own-property-descriptors');
require('../modules/es.object.get-own-property-names');
require('../modules/es.object.get-prototype-of');
require('../modules/es.object.is');
require('../modules/es.object.is-extensible');
require('../modules/es.object.is-frozen');
require('../modules/es.object.is-sealed');
require('../modules/es.object.keys');
require('../modules/es.object.lookup-getter');
require('../modules/es.object.lookup-setter');
require('../modules/es.object.prevent-extensions');
require('../modules/es.object.seal');
require('../modules/es.object.set-prototype-of');
require('../modules/es.object.to-string');
require('../modules/es.object.values');
require('../modules/es.parse-float');
require('../modules/es.parse-int');
require('../modules/es.promise');
require('../modules/es.promise.all-settled');
require('../modules/es.promise.any');
require('../modules/es.promise.finally');
require('../modules/es.reflect.apply');
require('../modules/es.reflect.construct');
require('../modules/es.reflect.define-property');
require('../modules/es.reflect.delete-property');
require('../modules/es.reflect.get');
require('../modules/es.reflect.get-own-property-descriptor');
require('../modules/es.reflect.get-prototype-of');
require('../modules/es.reflect.has');
require('../modules/es.reflect.is-extensible');
require('../modules/es.reflect.own-keys');
require('../modules/es.reflect.prevent-extensions');
require('../modules/es.reflect.set');
require('../modules/es.reflect.set-prototype-of');
require('../modules/es.reflect.to-string-tag');
require('../modules/es.regexp.constructor');
require('../modules/es.regexp.dot-all');
require('../modules/es.regexp.exec');
require('../modules/es.regexp.flags');
require('../modules/es.regexp.sticky');
require('../modules/es.regexp.test');
require('../modules/es.regexp.to-string');
require('../modules/es.set');
require('../modules/es.string.code-point-at');
require('../modules/es.string.ends-with');
require('../modules/es.string.from-code-point');
require('../modules/es.string.includes');
require('../modules/es.string.iterator');
require('../modules/es.string.match');
require('../modules/es.string.match-all');
require('../modules/es.string.pad-end');
require('../modules/es.string.pad-start');
require('../modules/es.string.raw');
require('../modules/es.string.repeat');
require('../modules/es.string.replace');
require('../modules/es.string.replace-all');
require('../modules/es.string.search');
require('../modules/es.string.split');
require('../modules/es.string.starts-with');
require('../modules/es.string.substr');
require('../modules/es.string.trim');
require('../modules/es.string.trim-end');
require('../modules/es.string.trim-start');
require('../modules/es.string.anchor');
require('../modules/es.string.big');
require('../modules/es.string.blink');
require('../modules/es.string.bold');
require('../modules/es.string.fixed');
require('../modules/es.string.fontcolor');
require('../modules/es.string.fontsize');
require('../modules/es.string.italics');
require('../modules/es.string.link');
require('../modules/es.string.small');
require('../modules/es.string.strike');
require('../modules/es.string.sub');
require('../modules/es.string.sup');
require('../modules/es.typed-array.float32-array');
require('../modules/es.typed-array.float64-array');
require('../modules/es.typed-array.int8-array');
require('../modules/es.typed-array.int16-array');
require('../modules/es.typed-array.int32-array');
require('../modules/es.typed-array.uint8-array');
require('../modules/es.typed-array.uint8-clamped-array');
require('../modules/es.typed-array.uint16-array');
require('../modules/es.typed-array.uint32-array');
require('../modules/es.typed-array.copy-within');
require('../modules/es.typed-array.every');
require('../modules/es.typed-array.fill');
require('../modules/es.typed-array.filter');
require('../modules/es.typed-array.find');
require('../modules/es.typed-array.find-index');
require('../modules/es.typed-array.for-each');
require('../modules/es.typed-array.from');
require('../modules/es.typed-array.includes');
require('../modules/es.typed-array.index-of');
require('../modules/es.typed-array.iterator');
require('../modules/es.typed-array.join');
require('../modules/es.typed-array.last-index-of');
require('../modules/es.typed-array.map');
require('../modules/es.typed-array.of');
require('../modules/es.typed-array.reduce');
require('../modules/es.typed-array.reduce-right');
require('../modules/es.typed-array.reverse');
require('../modules/es.typed-array.set');
require('../modules/es.typed-array.slice');
require('../modules/es.typed-array.some');
require('../modules/es.typed-array.sort');
require('../modules/es.typed-array.subarray');
require('../modules/es.typed-array.to-locale-string');
require('../modules/es.typed-array.to-string');
require('../modules/es.unescape');
require('../modules/es.weak-map');
require('../modules/es.weak-set');
require('../modules/web.dom-collections.for-each');
require('../modules/web.dom-collections.iterator');
require('../modules/web.immediate');
require('../modules/web.queue-microtask');
require('../modules/web.timers');
require('../modules/web.url');
require('../modules/web.url.to-json');
require('../modules/web.url-search-params');
module.exports = require('../internals/path');

},{"../modules/es.symbol":"h82Ta","../modules/es.symbol.description":"k6qTH","../modules/es.symbol.async-iterator":"4gQKh","../modules/es.symbol.has-instance":"6rypY","../modules/es.symbol.is-concat-spreadable":"8cPMJ","../modules/es.symbol.iterator":"54Wkt","../modules/es.symbol.match":"fci7y","../modules/es.symbol.match-all":"LEHqP","../modules/es.symbol.replace":"emMne","../modules/es.symbol.search":"1pJ8K","../modules/es.symbol.species":"aUPm6","../modules/es.symbol.split":"h3StJ","../modules/es.symbol.to-primitive":"jiMen","../modules/es.symbol.to-string-tag":"2Dw1B","../modules/es.symbol.unscopables":"dad1W","../modules/es.aggregate-error":"iQYvV","../modules/es.array.concat":"12BiX","../modules/es.array.copy-within":"6Qlz9","../modules/es.array.every":"isBXe","../modules/es.array.fill":"48CiI","../modules/es.array.filter":"cKRrG","../modules/es.array.find":"eHU6M","../modules/es.array.find-index":"kfYJb","../modules/es.array.flat":"am9Da","../modules/es.array.flat-map":"cMHMc","../modules/es.array.for-each":"aTBjZ","../modules/es.array.from":"fUGae","../modules/es.array.includes":"X9Fp2","../modules/es.array.index-of":"gpPtE","../modules/es.array.is-array":"9vHDR","../modules/es.array.iterator":"8YPvt","../modules/es.array.join":"fcdvD","../modules/es.array.last-index-of":"bVRYF","../modules/es.array.map":"g11io","../modules/es.array.of":"hwsFe","../modules/es.array.reduce":"iTsnC","../modules/es.array.reduce-right":"dTOyk","../modules/es.array.reverse":"4H4sw","../modules/es.array.slice":"1Qy0K","../modules/es.array.some":"3MKkN","../modules/es.array.sort":"6yoc0","../modules/es.array.species":"5m0CI","../modules/es.array.splice":"65ZuR","../modules/es.array.unscopables.flat":"hIgzb","../modules/es.array.unscopables.flat-map":"2lymx","../modules/es.array-buffer.constructor":"4p0zL","../modules/es.array-buffer.is-view":"30MAW","../modules/es.array-buffer.slice":"ktSH3","../modules/es.data-view":"6n7Um","../modules/es.date.get-year":"e1hhS","../modules/es.date.now":"lGf1w","../modules/es.date.set-year":"4GJ8v","../modules/es.date.to-gmt-string":"dNoww","../modules/es.date.to-iso-string":"7mzsp","../modules/es.date.to-json":"ay4bx","../modules/es.date.to-primitive":"fObwG","../modules/es.date.to-string":"7pcaU","../modules/es.escape":"7stNY","../modules/es.function.bind":"jrjf4","../modules/es.function.has-instance":"9on83","../modules/es.function.name":"2tRvX","../modules/es.global-this":"JI3Gz","../modules/es.json.stringify":"2B2ps","../modules/es.json.to-string-tag":"6YcXi","../modules/es.map":"dgMLm","../modules/es.math.acosh":"6Q3zo","../modules/es.math.asinh":"d1XOI","../modules/es.math.atanh":"5D0SG","../modules/es.math.cbrt":"l5TVA","../modules/es.math.clz32":"bJrnh","../modules/es.math.cosh":"6w8zd","../modules/es.math.expm1":"9DJbl","../modules/es.math.fround":"6tufR","../modules/es.math.hypot":"aSB3F","../modules/es.math.imul":"5Tpna","../modules/es.math.log10":"bTcHD","../modules/es.math.log1p":"jNyU5","../modules/es.math.log2":"2m7Uz","../modules/es.math.sign":"7yRUV","../modules/es.math.sinh":"loaKI","../modules/es.math.tanh":"dwPS4","../modules/es.math.to-string-tag":"96Wzg","../modules/es.math.trunc":"31xhu","../modules/es.number.constructor":"5DN40","../modules/es.number.epsilon":"6N90G","../modules/es.number.is-finite":"hI7wQ","../modules/es.number.is-integer":"57kzb","../modules/es.number.is-nan":"aJ0lS","../modules/es.number.is-safe-integer":"2sa8K","../modules/es.number.max-safe-integer":"ceCFQ","../modules/es.number.min-safe-integer":"cfRrX","../modules/es.number.parse-float":"9MahJ","../modules/es.number.parse-int":"lJYd7","../modules/es.number.to-fixed":"THlev","../modules/es.number.to-precision":"kVGGb","../modules/es.object.assign":"6ZqF3","../modules/es.object.create":"2xLMD","../modules/es.object.define-getter":"606Pz","../modules/es.object.define-properties":"fJ9J2","../modules/es.object.define-property":"59EGR","../modules/es.object.define-setter":"cFhpw","../modules/es.object.entries":"e5Xxq","../modules/es.object.freeze":"312H3","../modules/es.object.from-entries":"e3o3h","../modules/es.object.get-own-property-descriptor":"ihm1S","../modules/es.object.get-own-property-descriptors":"9OScw","../modules/es.object.get-own-property-names":"iic1E","../modules/es.object.get-prototype-of":"e7kbe","../modules/es.object.is":"5qpSm","../modules/es.object.is-extensible":"5Df9G","../modules/es.object.is-frozen":"jrP45","../modules/es.object.is-sealed":"9946V","../modules/es.object.keys":"boYMK","../modules/es.object.lookup-getter":"TD7HT","../modules/es.object.lookup-setter":"chseq","../modules/es.object.prevent-extensions":"YDDty","../modules/es.object.seal":"81CbY","../modules/es.object.set-prototype-of":"kDpCL","../modules/es.object.to-string":"bBRVN","../modules/es.object.values":"gTDYu","../modules/es.parse-float":"iXVt6","../modules/es.parse-int":"dHCty","../modules/es.promise":"kYha9","../modules/es.promise.all-settled":"iKqpp","../modules/es.promise.any":"8inPk","../modules/es.promise.finally":"bPigD","../modules/es.reflect.apply":"lncJ8","../modules/es.reflect.construct":"ff1SM","../modules/es.reflect.define-property":"dW0sW","../modules/es.reflect.delete-property":"7DsVb","../modules/es.reflect.get":"jaVFn","../modules/es.reflect.get-own-property-descriptor":"kVW26","../modules/es.reflect.get-prototype-of":"hBOtV","../modules/es.reflect.has":"gTbyP","../modules/es.reflect.is-extensible":"VG7RE","../modules/es.reflect.own-keys":"8moRG","../modules/es.reflect.prevent-extensions":"gMzOv","../modules/es.reflect.set":"9isA9","../modules/es.reflect.set-prototype-of":"6hNd3","../modules/es.reflect.to-string-tag":"99fpE","../modules/es.regexp.constructor":"dwe4v","../modules/es.regexp.dot-all":"1u6bJ","../modules/es.regexp.exec":"lySIs","../modules/es.regexp.flags":"ecNn9","../modules/es.regexp.sticky":"j9bjG","../modules/es.regexp.test":"iP2j2","../modules/es.regexp.to-string":"7sKSf","../modules/es.set":"5wbk0","../modules/es.string.code-point-at":"fviUF","../modules/es.string.ends-with":"i8dBj","../modules/es.string.from-code-point":"kP5Lw","../modules/es.string.includes":"c28Iv","../modules/es.string.iterator":"79oCt","../modules/es.string.match":"3bQbi","../modules/es.string.match-all":"jEeAs","../modules/es.string.pad-end":"fEFFM","../modules/es.string.pad-start":"coZy7","../modules/es.string.raw":"d9wUa","../modules/es.string.repeat":"7f2Bv","../modules/es.string.replace":"2k8lL","../modules/es.string.replace-all":"8IJOq","../modules/es.string.search":"9LcVn","../modules/es.string.split":"5yIFY","../modules/es.string.starts-with":"5IlYf","../modules/es.string.substr":"ffj2Y","../modules/es.string.trim":"1UwM0","../modules/es.string.trim-end":"67bv8","../modules/es.string.trim-start":"cbyCh","../modules/es.string.anchor":"h582X","../modules/es.string.big":"gSDtA","../modules/es.string.blink":"lTrep","../modules/es.string.bold":"kk4wr","../modules/es.string.fixed":"kdH1X","../modules/es.string.fontcolor":"412V5","../modules/es.string.fontsize":"7TWRa","../modules/es.string.italics":"iOrbm","../modules/es.string.link":"3BgXC","../modules/es.string.small":"7usyq","../modules/es.string.strike":"6sGtc","../modules/es.string.sub":"k998D","../modules/es.string.sup":"a5Yf5","../modules/es.typed-array.float32-array":"f9m3z","../modules/es.typed-array.float64-array":"ky6XR","../modules/es.typed-array.int8-array":"lEs7k","../modules/es.typed-array.int16-array":"5EyRk","../modules/es.typed-array.int32-array":"cDL8j","../modules/es.typed-array.uint8-array":"2HsmO","../modules/es.typed-array.uint8-clamped-array":"dFa8q","../modules/es.typed-array.uint16-array":"aykHi","../modules/es.typed-array.uint32-array":"2oUhq","../modules/es.typed-array.copy-within":"3ktIi","../modules/es.typed-array.every":"5DxE6","../modules/es.typed-array.fill":"fqjtk","../modules/es.typed-array.filter":"1uzjz","../modules/es.typed-array.find":"d7VSQ","../modules/es.typed-array.find-index":"llIwb","../modules/es.typed-array.for-each":"Wrhx0","../modules/es.typed-array.from":"fgrPV","../modules/es.typed-array.includes":"afXwJ","../modules/es.typed-array.index-of":"ffWJN","../modules/es.typed-array.iterator":"dWqIW","../modules/es.typed-array.join":"30Fjw","../modules/es.typed-array.last-index-of":"fUt12","../modules/es.typed-array.map":"abKo8","../modules/es.typed-array.of":"aASoo","../modules/es.typed-array.reduce":"cw3bd","../modules/es.typed-array.reduce-right":"fIIbY","../modules/es.typed-array.reverse":"aYS8V","../modules/es.typed-array.set":"4UlXb","../modules/es.typed-array.slice":"fmByv","../modules/es.typed-array.some":"adzA5","../modules/es.typed-array.sort":"7J6wI","../modules/es.typed-array.subarray":"ghLDl","../modules/es.typed-array.to-locale-string":"kaAyh","../modules/es.typed-array.to-string":"4lkfC","../modules/es.unescape":"gnnik","../modules/es.weak-map":"7VYon","../modules/es.weak-set":"kMVCu","../modules/web.dom-collections.for-each":"917na","../modules/web.dom-collections.iterator":"gC8gE","../modules/web.immediate":"6VxKM","../modules/web.queue-microtask":"kIUUV","../modules/web.timers":"8IM6S","../modules/web.url":"c61iN","../modules/web.url.to-json":"fBskR","../modules/web.url-search-params":"dj0GL","../internals/path":"cV4BF"}],"h82Ta":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var fails = require('../internals/fails');
var has = require('../internals/has');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var $toString = require('../internals/to-string');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var nativeObjectCreate = require('../internals/object-create');
var objectKeys = require('../internals/object-keys');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var shared = require('../internals/shared');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var uid = require('../internals/uid');
var wellKnownSymbol = require('../internals/well-known-symbol');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var $forEach = require('../internals/array-iteration').forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function() {
    return nativeObjectCreate(nativeDefineProperty({
    }, 'a', {
        get: function() {
            return nativeDefineProperty(this, 'a', {
                value: 7
            }).a;
        }
    })).a != 7;
}) ? function(O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
    nativeDefineProperty(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
} : nativeDefineProperty;
var wrap = function(tag, description) {
    var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
    setInternalState(symbol, {
        type: SYMBOL,
        tag: tag,
        description: description
    });
    if (!DESCRIPTORS) symbol.description = description;
    return symbol;
};
var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject(O);
    var key = toPropertyKey(P);
    anObject(Attributes);
    if (has(AllSymbols, key)) {
        if (!Attributes.enumerable) {
            if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {
            }));
            O[HIDDEN][key] = true;
        } else {
            if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, {
                enumerable: createPropertyDescriptor(0, false)
            });
        }
        return setSymbolDescriptor(O, key, Attributes);
    }
    return nativeDefineProperty(O, key, Attributes);
};
var $defineProperties = function defineProperties(O, Properties) {
    anObject(O);
    var properties = toIndexedObject(Properties);
    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
    $forEach(keys, function(key) {
        if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
};
var $create = function create(O, Properties) {
    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPropertyKey(V);
    var enumerable = nativePropertyIsEnumerable.call(this, P);
    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject(O);
    var key = toPropertyKey(P);
    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor(it, key);
    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) descriptor.enumerable = true;
    return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject(O));
    var result = [];
    $forEach(names, function(key) {
        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
    });
    return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
    var result = [];
    $forEach(names, function(key) {
        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) result.push(AllSymbols[key]);
    });
    return result;
};
// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol1() {
        if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
            if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };
        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
            configurable: true,
            set: setter
        });
        return wrap(tag, description);
    };
    redefine($Symbol[PROTOTYPE], 'toString', function toString() {
        return getInternalState(this).tag;
    });
    redefine($Symbol, 'withoutSetter', function(description) {
        return wrap(uid(description), description);
    });
    propertyIsEnumerableModule.f = $propertyIsEnumerable;
    definePropertyModule.f = $defineProperty;
    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
    wrappedWellKnownSymbolModule.f = function(name) {
        return wrap(wellKnownSymbol(name), name);
    };
    if (DESCRIPTORS) {
        // https://github.com/tc39/proposal-Symbol-description
        nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
            configurable: true,
            get: function description() {
                return getInternalState(this).description;
            }
        });
        if (!IS_PURE) redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
            unsafe: true
        });
    }
}
$({
    global: true,
    wrap: true,
    forced: !NATIVE_SYMBOL,
    sham: !NATIVE_SYMBOL
}, {
    Symbol: $Symbol
});
$forEach(objectKeys(WellKnownSymbolsStore), function(name) {
    defineWellKnownSymbol(name);
});
$({
    target: SYMBOL,
    stat: true,
    forced: !NATIVE_SYMBOL
}, {
    // `Symbol.for` method
    // https://tc39.es/ecma262/#sec-symbol.for
    'for': function(key) {
        var string = $toString(key);
        if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
        var symbol = $Symbol(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.es/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function() {
        USE_SETTER = true;
    },
    useSimple: function() {
        USE_SETTER = false;
    }
});
$({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL,
    sham: !DESCRIPTORS
}, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL
}, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
});
// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({
    target: 'Object',
    stat: true,
    forced: fails(function() {
        getOwnPropertySymbolsModule.f(1);
    })
}, {
    getOwnPropertySymbols: function getOwnPropertySymbols1(it) {
        return getOwnPropertySymbolsModule.f(toObject(it));
    }
});
// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
        var symbol = $Symbol();
        // MS Edge converts symbol values to JSON as {}
        return $stringify([
            symbol
        ]) != '[null]' || $stringify({
            a: symbol
        }) != '{}' || $stringify(Object(symbol)) != '{}';
    });
    $({
        target: 'JSON',
        stat: true,
        forced: FORCED_JSON_STRINGIFY
    }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify(it, replacer, space) {
            var args = [
                it
            ];
            var index = 1;
            var $replacer;
            while(arguments.length > index)args.push(arguments[index++]);
            $replacer = replacer;
            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
            if (!isArray(replacer)) replacer = function(key, value) {
                if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
                if (!isSymbol(value)) return value;
            };
            args[1] = replacer;
            return $stringify.apply(null, args);
        }
    });
}
// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/get-built-in":"hqegu","../internals/is-pure":"dlbEd","../internals/descriptors":"kuDzl","../internals/native-symbol":"2gIhS","../internals/fails":"byxLb","../internals/has":"aVEHj","../internals/is-array":"kiY2Q","../internals/is-object":"d60Kc","../internals/is-symbol":"hfIC8","../internals/an-object":"9unxM","../internals/to-object":"ghTKi","../internals/to-indexed-object":"9N8sJ","../internals/to-property-key":"99Lby","../internals/to-string":"k0ZQF","../internals/create-property-descriptor":"5fdHA","../internals/object-create":"eYZeq","../internals/object-keys":"7so9x","../internals/object-get-own-property-names":"38UqD","../internals/object-get-own-property-names-external":"ivjog","../internals/object-get-own-property-symbols":"3jR7g","../internals/object-get-own-property-descriptor":"hwpsT","../internals/object-define-property":"iKHmb","../internals/object-property-is-enumerable":"6JYDE","../internals/create-non-enumerable-property":"73EkF","../internals/redefine":"cwrrW","../internals/shared":"ic92G","../internals/shared-key":"65Tv5","../internals/hidden-keys":"8TVAY","../internals/uid":"9DssZ","../internals/well-known-symbol":"6sZ59","../internals/well-known-symbol-wrapped":"6xsru","../internals/define-well-known-symbol":"jDA2f","../internals/set-to-string-tag":"cFbSt","../internals/internal-state":"ceuiK","../internals/array-iteration":"ciNJ0"}],"2mZbc":[function(require,module,exports) {
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/ module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) target = global;
    else if (STATIC) target = global[TARGET] || setGlobal(TARGET, {
    });
    else target = (global[TARGET] || {
    }).prototype;
    if (target) for(key in source){
        sourceProperty = source[key];
        if (options.noTargetGet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        // contained in target
        if (!FORCED && targetProperty !== undefined) {
            if (typeof sourceProperty === typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
        }
        // add a flag to not completely full polyfills
        if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, 'sham', true);
        // extend global
        redefine(target, key, sourceProperty, options);
    }
};

},{"../internals/global":"a4GR8","../internals/object-get-own-property-descriptor":"hwpsT","../internals/create-non-enumerable-property":"73EkF","../internals/redefine":"cwrrW","../internals/set-global":"7Z35u","../internals/copy-constructor-properties":"4qgKG","../internals/is-forced":"djqhI"}],"a4GR8":[function(require,module,exports) {
var global = arguments[3];
var check = function(it) {
    return it && it.Math == Math && it;
};
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || // eslint-disable-next-line no-new-func -- fallback
(function() {
    return this;
})() || Function('return this')();

},{}],"hwpsT":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var has = require('../internals/has');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
    }
    if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

},{"../internals/descriptors":"kuDzl","../internals/object-property-is-enumerable":"6JYDE","../internals/create-property-descriptor":"5fdHA","../internals/to-indexed-object":"9N8sJ","../internals/to-property-key":"99Lby","../internals/has":"aVEHj","../internals/ie8-dom-define":"5FQkl"}],"kuDzl":[function(require,module,exports) {
var fails = require('../internals/fails');
// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({
    }, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

},{"../internals/fails":"byxLb"}],"byxLb":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

},{}],"6JYDE":[function(require,module,exports) {
'use strict';
var $propertyIsEnumerable = {
}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
    1: 2
}, 1);
// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],"5fdHA":[function(require,module,exports) {
module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

},{}],"9N8sJ":[function(require,module,exports) {
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":"1hg9G","../internals/require-object-coercible":"1XURO"}],"1hg9G":[function(require,module,exports) {
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');
var split = ''.split;
// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object('z').propertyIsEnumerable(0);
}) ? function(it) {
    return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

},{"../internals/fails":"byxLb","../internals/classof-raw":"8F0bi"}],"8F0bi":[function(require,module,exports) {
var toString = {
}.toString;
module.exports = function(it) {
    return toString.call(it).slice(8, -1);
};

},{}],"1XURO":[function(require,module,exports) {
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
};

},{}],"99Lby":[function(require,module,exports) {
var toPrimitive = require('../internals/to-primitive');
var isSymbol = require('../internals/is-symbol');
// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function(argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : String(key);
};

},{"../internals/to-primitive":"LSiNW","../internals/is-symbol":"hfIC8"}],"LSiNW":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = input[TO_PRIMITIVE];
    var result;
    if (exoticToPrim !== undefined) {
        if (pref === undefined) pref = 'default';
        result = exoticToPrim.call(input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
};

},{"../internals/is-object":"d60Kc","../internals/is-symbol":"hfIC8","../internals/ordinary-to-primitive":"1rrrl","../internals/well-known-symbol":"6sZ59"}],"d60Kc":[function(require,module,exports) {
module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"hfIC8":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == 'symbol';
} : function(it) {
    var $Symbol = getBuiltIn('Symbol');
    return typeof $Symbol == 'function' && Object(it) instanceof $Symbol;
};

},{"../internals/get-built-in":"hqegu","../internals/use-symbol-as-uid":"dancM"}],"hqegu":[function(require,module,exports) {
var global = require('../internals/global');
var aFunction = function(variable) {
    return typeof variable == 'function' ? variable : undefined;
};
module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};

},{"../internals/global":"a4GR8"}],"dancM":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = require('../internals/native-symbol');
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

},{"../internals/native-symbol":"2gIhS"}],"2gIhS":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = require('../internals/engine-v8-version');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

},{"../internals/engine-v8-version":"8Ofbb","../internals/fails":"byxLb"}],"8Ofbb":[function(require,module,exports) {
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');
var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
    match = v8.split('.');
    version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
    }
}
module.exports = version && +version;

},{"../internals/global":"a4GR8","../internals/engine-user-agent":"ihes9"}],"ihes9":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":"hqegu"}],"1rrrl":[function(require,module,exports) {
var isObject = require('../internals/is-object');
// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function(input, pref) {
    var fn, val;
    if (pref === 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (pref !== 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
};

},{"../internals/is-object":"d60Kc"}],"6sZ59":[function(require,module,exports) {
var global = require('../internals/global');
var shared = require('../internals/shared');
var has = require('../internals/has');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
var WellKnownSymbolsStore = shared('wks');
var Symbol1 = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;
module.exports = function(name) {
    if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
        if (NATIVE_SYMBOL && has(Symbol1, name)) WellKnownSymbolsStore[name] = Symbol1[name];
        else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
    return WellKnownSymbolsStore[name];
};

},{"../internals/global":"a4GR8","../internals/shared":"ic92G","../internals/has":"aVEHj","../internals/uid":"9DssZ","../internals/native-symbol":"2gIhS","../internals/use-symbol-as-uid":"dancM"}],"ic92G":[function(require,module,exports) {
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');
(module.exports = function(key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {
    });
})('versions', []).push({
    version: '3.16.1',
    mode: IS_PURE ? 'pure' : 'global',
    copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});

},{"../internals/is-pure":"dlbEd","../internals/shared-store":"4v8Nf"}],"dlbEd":[function(require,module,exports) {
module.exports = false;

},{}],"4v8Nf":[function(require,module,exports) {
var global = require('../internals/global');
var setGlobal = require('../internals/set-global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {
});
module.exports = store;

},{"../internals/global":"a4GR8","../internals/set-global":"7Z35u"}],"7Z35u":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = function(key, value) {
    try {
        // eslint-disable-next-line es/no-object-defineproperty -- safe
        Object.defineProperty(global, key, {
            value: value,
            configurable: true,
            writable: true
        });
    } catch (error) {
        global[key] = value;
    }
    return value;
};

},{"../internals/global":"a4GR8"}],"aVEHj":[function(require,module,exports) {
var toObject = require('../internals/to-object');
var hasOwnProperty = {
}.hasOwnProperty;
module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty.call(toObject(it), key);
};

},{"../internals/to-object":"ghTKi"}],"ghTKi":[function(require,module,exports) {
var requireObjectCoercible = require('../internals/require-object-coercible');
// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function(argument) {
    return Object(requireObjectCoercible(argument));
};

},{"../internals/require-object-coercible":"1XURO"}],"9DssZ":[function(require,module,exports) {
var id = 0;
var postfix = Math.random();
module.exports = function(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + ((++id) + postfix).toString(36);
};

},{}],"5FQkl":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');
// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
    return Object.defineProperty(createElement('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

},{"../internals/descriptors":"kuDzl","../internals/fails":"byxLb","../internals/document-create-element":"2WwO0"}],"2WwO0":[function(require,module,exports) {
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return EXISTS ? document.createElement(it) : {
    };
};

},{"../internals/global":"a4GR8","../internals/is-object":"d60Kc"}],"73EkF":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

},{"../internals/descriptors":"kuDzl","../internals/object-define-property":"iKHmb","../internals/create-property-descriptor":"5fdHA"}],"iKHmb":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var anObject = require('../internals/an-object');
var toPropertyKey = require('../internals/to-property-key');
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

},{"../internals/descriptors":"kuDzl","../internals/ie8-dom-define":"5FQkl","../internals/an-object":"9unxM","../internals/to-property-key":"99Lby"}],"9unxM":[function(require,module,exports) {
var isObject = require('../internals/is-object');
module.exports = function(it) {
    if (!isObject(it)) throw TypeError(String(it) + ' is not an object');
    return it;
};

},{"../internals/is-object":"d60Kc"}],"cwrrW":[function(require,module,exports) {
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var setGlobal = require('../internals/set-global');
var inspectSource = require('../internals/inspect-source');
var InternalStateModule = require('../internals/internal-state');
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var state;
    if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        state = enforceInternalState(value);
        if (!state.source) state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global) {
        if (simple) O[key] = value;
        else setGlobal(key, value);
        return;
    } else if (!unsafe) delete O[key];
    else if (!noTargetGet && O[key]) simple = true;
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

},{"../internals/global":"a4GR8","../internals/create-non-enumerable-property":"73EkF","../internals/has":"aVEHj","../internals/set-global":"7Z35u","../internals/inspect-source":"yqC5G","../internals/internal-state":"ceuiK"}],"yqC5G":[function(require,module,exports) {
var store = require('../internals/shared-store');
var functionToString = Function.toString;
// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') store.inspectSource = function(it) {
    return functionToString.call(it);
};
module.exports = store.inspectSource;

},{"../internals/shared-store":"4v8Nf"}],"ceuiK":[function(require,module,exports) {
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var objectHas = require('../internals/has');
var shared = require('../internals/shared-store');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap1 = global.WeakMap;
var set, get, has;
var enforce = function(it) {
    return has(it) ? get(it) : set(it, {
    });
};
var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        return state;
    };
};
if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap1());
    var wmget = store.get;
    var wmhas = store.has;
    var wmset = store.set;
    set = function(it, metadata) {
        if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset.call(store, it, metadata);
        return metadata;
    };
    get = function(it) {
        return wmget.call(store, it) || {
        };
    };
    has = function(it) {
        return wmhas.call(store, it);
    };
} else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
        if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return objectHas(it, STATE) ? it[STATE] : {
        };
    };
    has = function(it) {
        return objectHas(it, STATE);
    };
}
module.exports = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
};

},{"../internals/native-weak-map":"kny3R","../internals/global":"a4GR8","../internals/is-object":"d60Kc","../internals/create-non-enumerable-property":"73EkF","../internals/has":"aVEHj","../internals/shared-store":"4v8Nf","../internals/shared-key":"65Tv5","../internals/hidden-keys":"8TVAY"}],"kny3R":[function(require,module,exports) {
var global = require('../internals/global');
var inspectSource = require('../internals/inspect-source');
var WeakMap1 = global.WeakMap;
module.exports = typeof WeakMap1 === 'function' && /native code/.test(inspectSource(WeakMap1));

},{"../internals/global":"a4GR8","../internals/inspect-source":"yqC5G"}],"65Tv5":[function(require,module,exports) {
var shared = require('../internals/shared');
var uid = require('../internals/uid');
var keys = shared('keys');
module.exports = function(key) {
    return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":"ic92G","../internals/uid":"9DssZ"}],"8TVAY":[function(require,module,exports) {
module.exports = {
};

},{}],"4qgKG":[function(require,module,exports) {
var has = require('../internals/has');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
module.exports = function(target, source) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

},{"../internals/has":"aVEHj","../internals/own-keys":"dGiV1","../internals/object-get-own-property-descriptor":"hwpsT","../internals/object-define-property":"iKHmb"}],"dGiV1":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');
// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

},{"../internals/get-built-in":"hqegu","../internals/object-get-own-property-names":"38UqD","../internals/object-get-own-property-symbols":"3jR7g","../internals/an-object":"9unxM"}],"38UqD":[function(require,module,exports) {
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = enumBugKeys.concat('length', 'prototype');
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/object-keys-internal":"lhvNb","../internals/enum-bug-keys":"cEKLg"}],"lhvNb":[function(require,module,exports) {
var has = require('../internals/has');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');
module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (has(O, key = names[i++])) ~indexOf(result, key) || result.push(key);
    return result;
};

},{"../internals/has":"aVEHj","../internals/to-indexed-object":"9N8sJ","../internals/array-includes":"cmRkV","../internals/hidden-keys":"8TVAY"}],"cmRkV":[function(require,module,exports) {
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');
// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el != el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare -- NaN check
            if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++){
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};
module.exports = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};

},{"../internals/to-indexed-object":"9N8sJ","../internals/to-length":"coWuj","../internals/to-absolute-index":"bWCPe"}],"coWuj":[function(require,module,exports) {
var toInteger = require('../internals/to-integer');
var min = Math.min;
// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function(argument) {
    return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer":"gOCws"}],"gOCws":[function(require,module,exports) {
var ceil = Math.ceil;
var floor = Math.floor;
// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

},{}],"bWCPe":[function(require,module,exports) {
var toInteger = require('../internals/to-integer');
var max = Math.max;
var min = Math.min;
// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function(index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer":"gOCws"}],"cEKLg":[function(require,module,exports) {
// IE8- don't enum bug keys
module.exports = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];

},{}],"3jR7g":[function(require,module,exports) {
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],"djqhI":[function(require,module,exports) {
var fails = require('../internals/fails');
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {
};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

},{"../internals/fails":"byxLb"}],"kiY2Q":[function(require,module,exports) {
var classof = require('../internals/classof-raw');
// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(arg) {
    return classof(arg) == 'Array';
};

},{"../internals/classof-raw":"8F0bi"}],"k0ZQF":[function(require,module,exports) {
var isSymbol = require('../internals/is-symbol');
module.exports = function(argument) {
    if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a string');
    return String(argument);
};

},{"../internals/is-symbol":"hfIC8"}],"eYZeq":[function(require,module,exports) {
/* global ActiveXObject -- old IE, WSH */ var anObject = require('../internals/an-object');
var defineProperties = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};
// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
};
// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    if (iframe.style) {
        iframe.style.display = 'none';
        html.appendChild(iframe);
        // https://github.com/zloirock/core-js/issues/475
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag('document.F=Object'));
        iframeDocument.close();
        return iframeDocument.F;
    }
};
// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function() {
    try {
        activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {
    }
    NullProtoObject = document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() || NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : defineProperties(result, Properties);
};

},{"../internals/an-object":"9unxM","../internals/object-define-properties":"4aS77","../internals/enum-bug-keys":"cEKLg","../internals/hidden-keys":"8TVAY","../internals/html":"38cYd","../internals/document-create-element":"2WwO0","../internals/shared-key":"65Tv5"}],"4aS77":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var objectKeys = require('../internals/object-keys');
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);
    return O;
};

},{"../internals/descriptors":"kuDzl","../internals/object-define-property":"iKHmb","../internals/an-object":"9unxM","../internals/object-keys":"7so9x"}],"7so9x":[function(require,module,exports) {
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/object-keys-internal":"lhvNb","../internals/enum-bug-keys":"cEKLg"}],"38cYd":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":"hqegu"}],"ivjog":[function(require,module,exports) {
/* eslint-disable es/no-object-getownpropertynames -- safe */ var toIndexedObject = require('../internals/to-indexed-object');
var $getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var toString = {
}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
    try {
        return $getOwnPropertyNames(it);
    } catch (error) {
        return windowNames.slice();
    }
};
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
};

},{"../internals/to-indexed-object":"9N8sJ","../internals/object-get-own-property-names":"38UqD"}],"6xsru":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
exports.f = wellKnownSymbol;

},{"../internals/well-known-symbol":"6sZ59"}],"jDA2f":[function(require,module,exports) {
var path = require('../internals/path');
var has = require('../internals/has');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineProperty = require('../internals/object-define-property').f;
module.exports = function(NAME) {
    var Symbol1 = path.Symbol || (path.Symbol = {
    });
    if (!has(Symbol1, NAME)) defineProperty(Symbol1, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
    });
};

},{"../internals/path":"cV4BF","../internals/has":"aVEHj","../internals/well-known-symbol-wrapped":"6xsru","../internals/object-define-property":"iKHmb"}],"cV4BF":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = global;

},{"../internals/global":"a4GR8"}],"cFbSt":[function(require,module,exports) {
var defineProperty = require('../internals/object-define-property').f;
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function(it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) defineProperty(it, TO_STRING_TAG, {
        configurable: true,
        value: TAG
    });
};

},{"../internals/object-define-property":"iKHmb","../internals/has":"aVEHj","../internals/well-known-symbol":"6sZ59"}],"ciNJ0":[function(require,module,exports) {
var bind = require('../internals/function-bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var arraySpeciesCreate = require('../internals/array-species-create');
var push = [].push;
// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, that, 3);
        var length = toLength(self.length);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
        var value, result;
        for(; length > index; index++)if (NO_HOLES || index in self) {
            value = self[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
                if (IS_MAP) target[index] = result; // map
                else if (result) switch(TYPE){
                    case 3:
                        return true; // some
                    case 5:
                        return value; // find
                    case 6:
                        return index; // findIndex
                    case 2:
                        push.call(target, value); // filter
                }
                else switch(TYPE){
                    case 4:
                        return false; // every
                    case 7:
                        push.call(target, value); // filterReject
                }
            }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
};
module.exports = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod(7)
};

},{"../internals/function-bind-context":"1epb9","../internals/indexed-object":"1hg9G","../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/array-species-create":"beybx"}],"1epb9":[function(require,module,exports) {
var aFunction = require('../internals/a-function');
// optional / simple context binding
module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch(length){
        case 0:
            return function() {
                return fn.call(that);
            };
        case 1:
            return function(a) {
                return fn.call(that, a);
            };
        case 2:
            return function(a, b) {
                return fn.call(that, a, b);
            };
        case 3:
            return function(a, b, c) {
                return fn.call(that, a, b, c);
            };
    }
    return function() {
        return fn.apply(that, arguments);
    };
};

},{"../internals/a-function":"43ldr"}],"43ldr":[function(require,module,exports) {
module.exports = function(it) {
    if (typeof it != 'function') throw TypeError(String(it) + ' is not a function');
    return it;
};

},{}],"beybx":[function(require,module,exports) {
var arraySpeciesConstructor = require('../internals/array-species-constructor');
// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function(originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

},{"../internals/array-species-constructor":"ipwOm"}],"ipwOm":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');
// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function(originalArray) {
    var C;
    if (isArray(originalArray)) {
        C = originalArray.constructor;
        // cross-realm fallback
        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
        else if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
        }
    }
    return C === undefined ? Array : C;
};

},{"../internals/is-object":"d60Kc","../internals/is-array":"kiY2Q","../internals/well-known-symbol":"6sZ59"}],"k6qTH":[function(require,module,exports) {
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var has = require('../internals/has');
var isObject = require('../internals/is-object');
var defineProperty = require('../internals/object-define-property').f;
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var NativeSymbol = global.Symbol;
if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
    var EmptyStringDescriptionStore = {
    };
    // wrap Symbol constructor for correct work with undefined description
    var SymbolWrapper = function Symbol1() {
        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
        var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);
        if (description === '') EmptyStringDescriptionStore[result] = true;
        return result;
    };
    copyConstructorProperties(SymbolWrapper, NativeSymbol);
    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
    symbolPrototype.constructor = SymbolWrapper;
    var symbolToString = symbolPrototype.toString;
    var native = String(NativeSymbol('test')) == 'Symbol(test)';
    var regexp = /^Symbol\((.*)\)[^)]+$/;
    defineProperty(symbolPrototype, 'description', {
        configurable: true,
        get: function description() {
            var symbol = isObject(this) ? this.valueOf() : this;
            var string = symbolToString.call(symbol);
            if (has(EmptyStringDescriptionStore, symbol)) return '';
            var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
            return desc === '' ? undefined : desc;
        }
    });
    $({
        global: true,
        forced: true
    }, {
        Symbol: SymbolWrapper
    });
}

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/global":"a4GR8","../internals/has":"aVEHj","../internals/is-object":"d60Kc","../internals/object-define-property":"iKHmb","../internals/copy-constructor-properties":"4qgKG"}],"4gQKh":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

},{"../internals/define-well-known-symbol":"jDA2f"}],"6rypY":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');

},{"../internals/define-well-known-symbol":"jDA2f"}],"8cPMJ":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');

},{"../internals/define-well-known-symbol":"jDA2f"}],"54Wkt":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/define-well-known-symbol":"jDA2f"}],"fci7y":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');

},{"../internals/define-well-known-symbol":"jDA2f"}],"LEHqP":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');

},{"../internals/define-well-known-symbol":"jDA2f"}],"emMne":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');

},{"../internals/define-well-known-symbol":"jDA2f"}],"1pJ8K":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');

},{"../internals/define-well-known-symbol":"jDA2f"}],"aUPm6":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');

},{"../internals/define-well-known-symbol":"jDA2f"}],"h3StJ":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');

},{"../internals/define-well-known-symbol":"jDA2f"}],"jiMen":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

},{"../internals/define-well-known-symbol":"jDA2f"}],"2Dw1B":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

},{"../internals/define-well-known-symbol":"jDA2f"}],"dad1W":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');

},{"../internals/define-well-known-symbol":"jDA2f"}],"iQYvV":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var iterate = require('../internals/iterate');
var toString = require('../internals/to-string');
var $AggregateError = function AggregateError(errors, message) {
    var that = this;
    if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
    if (setPrototypeOf) // eslint-disable-next-line unicorn/error-message -- expected
    that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
    if (message !== undefined) createNonEnumerableProperty(that, 'message', toString(message));
    var errorsArray = [];
    iterate(errors, errorsArray.push, {
        that: errorsArray
    });
    createNonEnumerableProperty(that, 'errors', errorsArray);
    return that;
};
$AggregateError.prototype = create(Error.prototype, {
    constructor: createPropertyDescriptor(5, $AggregateError),
    message: createPropertyDescriptor(5, ''),
    name: createPropertyDescriptor(5, 'AggregateError')
});
// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({
    global: true
}, {
    AggregateError: $AggregateError
});

},{"../internals/export":"2mZbc","../internals/object-get-prototype-of":"4Xd6L","../internals/object-set-prototype-of":"k1Sl0","../internals/object-create":"eYZeq","../internals/create-non-enumerable-property":"73EkF","../internals/create-property-descriptor":"5fdHA","../internals/iterate":"a4R19","../internals/to-string":"k0ZQF"}],"4Xd6L":[function(require,module,exports) {
var has = require('../internals/has');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) return O.constructor.prototype;
    return O instanceof Object ? ObjectPrototype : null;
};

},{"../internals/has":"aVEHj","../internals/to-object":"ghTKi","../internals/shared-key":"65Tv5","../internals/correct-prototype-getter":"dMqx3"}],"dMqx3":[function(require,module,exports) {
var fails = require('../internals/fails');
module.exports = !fails(function() {
    function F() {
    }
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":"byxLb"}],"k1Sl0":[function(require,module,exports) {
/* eslint-disable no-proto -- safe */ var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {
} ? (function() {
    var CORRECT_SETTER = false;
    var test = {
    };
    var setter;
    try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
        setter.call(test, []);
        CORRECT_SETTER = test instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);
        else O.__proto__ = proto;
        return O;
    };
})() : undefined);

},{"../internals/an-object":"9unxM","../internals/a-possible-prototype":"4dKE2"}],"4dKE2":[function(require,module,exports) {
var isObject = require('../internals/is-object');
module.exports = function(it) {
    if (!isObject(it) && it !== null) throw TypeError("Can't set " + String(it) + ' as a prototype');
    return it;
};

},{"../internals/is-object":"d60Kc"}],"a4R19":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var bind = require('../internals/function-bind-context');
var getIteratorMethod = require('../internals/get-iterator-method');
var iteratorClose = require('../internals/iterator-close');
var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};
module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
        if (iterator) iteratorClose(iterator);
        return new Result(true, condition);
    };
    var callFn = function(value) {
        if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_ITERATOR) iterator = iterable;
    else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for(index = 0, length = toLength(iterable.length); length > index; index++){
                result = callFn(iterable[index]);
                if (result && result instanceof Result) return result;
            }
            return new Result(false);
        }
        iterator = iterFn.call(iterable);
    }
    next = iterator.next;
    while(!(step = next.call(iterator)).done){
        try {
            result = callFn(step.value);
        } catch (error) {
            iteratorClose(iterator);
            throw error;
        }
        if (typeof result == 'object' && result && result instanceof Result) return result;
    }
    return new Result(false);
};

},{"../internals/an-object":"9unxM","../internals/is-array-iterator-method":"fEVgY","../internals/to-length":"coWuj","../internals/function-bind-context":"1epb9","../internals/get-iterator-method":"btrxT","../internals/iterator-close":"ljRDT"}],"fEVgY":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;
// check on default Array iterator
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/well-known-symbol":"6sZ59","../internals/iterators":"gp9Ft"}],"gp9Ft":[function(require,module,exports) {
module.exports = {
};

},{}],"btrxT":[function(require,module,exports) {
var classof = require('../internals/classof');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function(it) {
    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

},{"../internals/classof":"gO6DW","../internals/iterators":"gp9Ft","../internals/well-known-symbol":"6sZ59"}],"gO6DW":[function(require,module,exports) {
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) == 'Arguments';
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) {
    }
};
// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

},{"../internals/to-string-tag-support":"eaplU","../internals/classof-raw":"8F0bi","../internals/well-known-symbol":"6sZ59"}],"eaplU":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {
};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

},{"../internals/well-known-symbol":"6sZ59"}],"ljRDT":[function(require,module,exports) {
var anObject = require('../internals/an-object');
module.exports = function(iterator) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) return anObject(returnMethod.call(iterator)).value;
};

},{"../internals/an-object":"9unxM"}],"12BiX":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var arraySpeciesCreate = require('../internals/array-species-create');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 9007199254740991;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
var isConcatSpreadable = function(O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
};
var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({
    target: 'Array',
    proto: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for(i = -1, length = arguments.length; i < length; i++){
            E = i === -1 ? O : arguments[i];
            if (isConcatSpreadable(E)) {
                len = toLength(E.length);
                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);
            } else {
                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A, n++, E);
            }
        }
        A.length = n;
        return A;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/is-array":"kiY2Q","../internals/is-object":"d60Kc","../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/create-property":"9DQWQ","../internals/array-species-create":"beybx","../internals/array-method-has-species-support":"67F2b","../internals/well-known-symbol":"6sZ59","../internals/engine-v8-version":"8Ofbb"}],"9DQWQ":[function(require,module,exports) {
'use strict';
var toPropertyKey = require('../internals/to-property-key');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = function(object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
};

},{"../internals/to-property-key":"99Lby","../internals/object-define-property":"iKHmb","../internals/create-property-descriptor":"5fdHA"}],"67F2b":[function(require,module,exports) {
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
module.exports = function(METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {
        };
        constructor[SPECIES] = function() {
            return {
                foo: 1
            };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
    });
};

},{"../internals/fails":"byxLb","../internals/well-known-symbol":"6sZ59","../internals/engine-v8-version":"8Ofbb"}],"6Qlz9":[function(require,module,exports) {
var $ = require('../internals/export');
var copyWithin = require('../internals/array-copy-within');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
$({
    target: 'Array',
    proto: true
}, {
    copyWithin: copyWithin
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');

},{"../internals/export":"2mZbc","../internals/array-copy-within":"gaD2u","../internals/add-to-unscopables":"d20N8"}],"gaD2u":[function(require,module,exports) {
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var min = Math.min;
// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */ , start /* = 0, end = @length */ ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
    }
    while((count--) > 0){
        if (from in O) O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
    }
    return O;
};

},{"../internals/to-object":"ghTKi","../internals/to-absolute-index":"bWCPe","../internals/to-length":"coWuj"}],"d20N8":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var create = require('../internals/object-create');
var definePropertyModule = require('../internals/object-define-property');
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;
// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
});
// add a key to Array.prototype[@@unscopables]
module.exports = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
};

},{"../internals/well-known-symbol":"6sZ59","../internals/object-create":"eYZeq","../internals/object-define-property":"iKHmb"}],"isBXe":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $every = require('../internals/array-iteration').every;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('every');
// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD
}, {
    every: function every(callbackfn /* , thisArg */ ) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/array-method-is-strict":"2hfFU"}],"2hfFU":[function(require,module,exports) {
'use strict';
var fails = require('../internals/fails');
module.exports = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function() {
        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
        method.call(null, argument || function() {
            throw 1;
        }, 1);
    });
};

},{"../internals/fails":"byxLb"}],"48CiI":[function(require,module,exports) {
var $ = require('../internals/export');
var fill = require('../internals/array-fill');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({
    target: 'Array',
    proto: true
}, {
    fill: fill
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

},{"../internals/export":"2mZbc","../internals/array-fill":"hYFo3","../internals/add-to-unscopables":"d20N8"}],"hYFo3":[function(require,module,exports) {
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */ ) {
    var O = toObject(this);
    var length = toLength(O.length);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
};

},{"../internals/to-object":"ghTKi","../internals/to-absolute-index":"bWCPe","../internals/to-length":"coWuj"}],"cKRrG":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $filter = require('../internals/array-iteration').filter;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    filter: function filter(callbackfn /* , thisArg */ ) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/array-method-has-species-support":"67F2b"}],"eHU6M":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $find = require('../internals/array-iteration').find;
var addToUnscopables = require('../internals/add-to-unscopables');
var FIND = 'find';
var SKIPS_HOLES = true;
// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function() {
    SKIPS_HOLES = false;
});
// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES
}, {
    find: function find(callbackfn /* , that = undefined */ ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/add-to-unscopables":"d20N8"}],"kfYJb":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $findIndex = require('../internals/array-iteration').findIndex;
var addToUnscopables = require('../internals/add-to-unscopables');
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;
// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
    SKIPS_HOLES = false;
});
// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES
}, {
    findIndex: function findIndex(callbackfn /* , that = undefined */ ) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/add-to-unscopables":"d20N8"}],"am9Da":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var toInteger = require('../internals/to-integer');
var arraySpeciesCreate = require('../internals/array-species-create');
// `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat
$({
    target: 'Array',
    proto: true
}, {
    flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : undefined;
        var O = toObject(this);
        var sourceLen = toLength(O.length);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
        return A;
    }
});

},{"../internals/export":"2mZbc","../internals/flatten-into-array":"cH9ZO","../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/to-integer":"gOCws","../internals/array-species-create":"beybx"}],"cH9ZO":[function(require,module,exports) {
'use strict';
var isArray = require('../internals/is-array');
var toLength = require('../internals/to-length');
var bind = require('../internals/function-bind-context');
// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
    var element;
    while(sourceIndex < sourceLen){
        if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray(element)) targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
            else {
                if (targetIndex >= 9007199254740991) throw TypeError('Exceed the acceptable array length');
                target[targetIndex] = element;
            }
            targetIndex++;
        }
        sourceIndex++;
    }
    return targetIndex;
};
module.exports = flattenIntoArray;

},{"../internals/is-array":"kiY2Q","../internals/to-length":"coWuj","../internals/function-bind-context":"1epb9"}],"cMHMc":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var aFunction = require('../internals/a-function');
var arraySpeciesCreate = require('../internals/array-species-create');
// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({
    target: 'Array',
    proto: true
}, {
    flatMap: function flatMap(callbackfn /* , thisArg */ ) {
        var O = toObject(this);
        var sourceLen = toLength(O.length);
        var A;
        aFunction(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return A;
    }
});

},{"../internals/export":"2mZbc","../internals/flatten-into-array":"cH9ZO","../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/a-function":"43ldr","../internals/array-species-create":"beybx"}],"aTBjZ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var forEach = require('../internals/array-for-each');
// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({
    target: 'Array',
    proto: true,
    forced: [].forEach != forEach
}, {
    forEach: forEach
});

},{"../internals/export":"2mZbc","../internals/array-for-each":"dwspA"}],"dwspA":[function(require,module,exports) {
'use strict';
var $forEach = require('../internals/array-iteration').forEach;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('forEach');
// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;

},{"../internals/array-iteration":"ciNJ0","../internals/array-method-is-strict":"2hfFU"}],"fUGae":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
    // eslint-disable-next-line es/no-array-from -- required for testing
    Array.from(iterable);
});
// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({
    target: 'Array',
    stat: true,
    forced: INCORRECT_ITERATION
}, {
    from: from
});

},{"../internals/export":"2mZbc","../internals/array-from":"hkJ4P","../internals/check-correctness-of-iteration":"lO6Bq"}],"hkJ4P":[function(require,module,exports) {
'use strict';
var bind = require('../internals/function-bind-context');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var getIteratorMethod = require('../internals/get-iterator-method');
// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var index = 0;
    var length, result, step, iterator, next, value;
    if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
    // if the target is not iterable or it's an array with the default iterator - use a simple case
    if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = iteratorMethod.call(O);
        next = iterator.next;
        result = new C();
        for(; !(step = next.call(iterator)).done; index++){
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [
                step.value,
                index
            ], true) : step.value;
            createProperty(result, index, value);
        }
    } else {
        length = toLength(O.length);
        result = new C(length);
        for(; length > index; index++){
            value = mapping ? mapfn(O[index], index) : O[index];
            createProperty(result, index, value);
        }
    }
    result.length = index;
    return result;
};

},{"../internals/function-bind-context":"1epb9","../internals/to-object":"ghTKi","../internals/call-with-safe-iteration-closing":"cNS8J","../internals/is-array-iterator-method":"fEVgY","../internals/to-length":"coWuj","../internals/create-property":"9DQWQ","../internals/get-iterator-method":"btrxT"}],"cNS8J":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var iteratorClose = require('../internals/iterator-close');
// call something on iterator step with safe closing on error
module.exports = function(iterator, fn, value, ENTRIES) {
    try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (error) {
        iteratorClose(iterator);
        throw error;
    }
};

},{"../internals/an-object":"9unxM","../internals/iterator-close":"ljRDT"}],"lO6Bq":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;
try {
    var called = 0;
    var iteratorWithReturn = {
        next: function() {
            return {
                done: !!called++
            };
        },
        'return': function() {
            SAFE_CLOSING = true;
        }
    };
    iteratorWithReturn[ITERATOR] = function() {
        return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function() {
        throw 2;
    });
} catch (error) {
}
module.exports = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
        var object = {
        };
        object[ITERATOR] = function() {
            return {
                next: function() {
                    return {
                        done: ITERATION_SUPPORT = true
                    };
                }
            };
        };
        exec(object);
    } catch (error) {
    }
    return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":"6sZ59"}],"X9Fp2":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({
    target: 'Array',
    proto: true
}, {
    includes: function includes(el /* , fromIndex = 0 */ ) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/export":"2mZbc","../internals/array-includes":"cmRkV","../internals/add-to-unscopables":"d20N8"}],"gpPtE":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-array-prototype-indexof -- required for testing */ var $ = require('../internals/export');
var $indexOf = require('../internals/array-includes').indexOf;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [
    1
].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$({
    target: 'Array',
    proto: true,
    forced: NEGATIVE_ZERO || !STRICT_METHOD
}, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */ ) {
        return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-includes":"cmRkV","../internals/array-method-is-strict":"2hfFU"}],"9vHDR":[function(require,module,exports) {
var $ = require('../internals/export');
var isArray = require('../internals/is-array');
// `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray
$({
    target: 'Array',
    stat: true
}, {
    isArray: isArray
});

},{"../internals/export":"2mZbc","../internals/is-array":"kiY2Q"}],"8YPvt":[function(require,module,exports) {
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function(iterated, kind) {
    setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind: kind // kind
    });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function() {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
        state.target = undefined;
        return {
            value: undefined,
            done: true
        };
    }
    if (kind == 'keys') return {
        value: index,
        done: false
    };
    if (kind == 'values') return {
        value: target[index],
        done: false
    };
    return {
        value: [
            index,
            target[index]
        ],
        done: false
    };
}, 'values');
// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"../internals/to-indexed-object":"9N8sJ","../internals/add-to-unscopables":"d20N8","../internals/iterators":"gp9Ft","../internals/internal-state":"ceuiK","../internals/define-iterator":"6ZPeX"}],"6ZPeX":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function() {
    return this;
};
module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch(KIND){
            case KEYS:
                return function keys() {
                    return new IteratorConstructor(this, KIND);
                };
            case VALUES:
                return function values() {
                    return new IteratorConstructor(this, KIND);
                };
            case ENTRIES:
                return function entries() {
                    return new IteratorConstructor(this, KIND);
                };
        }
        return function() {
            return new IteratorConstructor(this);
        };
    };
    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    // fix native
    if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
            // Set @@toStringTag to native iterators
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
    }
    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
            return nativeIterator.call(this);
        };
    }
    // define iterator
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
    Iterators[NAME] = defaultIterator;
    // export additional methods
    if (DEFAULT) {
        methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for(KEY in methods)if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);
        else $({
            target: NAME,
            proto: true,
            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
    }
    return methods;
};

},{"../internals/export":"2mZbc","../internals/create-iterator-constructor":"biz26","../internals/object-get-prototype-of":"4Xd6L","../internals/object-set-prototype-of":"k1Sl0","../internals/set-to-string-tag":"cFbSt","../internals/create-non-enumerable-property":"73EkF","../internals/redefine":"cwrrW","../internals/well-known-symbol":"6sZ59","../internals/is-pure":"dlbEd","../internals/iterators":"gp9Ft","../internals/iterators-core":"eCtuD"}],"biz26":[function(require,module,exports) {
'use strict';
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');
var returnThis = function() {
    return this;
};
module.exports = function(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(1, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
};

},{"../internals/iterators-core":"eCtuD","../internals/object-create":"eYZeq","../internals/create-property-descriptor":"5fdHA","../internals/set-to-string-tag":"cFbSt","../internals/iterators":"gp9Ft"}],"eCtuD":[function(require,module,exports) {
'use strict';
var fails = require('../internals/fails');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
var returnThis = function() {
    return this;
};
// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {
    var test = {
    };
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {
};
// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
module.exports = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/fails":"byxLb","../internals/object-get-prototype-of":"4Xd6L","../internals/create-non-enumerable-property":"73EkF","../internals/has":"aVEHj","../internals/well-known-symbol":"6sZ59","../internals/is-pure":"dlbEd"}],"fcdvD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IndexedObject = require('../internals/indexed-object');
var toIndexedObject = require('../internals/to-indexed-object');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var nativeJoin = [].join;
var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');
// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({
    target: 'Array',
    proto: true,
    forced: ES3_STRINGS || !STRICT_METHOD
}, {
    join: function join(separator) {
        return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
});

},{"../internals/export":"2mZbc","../internals/indexed-object":"1hg9G","../internals/to-indexed-object":"9N8sJ","../internals/array-method-is-strict":"2hfFU"}],"bVRYF":[function(require,module,exports) {
var $ = require('../internals/export');
var lastIndexOf = require('../internals/array-last-index-of');
// `Array.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
// eslint-disable-next-line es/no-array-prototype-lastindexof -- required for testing
$({
    target: 'Array',
    proto: true,
    forced: lastIndexOf !== [].lastIndexOf
}, {
    lastIndexOf: lastIndexOf
});

},{"../internals/export":"2mZbc","../internals/array-last-index-of":"3G0we"}],"3G0we":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-array-prototype-lastindexof -- safe */ var toIndexedObject = require('../internals/to-indexed-object');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [
    1
].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */ ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $lastIndexOf.apply(this, arguments) || 0;
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for(; index >= 0; index--)if (index in O && O[index] === searchElement) return index || 0;
    return -1;
} : $lastIndexOf;

},{"../internals/to-indexed-object":"9N8sJ","../internals/to-integer":"gOCws","../internals/to-length":"coWuj","../internals/array-method-is-strict":"2hfFU"}],"g11io":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $map = require('../internals/array-iteration').map;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    map: function map(callbackfn /* , thisArg */ ) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/array-method-has-species-support":"67F2b"}],"hwsFe":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var createProperty = require('../internals/create-property');
var ISNT_GENERIC = fails(function() {
    function F() {
    }
    // eslint-disable-next-line es/no-array-of -- required for testing
    return !(Array.of.call(F) instanceof F);
});
// `Array.of` method
// https://tc39.es/ecma262/#sec-array.of
// WebKit Array.of isn't generic
$({
    target: 'Array',
    stat: true,
    forced: ISNT_GENERIC
}, {
    of: function of() {
        var index = 0;
        var argumentsLength = arguments.length;
        var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
        while(argumentsLength > index)createProperty(result, index, arguments[index++]);
        result.length = argumentsLength;
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/create-property":"9DQWQ"}],"iTsnC":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $reduce = require('../internals/array-reduce').left;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var CHROME_VERSION = require('../internals/engine-v8-version');
var IS_NODE = require('../internals/engine-is-node');
var STRICT_METHOD = arrayMethodIsStrict('reduce');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD || CHROME_BUG
}, {
    reduce: function reduce(callbackfn /* , initialValue */ ) {
        return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-reduce":"8zC1E","../internals/array-method-is-strict":"2hfFU","../internals/engine-v8-version":"8Ofbb","../internals/engine-is-node":"gpWpt"}],"8zC1E":[function(require,module,exports) {
var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
var toLength = require('../internals/to-length');
// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
        aFunction(callbackfn);
        var O = toObject(that);
        var self = IndexedObject(O);
        var length = toLength(O.length);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while(true){
            if (index in self) {
                memo = self[index];
                index += i;
                break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) throw TypeError('Reduce of empty array with no initial value');
        }
        for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self) memo = callbackfn(memo, self[index], index, O);
        return memo;
    };
};
module.exports = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod(true)
};

},{"../internals/a-function":"43ldr","../internals/to-object":"ghTKi","../internals/indexed-object":"1hg9G","../internals/to-length":"coWuj"}],"gpWpt":[function(require,module,exports) {
var classof = require('../internals/classof-raw');
var global = require('../internals/global');
module.exports = classof(global.process) == 'process';

},{"../internals/classof-raw":"8F0bi","../internals/global":"a4GR8"}],"dTOyk":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $reduceRight = require('../internals/array-reduce').right;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var CHROME_VERSION = require('../internals/engine-v8-version');
var IS_NODE = require('../internals/engine-is-node');
var STRICT_METHOD = arrayMethodIsStrict('reduceRight');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
// `Array.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-array.prototype.reduceright
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD || CHROME_BUG
}, {
    reduceRight: function reduceRight(callbackfn /* , initialValue */ ) {
        return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-reduce":"8zC1E","../internals/array-method-is-strict":"2hfFU","../internals/engine-v8-version":"8Ofbb","../internals/engine-is-node":"gpWpt"}],"4H4sw":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var isArray = require('../internals/is-array');
var nativeReverse = [].reverse;
var test = [
    1,
    2
];
// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({
    target: 'Array',
    proto: true,
    forced: String(test) === String(test.reverse())
}, {
    reverse: function reverse() {
        // eslint-disable-next-line no-self-assign -- dirty hack
        if (isArray(this)) this.length = this.length;
        return nativeReverse.call(this);
    }
});

},{"../internals/export":"2mZbc","../internals/is-array":"kiY2Q"}],"1Qy0K":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var toIndexedObject = require('../internals/to-indexed-object');
var createProperty = require('../internals/create-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;
// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = toLength(O.length);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
        var Constructor, result, n;
        if (isArray(O)) {
            Constructor = O.constructor;
            // cross-realm fallback
            if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) Constructor = undefined;
            else if (isObject(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null) Constructor = undefined;
            }
            if (Constructor === Array || Constructor === undefined) return nativeSlice.call(O, k, fin);
        }
        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/is-object":"d60Kc","../internals/is-array":"kiY2Q","../internals/to-absolute-index":"bWCPe","../internals/to-length":"coWuj","../internals/to-indexed-object":"9N8sJ","../internals/create-property":"9DQWQ","../internals/well-known-symbol":"6sZ59","../internals/array-method-has-species-support":"67F2b"}],"3MKkN":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $some = require('../internals/array-iteration').some;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('some');
// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD
}, {
    some: function some(callbackfn /* , thisArg */ ) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/array-iteration":"ciNJ0","../internals/array-method-is-strict":"2hfFU"}],"6yoc0":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var fails = require('../internals/fails');
var internalSort = require('../internals/array-sort');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var FF = require('../internals/engine-ff-version');
var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
var V8 = require('../internals/engine-v8-version');
var WEBKIT = require('../internals/engine-webkit-version');
var test = [];
var nativeSort = test.sort;
// IE8-
var FAILS_ON_UNDEFINED = fails(function() {
    test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function() {
    test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');
var STABLE_SORT = !fails(function() {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 70;
    if (FF && FF > 3) return;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var result = '';
    var code, chr, value, index;
    // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
    for(code = 65; code < 76; code++){
        chr = String.fromCharCode(code);
        switch(code){
            case 66:
            case 69:
            case 70:
            case 72:
                value = 3;
                break;
            case 68:
            case 71:
                value = 4;
                break;
            default:
                value = 2;
        }
        for(index = 0; index < 47; index++)test.push({
            k: chr + index,
            v: value
        });
    }
    test.sort(function(a, b) {
        return b.v - a.v;
    });
    for(index = 0; index < test.length; index++){
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr) result += chr;
    }
    return result !== 'DGBEFHACIJK';
});
var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
var getSortCompare = function(comparefn) {
    return function(x, y) {
        if (y === undefined) return -1;
        if (x === undefined) return 1;
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        return toString(x) > toString(y) ? 1 : -1;
    };
};
// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({
    target: 'Array',
    proto: true,
    forced: FORCED
}, {
    sort: function sort(comparefn) {
        if (comparefn !== undefined) aFunction(comparefn);
        var array = toObject(this);
        if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);
        var items = [];
        var arrayLength = toLength(array.length);
        var itemsLength, index;
        for(index = 0; index < arrayLength; index++)if (index in array) items.push(array[index]);
        items = internalSort(items, getSortCompare(comparefn));
        itemsLength = items.length;
        index = 0;
        while(index < itemsLength)array[index] = items[index++];
        while(index < arrayLength)delete array[index++];
        return array;
    }
});

},{"../internals/export":"2mZbc","../internals/a-function":"43ldr","../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/fails":"byxLb","../internals/array-sort":"aFml7","../internals/array-method-is-strict":"2hfFU","../internals/engine-ff-version":"ftzYY","../internals/engine-is-ie-or-edge":"5GiwV","../internals/engine-v8-version":"8Ofbb","../internals/engine-webkit-version":"6Jcx4"}],"aFml7":[function(require,module,exports) {
// TODO: use something more complex like timsort?
var floor = Math.floor;
var mergeSort = function(array, comparefn) {
    var length = array.length;
    var middle = floor(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(mergeSort(array.slice(0, middle), comparefn), mergeSort(array.slice(middle), comparefn), comparefn);
};
var insertionSort = function(array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;
    while(i < length){
        j = i;
        element = array[i];
        while(j && comparefn(array[j - 1], element) > 0)array[j] = array[--j];
        if (j !== i++) array[j] = element;
    }
    return array;
};
var merge = function(left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;
    var result = [];
    while(lindex < llength || rindex < rlength)if (lindex < llength && rindex < rlength) result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);
    else result.push(lindex < llength ? left[lindex++] : right[rindex++]);
    return result;
};
module.exports = mergeSort;

},{}],"ftzYY":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var firefox = userAgent.match(/firefox\/(\d+)/i);
module.exports = !!firefox && +firefox[1];

},{"../internals/engine-user-agent":"ihes9"}],"5GiwV":[function(require,module,exports) {
var UA = require('../internals/engine-user-agent');
module.exports = /MSIE|Trident/.test(UA);

},{"../internals/engine-user-agent":"ihes9"}],"6Jcx4":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
module.exports = !!webkit && +webkit[1];

},{"../internals/engine-user-agent":"ihes9"}],"5m0CI":[function(require,module,exports) {
var setSpecies = require('../internals/set-species');
// `Array[@@species]` getter
// https://tc39.es/ecma262/#sec-get-array-@@species
setSpecies('Array');

},{"../internals/set-species":"99lPJ"}],"99lPJ":[function(require,module,exports) {
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var definePropertyModule = require('../internals/object-define-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');
var SPECIES = wellKnownSymbol('species');
module.exports = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function() {
            return this;
        }
    });
};

},{"../internals/get-built-in":"hqegu","../internals/object-define-property":"iKHmb","../internals/well-known-symbol":"6sZ59","../internals/descriptors":"kuDzl"}],"65ZuR":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toObject = require('../internals/to-object');
var arraySpeciesCreate = require('../internals/array-species-create');
var createProperty = require('../internals/create-property');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';
// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    splice: function splice(start, deleteCount /* , ...items */ ) {
        var O = toObject(this);
        var len = toLength(O.length);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
        else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
        } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
        }
        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        A = arraySpeciesCreate(O, actualDeleteCount);
        for(k = 0; k < actualDeleteCount; k++){
            from = actualStart + k;
            if (from in O) createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
            for(k = actualStart; k < len - actualDeleteCount; k++){
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O) O[to] = O[from];
                else delete O[to];
            }
            for(k = len; k > len - actualDeleteCount + insertCount; k--)delete O[k - 1];
        } else if (insertCount > actualDeleteCount) for(k = len - actualDeleteCount; k > actualStart; k--){
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O) O[to] = O[from];
            else delete O[to];
        }
        for(k = 0; k < insertCount; k++)O[k + actualStart] = arguments[k + 2];
        O.length = len - actualDeleteCount + insertCount;
        return A;
    }
});

},{"../internals/export":"2mZbc","../internals/to-absolute-index":"bWCPe","../internals/to-integer":"gOCws","../internals/to-length":"coWuj","../internals/to-object":"ghTKi","../internals/array-species-create":"beybx","../internals/create-property":"9DQWQ","../internals/array-method-has-species-support":"67F2b"}],"hIgzb":[function(require,module,exports) {
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');

},{"../internals/add-to-unscopables":"d20N8"}],"2lymx":[function(require,module,exports) {
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');

},{"../internals/add-to-unscopables":"d20N8"}],"4p0zL":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var arrayBufferModule = require('../internals/array-buffer');
var setSpecies = require('../internals/set-species');
var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer1 = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];
// `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor
$({
    global: true,
    forced: NativeArrayBuffer !== ArrayBuffer1
}, {
    ArrayBuffer: ArrayBuffer1
});
setSpecies(ARRAY_BUFFER);

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/array-buffer":"hMeAx","../internals/set-species":"99lPJ"}],"hMeAx":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var fails = require('../internals/fails');
var anInstance = require('../internals/an-instance');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var IEEE754 = require('../internals/ieee754');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var defineProperty = require('../internals/object-define-property').f;
var arrayFill = require('../internals/array-fill');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError1 = global.RangeError;
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;
var packInt8 = function(number) {
    return [
        number & 255
    ];
};
var packInt16 = function(number) {
    return [
        number & 255,
        number >> 8 & 255
    ];
};
var packInt32 = function(number) {
    return [
        number & 255,
        number >> 8 & 255,
        number >> 16 & 255,
        number >> 24 & 255
    ];
};
var unpackInt32 = function(buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};
var packFloat32 = function(number) {
    return packIEEE754(number, 23, 4);
};
var packFloat64 = function(number) {
    return packIEEE754(number, 52, 8);
};
var addGetter = function(Constructor, key) {
    defineProperty(Constructor[PROTOTYPE], key, {
        get: function() {
            return getInternalState(this)[key];
        }
    });
};
var get = function(view, count, index, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError1(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = bytes.slice(start, start + count);
    return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError1(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);
    for(var i = 0; i < count; i++)bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER) {
    $ArrayBuffer = function ArrayBuffer1(length) {
        anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = toIndex(length);
        setInternalState(this, {
            bytes: arrayFill.call(new Array(byteLength), 0),
            byteLength: byteLength
        });
        if (!DESCRIPTORS) this.byteLength = byteLength;
    };
    $DataView = function DataView1(buffer, byteOffset, byteLength) {
        anInstance(this, $DataView, DATA_VIEW);
        anInstance(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = getInternalState(buffer).byteLength;
        var offset = toInteger(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError1('Wrong offset');
        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError1(WRONG_LENGTH);
        setInternalState(this, {
            buffer: buffer,
            byteLength: byteLength,
            byteOffset: offset
        });
        if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
        }
    };
    if (DESCRIPTORS) {
        addGetter($ArrayBuffer, 'byteLength');
        addGetter($DataView, 'buffer');
        addGetter($DataView, 'byteLength');
        addGetter($DataView, 'byteOffset');
    }
    redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
        },
        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
        },
        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
        }
    });
} else {
    /* eslint-disable no-new -- required for testing */ if (!fails(function() {
        NativeArrayBuffer(1);
    }) || !fails(function() {
        new NativeArrayBuffer(-1);
    }) || fails(function() {
        new NativeArrayBuffer();
        new NativeArrayBuffer(1.5);
        new NativeArrayBuffer(NaN);
        return NativeArrayBuffer.name != ARRAY_BUFFER;
    })) {
        /* eslint-enable no-new -- required for testing */ $ArrayBuffer = function ArrayBuffer1(length) {
            anInstance(this, $ArrayBuffer);
            return new NativeArrayBuffer(toIndex(length));
        };
        var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
        for(var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;)if (!((key = keys[j++]) in $ArrayBuffer)) createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
        ArrayBufferPrototype.constructor = $ArrayBuffer;
    }
    // WebKit bug - the same parent prototype for typed arrays and data view
    if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) setPrototypeOf($DataViewPrototype, ObjectPrototype);
    // iOS Safari 7.x bug
    var testView = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = $DataViewPrototype.setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
        setInt8: function setInt8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
        }
    }, {
        unsafe: true
    });
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
module.exports = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
};

},{"../internals/global":"a4GR8","../internals/descriptors":"kuDzl","../internals/array-buffer-native":"2XybU","../internals/create-non-enumerable-property":"73EkF","../internals/redefine-all":"4a8AR","../internals/fails":"byxLb","../internals/an-instance":"gTr5k","../internals/to-integer":"gOCws","../internals/to-length":"coWuj","../internals/to-index":"iXt4Q","../internals/ieee754":"8cQVO","../internals/object-get-prototype-of":"4Xd6L","../internals/object-set-prototype-of":"k1Sl0","../internals/object-get-own-property-names":"38UqD","../internals/object-define-property":"iKHmb","../internals/array-fill":"hYFo3","../internals/set-to-string-tag":"cFbSt","../internals/internal-state":"ceuiK"}],"2XybU":[function(require,module,exports) {
// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

},{}],"4a8AR":[function(require,module,exports) {
var redefine = require('../internals/redefine');
module.exports = function(target, src, options) {
    for(var key in src)redefine(target, key, src[key], options);
    return target;
};

},{"../internals/redefine":"cwrrW"}],"gTr5k":[function(require,module,exports) {
module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    return it;
};

},{}],"iXt4Q":[function(require,module,exports) {
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function(it) {
    if (it === undefined) return 0;
    var number = toInteger(it);
    var length = toLength(number);
    if (number !== length) throw RangeError('Wrong length or index');
    return length;
};

},{"../internals/to-integer":"gOCws","../internals/to-length":"coWuj"}],"8cQVO":[function(require,module,exports) {
// IEEE754 conversions based on https://github.com/feross/ieee754
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var pack = function(number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number || number === Infinity) {
        // eslint-disable-next-line no-self-compare -- NaN check
        mantissa = number != number ? 1 : 0;
        exponent = eMax;
    } else {
        exponent = floor(log(number) / LN2);
        if (number * (c = pow(2, -exponent)) < 1) {
            exponent--;
            c *= 2;
        }
        if (exponent + eBias >= 1) number += rt / c;
        else number += rt * pow(2, 1 - eBias);
        if (number * c >= 2) {
            exponent++;
            c /= 2;
        }
        if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
        } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent = exponent + eBias;
        } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
        }
    }
    for(; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    for(; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
    buffer[--index] |= sign * 128;
    return buffer;
};
var unpack = function(buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    for(; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    for(; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
    if (exponent === 0) exponent = 1 - eBias;
    else if (exponent === eMax) return mantissa ? NaN : sign ? -Infinity : Infinity;
    else {
        mantissa = mantissa + pow(2, mantissaLength);
        exponent = exponent - eBias;
    }
    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};
module.exports = {
    pack: pack,
    unpack: unpack
};

},{}],"30MAW":[function(require,module,exports) {
var $ = require('../internals/export');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
// `ArrayBuffer.isView` method
// https://tc39.es/ecma262/#sec-arraybuffer.isview
$({
    target: 'ArrayBuffer',
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS
}, {
    isView: ArrayBufferViewCore.isView
});

},{"../internals/export":"2mZbc","../internals/array-buffer-view-core":"zd7ve"}],"zd7ve":[function(require,module,exports) {
'use strict';
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var classof = require('../internals/classof');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var defineProperty = require('../internals/object-define-property').f;
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var uid = require('../internals/uid');
var Int8Array1 = global.Int8Array;
var Int8ArrayPrototype = Int8Array1 && Int8Array1.prototype;
var Uint8ClampedArray1 = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray1 && Uint8ClampedArray1.prototype;
var TypedArray = Int8Array1 && getPrototypeOf(Int8Array1);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME, Constructor, Prototype;
var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
};
var BigIntArrayConstructorsList = {
    BigInt64Array: 8,
    BigUint64Array: 8
};
var isView = function isView1(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return klass === 'DataView' || has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
};
var isTypedArray = function(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
};
var aTypedArray = function(it) {
    if (isTypedArray(it)) return it;
    throw TypeError('Target is not a typed array');
};
var aTypedArrayConstructor = function(C) {
    if (setPrototypeOf && !isPrototypeOf.call(TypedArray, C)) throw TypeError('Target is not a typed array constructor');
    return C;
};
var exportTypedArrayMethod = function(KEY, property, forced) {
    if (!DESCRIPTORS) return;
    if (forced) for(var ARRAY in TypedArrayConstructorsList){
        var TypedArrayConstructor = global[ARRAY];
        if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) try {
            delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
        }
    }
    if (!TypedArrayPrototype[KEY] || forced) redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
};
var exportTypedArrayStaticMethod = function(KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!DESCRIPTORS) return;
    if (setPrototypeOf) {
        if (forced) for(ARRAY in TypedArrayConstructorsList){
            TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) try {
                delete TypedArrayConstructor[KEY];
            } catch (error) {
            }
        }
        if (!TypedArray[KEY] || forced) // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
        try {
            return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
        } catch (error) {
        }
        else return;
    }
    for(ARRAY in TypedArrayConstructorsList){
        TypedArrayConstructor = global[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) redefine(TypedArrayConstructor, KEY, property);
    }
};
for(NAME in TypedArrayConstructorsList){
    Constructor = global[NAME];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
    else NATIVE_ARRAY_BUFFER_VIEWS = false;
}
for(NAME in BigIntArrayConstructorsList){
    Constructor = global[NAME];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
}
// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
    // eslint-disable-next-line no-shadow -- safe
    TypedArray = function TypedArray1() {
        throw TypeError('Incorrect invocation');
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
}
if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
    TypedArrayPrototype = TypedArray.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
}
// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
    TYPED_ARRAY_TAG_REQIRED = true;
    defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
        get: function() {
            return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
        }
    });
    for(NAME in TypedArrayConstructorsList)if (global[NAME]) createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
}
module.exports = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
    TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
    aTypedArray: aTypedArray,
    aTypedArrayConstructor: aTypedArrayConstructor,
    exportTypedArrayMethod: exportTypedArrayMethod,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    isView: isView,
    isTypedArray: isTypedArray,
    TypedArray: TypedArray,
    TypedArrayPrototype: TypedArrayPrototype
};

},{"../internals/array-buffer-native":"2XybU","../internals/descriptors":"kuDzl","../internals/global":"a4GR8","../internals/is-object":"d60Kc","../internals/has":"aVEHj","../internals/classof":"gO6DW","../internals/create-non-enumerable-property":"73EkF","../internals/redefine":"cwrrW","../internals/object-define-property":"iKHmb","../internals/object-get-prototype-of":"4Xd6L","../internals/object-set-prototype-of":"k1Sl0","../internals/well-known-symbol":"6sZ59","../internals/uid":"9DssZ"}],"ktSH3":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var ArrayBufferModule = require('../internals/array-buffer');
var anObject = require('../internals/an-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var speciesConstructor = require('../internals/species-constructor');
var ArrayBuffer1 = ArrayBufferModule.ArrayBuffer;
var DataView1 = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer1.prototype.slice;
var INCORRECT_SLICE = fails(function() {
    return !new ArrayBuffer1(2).slice(1, undefined).byteLength;
});
// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({
    target: 'ArrayBuffer',
    proto: true,
    unsafe: true,
    forced: INCORRECT_SLICE
}, {
    slice: function slice(start, end) {
        if (nativeArrayBufferSlice !== undefined && end === undefined) return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
        var length = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        var result = new (speciesConstructor(this, ArrayBuffer1))(toLength(fin - first));
        var viewSource = new DataView1(this);
        var viewTarget = new DataView1(result);
        var index = 0;
        while(first < fin)viewTarget.setUint8(index++, viewSource.getUint8(first++));
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/array-buffer":"hMeAx","../internals/an-object":"9unxM","../internals/to-absolute-index":"bWCPe","../internals/to-length":"coWuj","../internals/species-constructor":"6tv7V"}],"6tv7V":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');
// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

},{"../internals/an-object":"9unxM","../internals/a-function":"43ldr","../internals/well-known-symbol":"6sZ59"}],"6n7Um":[function(require,module,exports) {
var $ = require('../internals/export');
var ArrayBufferModule = require('../internals/array-buffer');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
// `DataView` constructor
// https://tc39.es/ecma262/#sec-dataview-constructor
$({
    global: true,
    forced: !NATIVE_ARRAY_BUFFER
}, {
    DataView: ArrayBufferModule.DataView
});

},{"../internals/export":"2mZbc","../internals/array-buffer":"hMeAx","../internals/array-buffer-native":"2XybU"}],"e1hhS":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var FORCED = fails(function() {
    return new Date(1600000000000).getYear() !== 120;
});
var getFullYear = Date.prototype.getFullYear;
// `Date.prototype.getYear` method
// https://tc39.es/ecma262/#sec-date.prototype.getyear
$({
    target: 'Date',
    proto: true,
    forced: FORCED
}, {
    getYear: function getYear() {
        return getFullYear.call(this) - 1900;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb"}],"lGf1w":[function(require,module,exports) {
var $ = require('../internals/export');
// `Date.now` method
// https://tc39.es/ecma262/#sec-date.now
$({
    target: 'Date',
    stat: true
}, {
    now: function now() {
        return new Date().getTime();
    }
});

},{"../internals/export":"2mZbc"}],"4GJ8v":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toInteger = require('../internals/to-integer');
var getTime = Date.prototype.getTime;
var setFullYear = Date.prototype.setFullYear;
// `Date.prototype.setYear` method
// https://tc39.es/ecma262/#sec-date.prototype.setyear
$({
    target: 'Date',
    proto: true
}, {
    setYear: function setYear(year) {
        // validate
        getTime.call(this);
        var yi = toInteger(year);
        var yyyy = 0 <= yi && yi <= 99 ? yi + 1900 : yi;
        return setFullYear.call(this, yyyy);
    }
});

},{"../internals/export":"2mZbc","../internals/to-integer":"gOCws"}],"dNoww":[function(require,module,exports) {
var $ = require('../internals/export');
// `Date.prototype.toGMTString` method
// https://tc39.es/ecma262/#sec-date.prototype.togmtstring
$({
    target: 'Date',
    proto: true
}, {
    toGMTString: Date.prototype.toUTCString
});

},{"../internals/export":"2mZbc"}],"7mzsp":[function(require,module,exports) {
var $ = require('../internals/export');
var toISOString = require('../internals/date-to-iso-string');
// `Date.prototype.toISOString` method
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
$({
    target: 'Date',
    proto: true,
    forced: Date.prototype.toISOString !== toISOString
}, {
    toISOString: toISOString
});

},{"../internals/export":"2mZbc","../internals/date-to-iso-string":"2rORF"}],"2rORF":[function(require,module,exports) {
'use strict';
var fails = require('../internals/fails');
var padStart = require('../internals/string-pad').start;
var abs = Math.abs;
var DatePrototype = Date.prototype;
var getTime = DatePrototype.getTime;
var nativeDateToISOString = DatePrototype.toISOString;
// `Date.prototype.toISOString` method implementation
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
module.exports = fails(function() {
    return nativeDateToISOString.call(new Date(-50000000000000 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function() {
    nativeDateToISOString.call(new Date(NaN));
}) ? function toISOString() {
    if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
    var date = this;
    var year = date.getUTCFullYear();
    var milliseconds = date.getUTCMilliseconds();
    var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
    return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
} : nativeDateToISOString;

},{"../internals/fails":"byxLb","../internals/string-pad":"lqvFq"}],"lqvFq":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var repeat = require('../internals/string-repeat');
var requireObjectCoercible = require('../internals/require-object-coercible');
var ceil = Math.ceil;
// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function(IS_END) {
    return function($this, maxLength, fillString) {
        var S = toString(requireObjectCoercible($this));
        var stringLength = S.length;
        var fillStr = fillString === undefined ? ' ' : toString(fillString);
        var intMaxLength = toLength(maxLength);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr == '') return S;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
        return IS_END ? S + stringFiller : stringFiller + S;
    };
};
module.exports = {
    // `String.prototype.padStart` method
    // https://tc39.es/ecma262/#sec-string.prototype.padstart
    start: createMethod(false),
    // `String.prototype.padEnd` method
    // https://tc39.es/ecma262/#sec-string.prototype.padend
    end: createMethod(true)
};

},{"../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/string-repeat":"8cSMA","../internals/require-object-coercible":"1XURO"}],"8cSMA":[function(require,module,exports) {
'use strict';
var toInteger = require('../internals/to-integer');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
    var str = toString(requireObjectCoercible(this));
    var result = '';
    var n = toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
    for(; n > 0; n >>>= 1, str += str)if (n & 1) result += str;
    return result;
};

},{"../internals/to-integer":"gOCws","../internals/to-string":"k0ZQF","../internals/require-object-coercible":"1XURO"}],"ay4bx":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var toPrimitive = require('../internals/to-primitive');
var FORCED = fails(function() {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function() {
            return 1;
        }
    }) !== 1;
});
// `Date.prototype.toJSON` method
// https://tc39.es/ecma262/#sec-date.prototype.tojson
$({
    target: 'Date',
    proto: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive(O, 'number');
        return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/to-object":"ghTKi","../internals/to-primitive":"LSiNW"}],"fObwG":[function(require,module,exports) {
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var dateToPrimitive = require('../internals/date-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;
// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!(TO_PRIMITIVE in DatePrototype)) createNonEnumerableProperty(DatePrototype, TO_PRIMITIVE, dateToPrimitive);

},{"../internals/create-non-enumerable-property":"73EkF","../internals/date-to-primitive":"gDvqe","../internals/well-known-symbol":"6sZ59"}],"gDvqe":[function(require,module,exports) {
'use strict';
var anObject = require('../internals/an-object');
var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function(hint) {
    anObject(this);
    if (hint === 'string' || hint === 'default') hint = 'string';
    else if (hint !== 'number') throw TypeError('Incorrect hint');
    return ordinaryToPrimitive(this, hint);
};

},{"../internals/an-object":"9unxM","../internals/ordinary-to-primitive":"1rrrl"}],"7pcaU":[function(require,module,exports) {
var redefine = require('../internals/redefine');
var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;
// `Date.prototype.toString` method
// https://tc39.es/ecma262/#sec-date.prototype.tostring
if (String(new Date(NaN)) != INVALID_DATE) redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare -- NaN check
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
});

},{"../internals/redefine":"cwrrW"}],"7stNY":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toString = require('../internals/to-string');
var raw = /[\w*+\-./@]/;
var hex = function(code, length) {
    var result = code.toString(16);
    while(result.length < length)result = '0' + result;
    return result;
};
// `escape` method
// https://tc39.es/ecma262/#sec-escape-string
$({
    global: true
}, {
    escape: function escape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, code;
        while(index < length){
            chr = str.charAt(index++);
            if (raw.test(chr)) result += chr;
            else {
                code = chr.charCodeAt(0);
                if (code < 256) result += '%' + hex(code, 2);
                else result += '%u' + hex(code, 4).toUpperCase();
            }
        }
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/to-string":"k0ZQF"}],"jrjf4":[function(require,module,exports) {
var $ = require('../internals/export');
var bind = require('../internals/function-bind');
// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
$({
    target: 'Function',
    proto: true
}, {
    bind: bind
});

},{"../internals/export":"2mZbc","../internals/function-bind":"5QaOT"}],"5QaOT":[function(require,module,exports) {
'use strict';
var aFunction = require('../internals/a-function');
var isObject = require('../internals/is-object');
var slice = [].slice;
var factories = {
};
var construct = function(C, argsLength, args) {
    if (!(argsLength in factories)) {
        for(var list = [], i = 0; i < argsLength; i++)list[i] = 'a[' + i + ']';
        // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
        factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
    }
    return factories[argsLength](C, args);
};
// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */ ) {
    var fn = aFunction(this);
    var partArgs = slice.call(arguments, 1);
    var boundFunction = function bound() {
        var args = partArgs.concat(slice.call(arguments));
        return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
    };
    if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
    return boundFunction;
};

},{"../internals/a-function":"43ldr","../internals/is-object":"d60Kc"}],"9on83":[function(require,module,exports) {
'use strict';
var isObject = require('../internals/is-object');
var definePropertyModule = require('../internals/object-define-property');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype;
// `Function.prototype[@@hasInstance]` method
// https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance
if (!(HAS_INSTANCE in FunctionPrototype)) definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, {
    value: function(O) {
        if (typeof this != 'function' || !isObject(O)) return false;
        if (!isObject(this.prototype)) return O instanceof this;
        // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
        while(O = getPrototypeOf(O))if (this.prototype === O) return true;
        return false;
    }
});

},{"../internals/is-object":"d60Kc","../internals/object-define-property":"iKHmb","../internals/object-get-prototype-of":"4Xd6L","../internals/well-known-symbol":"6sZ59"}],"2tRvX":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var defineProperty = require('../internals/object-define-property').f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';
// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function() {
        try {
            return FunctionPrototypeToString.call(this).match(nameRE)[1];
        } catch (error) {
            return '';
        }
    }
});

},{"../internals/descriptors":"kuDzl","../internals/object-define-property":"iKHmb"}],"JI3Gz":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$({
    global: true
}, {
    globalThis: global
});

},{"../internals/export":"2mZbc","../internals/global":"a4GR8"}],"2B2ps":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var fails = require('../internals/fails');
var $stringify = getBuiltIn('JSON', 'stringify');
var re = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var fix = function(match, offset, string) {
    var prev = string.charAt(offset - 1);
    var next = string.charAt(offset + 1);
    if (low.test(match) && !hi.test(next) || hi.test(match) && !low.test(prev)) return '\\u' + match.charCodeAt(0).toString(16);
    return match;
};
var FORCED = fails(function() {
    return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
});
if ($stringify) // `JSON.stringify` method
// https://tc39.es/ecma262/#sec-json.stringify
// https://github.com/tc39/proposal-well-formed-stringify
$({
    target: 'JSON',
    stat: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
        var result = $stringify.apply(null, arguments);
        return typeof result == 'string' ? result.replace(re, fix) : result;
    }
});

},{"../internals/export":"2mZbc","../internals/get-built-in":"hqegu","../internals/fails":"byxLb"}],"6YcXi":[function(require,module,exports) {
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');
// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);

},{"../internals/global":"a4GR8","../internals/set-to-string-tag":"cFbSt"}],"dgMLm":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');
// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
module.exports = collection('Map', function(init) {
    return function Map1() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionStrong);

},{"../internals/collection":"8qCpd","../internals/collection-strong":"hibUM"}],"8qCpd":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var InternalMetadataModule = require('../internals/internal-metadata');
var iterate = require('../internals/iterate');
var anInstance = require('../internals/an-instance');
var isObject = require('../internals/is-object');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var setToStringTag = require('../internals/set-to-string-tag');
var inheritIfRequired = require('../internals/inherit-if-required');
module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var Constructor = NativeConstructor;
    var exported = {
    };
    var fixMethod = function(KEY) {
        var nativeMethod = NativePrototype[KEY];
        redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
            nativeMethod.call(this, value === 0 ? 0 : value);
            return this;
        } : KEY == 'delete' ? function(key) {
            return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'get' ? function get(key) {
            return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'has' ? function has(key) {
            return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : function set(key, value) {
            nativeMethod.call(this, key === 0 ? 0 : key, value);
            return this;
        });
    };
    var REPLACE = isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
        new NativeConstructor().entries().next();
    })));
    if (REPLACE) {
        // create collection constructor
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
    } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        // early implementations not supports chaining
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {
        } : -0, 1) != instance;
        // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
        var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
        });
        // most early implementations doesn't supports iterables, most modern - not close it correctly
        // eslint-disable-next-line no-new -- required for testing
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
        });
        // for early implementations -0 and +0 not the same
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
            // V8 ~ Chromium 42- fails only with 5+ elements
            var $instance = new NativeConstructor();
            var index = 5;
            while(index--)$instance[ADDER](index, index);
            return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
                anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
                var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                if (iterable != undefined) iterate(iterable, that[ADDER], {
                    that: that,
                    AS_ENTRIES: IS_MAP
                });
                return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod('delete');
            fixMethod('has');
            IS_MAP && fixMethod('get');
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        // weak collections should not contains .clear method
        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
    }
    exported[CONSTRUCTOR_NAME] = Constructor;
    $({
        global: true,
        forced: Constructor != NativeConstructor
    }, exported);
    setToStringTag(Constructor, CONSTRUCTOR_NAME);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
};

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/is-forced":"djqhI","../internals/redefine":"cwrrW","../internals/internal-metadata":"5OjLO","../internals/iterate":"a4R19","../internals/an-instance":"gTr5k","../internals/is-object":"d60Kc","../internals/fails":"byxLb","../internals/check-correctness-of-iteration":"lO6Bq","../internals/set-to-string-tag":"cFbSt","../internals/inherit-if-required":"5Ef3J"}],"5OjLO":[function(require,module,exports) {
var $ = require('../internals/export');
var hiddenKeys = require('../internals/hidden-keys');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternalModule = require('../internals/object-get-own-property-names-external');
var uid = require('../internals/uid');
var FREEZING = require('../internals/freezing');
var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = Object.isExtensible || function() {
    return true;
};
var setMetadata = function(it) {
    defineProperty(it, METADATA, {
        value: {
            objectID: 'O' + id++,
            weakData: {
            } // weak collections IDs
        }
    });
};
var fastKey = function(it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F';
        // not necessary to add metadata
        if (!create) return 'E';
        // add missing metadata
        setMetadata(it);
    // return object ID
    }
    return it[METADATA].objectID;
};
var getWeakData = function(it, create) {
    if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true;
        // not necessary to add metadata
        if (!create) return false;
        // add missing metadata
        setMetadata(it);
    // return the store of weak collections IDs
    }
    return it[METADATA].weakData;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
};
var enable = function() {
    meta.enable = function() {
    };
    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = [].splice;
    var test = {
    };
    test[METADATA] = 1;
    // prevent exposing of metadata key
    if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
            var result = getOwnPropertyNames(it);
            for(var i = 0, length = result.length; i < length; i++)if (result[i] === METADATA) {
                splice.call(result, i, 1);
                break;
            }
            return result;
        };
        $({
            target: 'Object',
            stat: true,
            forced: true
        }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
    }
};
var meta = module.exports = {
    enable: enable,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

},{"../internals/export":"2mZbc","../internals/hidden-keys":"8TVAY","../internals/is-object":"d60Kc","../internals/has":"aVEHj","../internals/object-define-property":"iKHmb","../internals/object-get-own-property-names":"38UqD","../internals/object-get-own-property-names-external":"ivjog","../internals/uid":"9DssZ","../internals/freezing":"8zb2E"}],"8zb2E":[function(require,module,exports) {
var fails = require('../internals/fails');
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({
    }));
});

},{"../internals/fails":"byxLb"}],"5Ef3J":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var setPrototypeOf = require('../internals/object-set-prototype-of');
// makes subclassing work correct for wrapped built-ins
module.exports = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (// it can work only with native `setPrototypeOf`
    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
    return $this;
};

},{"../internals/is-object":"d60Kc","../internals/object-set-prototype-of":"k1Sl0"}],"hibUM":[function(require,module,exports) {
'use strict';
var defineProperty = require('../internals/object-define-property').f;
var create = require('../internals/object-create');
var redefineAll = require('../internals/redefine-all');
var bind = require('../internals/function-bind-context');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var defineIterator = require('../internals/define-iterator');
var setSpecies = require('../internals/set-species');
var DESCRIPTORS = require('../internals/descriptors');
var fastKey = require('../internals/internal-metadata').fastKey;
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
module.exports = {
    getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
            anInstance(that, C, CONSTRUCTOR_NAME);
            setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                index: create(null),
                first: undefined,
                last: undefined,
                size: 0
            });
            if (!DESCRIPTORS) that.size = 0;
            if (iterable != undefined) iterate(iterable, that[ADDER], {
                that: that,
                AS_ENTRIES: IS_MAP
            });
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            // change existing entry
            if (entry) entry.value = value;
            else {
                state.last = entry = {
                    index: index = fastKey(key, true),
                    key: key,
                    value: value,
                    previous: previous = state.last,
                    next: undefined,
                    removed: false
                };
                if (!state.first) state.first = entry;
                if (previous) previous.next = entry;
                if (DESCRIPTORS) state.size++;
                else that.size++;
                // add to index
                if (index !== 'F') state.index[index] = entry;
            }
            return that;
        };
        var getEntry = function(that, key) {
            var state = getInternalState(that);
            // fast case
            var index = fastKey(key);
            var entry;
            if (index !== 'F') return state.index[index];
            // frozen object case
            for(entry = state.first; entry; entry = entry.next){
                if (entry.key == key) return entry;
            }
        };
        redefineAll(C.prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
                var that = this;
                var state = getInternalState(that);
                var data = state.index;
                var entry = state.first;
                while(entry){
                    entry.removed = true;
                    if (entry.previous) entry.previous = entry.previous.next = undefined;
                    delete data[entry.index];
                    entry = entry.next;
                }
                state.first = state.last = undefined;
                if (DESCRIPTORS) state.size = 0;
                else that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            'delete': function(key) {
                var that = this;
                var state = getInternalState(that);
                var entry = getEntry(that, key);
                if (entry) {
                    var next = entry.next;
                    var prev = entry.previous;
                    delete state.index[entry.index];
                    entry.removed = true;
                    if (prev) prev.next = next;
                    if (next) next.previous = prev;
                    if (state.first == entry) state.first = next;
                    if (state.last == entry) state.last = prev;
                    if (DESCRIPTORS) state.size--;
                    else that.size--;
                }
                return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach(callbackfn /* , that = undefined */ ) {
                var state = getInternalState(this);
                var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                var entry;
                while(entry = entry ? entry.next : state.first){
                    boundFunction(entry.value, entry.key, this);
                    // revert to the last existing entry
                    while(entry && entry.removed)entry = entry.previous;
                }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has(key) {
                return !!getEntry(this, key);
            }
        });
        redefineAll(C.prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get(key) {
                var entry = getEntry(this, key);
                return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set(key, value) {
                return define(this, key === 0 ? 0 : key, value);
            }
        } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add(value) {
                return define(this, value = value === 0 ? 0 : value, value);
            }
        });
        if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
            get: function() {
                return getInternalState(this).size;
            }
        });
        return C;
    },
    setStrong: function(C, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.entries
        // https://tc39.es/ecma262/#sec-map.prototype.keys
        // https://tc39.es/ecma262/#sec-map.prototype.values
        // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
        // https://tc39.es/ecma262/#sec-set.prototype.entries
        // https://tc39.es/ecma262/#sec-set.prototype.keys
        // https://tc39.es/ecma262/#sec-set.prototype.values
        // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
        defineIterator(C, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
                type: ITERATOR_NAME,
                target: iterated,
                state: getInternalCollectionState(iterated),
                kind: kind,
                last: undefined
            });
        }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            // revert to the last existing entry
            while(entry && entry.removed)entry = entry.previous;
            // get next entry
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                // or finish the iteration
                state.target = undefined;
                return {
                    value: undefined,
                    done: true
                };
            }
            // return step by kind
            if (kind == 'keys') return {
                value: entry.key,
                done: false
            };
            if (kind == 'values') return {
                value: entry.value,
                done: false
            };
            return {
                value: [
                    entry.key,
                    entry.value
                ],
                done: false
            };
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
        // `{ Map, Set }.prototype[@@species]` accessors
        // https://tc39.es/ecma262/#sec-get-map-@@species
        // https://tc39.es/ecma262/#sec-get-set-@@species
        setSpecies(CONSTRUCTOR_NAME);
    }
};

},{"../internals/object-define-property":"iKHmb","../internals/object-create":"eYZeq","../internals/redefine-all":"4a8AR","../internals/function-bind-context":"1epb9","../internals/an-instance":"gTr5k","../internals/iterate":"a4R19","../internals/define-iterator":"6ZPeX","../internals/set-species":"99lPJ","../internals/descriptors":"kuDzl","../internals/internal-metadata":"5OjLO","../internals/internal-state":"ceuiK"}],"6Q3zo":[function(require,module,exports) {
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');
// eslint-disable-next-line es/no-math-acosh -- required for testing
var $acosh = Math.acosh;
var log = Math.log;
var sqrt = Math.sqrt;
var LN2 = Math.LN2;
var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) != 710 || $acosh(Infinity) != Infinity;
// `Math.acosh` method
// https://tc39.es/ecma262/#sec-math.acosh
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log(x) + LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }
});

},{"../internals/export":"2mZbc","../internals/math-log1p":"isHMF"}],"isHMF":[function(require,module,exports) {
var log = Math.log;
// `Math.log1p` method implementation
// https://tc39.es/ecma262/#sec-math.log1p
// eslint-disable-next-line es/no-math-log1p -- safe
module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -0.00000001 && x < 0.00000001 ? x - x * x / 2 : log(1 + x);
};

},{}],"d1XOI":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-asinh -- required for testing
var $asinh = Math.asinh;
var log = Math.log;
var sqrt = Math.sqrt;
function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// `Math.asinh` method
// https://tc39.es/ecma262/#sec-math.asinh
// Tor Browser bug: Math.asinh(0) -> -0
$({
    target: 'Math',
    stat: true,
    forced: !($asinh && 1 / $asinh(0) > 0)
}, {
    asinh: asinh
});

},{"../internals/export":"2mZbc"}],"5D0SG":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-atanh -- required for testing
var $atanh = Math.atanh;
var log = Math.log;
// `Math.atanh` method
// https://tc39.es/ecma262/#sec-math.atanh
// Tor Browser bug: Math.atanh(-0) -> 0
$({
    target: 'Math',
    stat: true,
    forced: !($atanh && 1 / $atanh(-0) < 0)
}, {
    atanh: function atanh(x) {
        return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    }
});

},{"../internals/export":"2mZbc"}],"l5TVA":[function(require,module,exports) {
var $ = require('../internals/export');
var sign = require('../internals/math-sign');
var abs = Math.abs;
var pow = Math.pow;
// `Math.cbrt` method
// https://tc39.es/ecma262/#sec-math.cbrt
$({
    target: 'Math',
    stat: true
}, {
    cbrt: function cbrt(x) {
        return sign(x = +x) * pow(abs(x), 1 / 3);
    }
});

},{"../internals/export":"2mZbc","../internals/math-sign":"hGl9f"}],"hGl9f":[function(require,module,exports) {
// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
// eslint-disable-next-line es/no-math-sign -- safe
module.exports = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"bJrnh":[function(require,module,exports) {
var $ = require('../internals/export');
var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E;
// `Math.clz32` method
// https://tc39.es/ecma262/#sec-math.clz32
$({
    target: 'Math',
    stat: true
}, {
    clz32: function clz32(x) {
        return x >>>= 0, 32;
    }
});

},{"../internals/export":"2mZbc"}],"6w8zd":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
// eslint-disable-next-line es/no-math-cosh -- required for testing
var $cosh = Math.cosh;
var abs = Math.abs;
var E = Math.E;
// `Math.cosh` method
// https://tc39.es/ecma262/#sec-math.cosh
$({
    target: 'Math',
    stat: true,
    forced: !$cosh || $cosh(710) === Infinity
}, {
    cosh: function cosh(x) {
        var t = expm1(abs(x) - 1) + 1;
        return (t + 1 / (t * E * E)) * (E / 2);
    }
});

},{"../internals/export":"2mZbc","../internals/math-expm1":"iqG48"}],"iqG48":[function(require,module,exports) {
// eslint-disable-next-line es/no-math-expm1 -- safe
var $expm1 = Math.expm1;
var exp = Math.exp;
// `Math.expm1` method implementation
// https://tc39.es/ecma262/#sec-math.expm1
module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-0.00000000000000002) != -0.00000000000000002 ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -0.000001 && x < 0.000001 ? x + x * x / 2 : exp(x) - 1;
} : $expm1;

},{}],"9DJbl":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
// `Math.expm1` method
// https://tc39.es/ecma262/#sec-math.expm1
// eslint-disable-next-line es/no-math-expm1 -- required for testing
$({
    target: 'Math',
    stat: true,
    forced: expm1 != Math.expm1
}, {
    expm1: expm1
});

},{"../internals/export":"2mZbc","../internals/math-expm1":"iqG48"}],"6tufR":[function(require,module,exports) {
var $ = require('../internals/export');
var fround = require('../internals/math-fround');
// `Math.fround` method
// https://tc39.es/ecma262/#sec-math.fround
$({
    target: 'Math',
    stat: true
}, {
    fround: fround
});

},{"../internals/export":"2mZbc","../internals/math-fround":"hI6TW"}],"hI6TW":[function(require,module,exports) {
var sign = require('../internals/math-sign');
var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);
var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
};
// `Math.fround` method implementation
// https://tc39.es/ecma262/#sec-math.fround
// eslint-disable-next-line es/no-math-fround -- safe
module.exports = Math.fround || function fround(x) {
    var $abs = abs(x);
    var $sign = sign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
};

},{"../internals/math-sign":"hGl9f"}],"aSB3F":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-hypot -- required for testing
var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt;
// Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546
var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
// `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot
$({
    target: 'Math',
    stat: true,
    forced: BUGGY
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while(i < aLen){
            arg = abs(arguments[i++]);
            if (larg < arg) {
                div = larg / arg;
                sum = sum * div * div + 1;
                larg = arg;
            } else if (arg > 0) {
                div = arg / larg;
                sum += div * div;
            } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * sqrt(sum);
    }
});

},{"../internals/export":"2mZbc"}],"5Tpna":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-math-imul -- required for testing
var $imul = Math.imul;
var FORCED = fails(function() {
    return $imul(4294967295, 5) != -5 || $imul.length != 2;
});
// `Math.imul` method
// https://tc39.es/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    imul: function imul(x, y) {
        var UINT16 = 65535;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb"}],"bTcHD":[function(require,module,exports) {
var $ = require('../internals/export');
var log = Math.log;
var LOG10E = Math.LOG10E;
// `Math.log10` method
// https://tc39.es/ecma262/#sec-math.log10
$({
    target: 'Math',
    stat: true
}, {
    log10: function log10(x) {
        return log(x) * LOG10E;
    }
});

},{"../internals/export":"2mZbc"}],"jNyU5":[function(require,module,exports) {
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');
// `Math.log1p` method
// https://tc39.es/ecma262/#sec-math.log1p
$({
    target: 'Math',
    stat: true
}, {
    log1p: log1p
});

},{"../internals/export":"2mZbc","../internals/math-log1p":"isHMF"}],"2m7Uz":[function(require,module,exports) {
var $ = require('../internals/export');
var log = Math.log;
var LN2 = Math.LN2;
// `Math.log2` method
// https://tc39.es/ecma262/#sec-math.log2
$({
    target: 'Math',
    stat: true
}, {
    log2: function log2(x) {
        return log(x) / LN2;
    }
});

},{"../internals/export":"2mZbc"}],"7yRUV":[function(require,module,exports) {
var $ = require('../internals/export');
var sign = require('../internals/math-sign');
// `Math.sign` method
// https://tc39.es/ecma262/#sec-math.sign
$({
    target: 'Math',
    stat: true
}, {
    sign: sign
});

},{"../internals/export":"2mZbc","../internals/math-sign":"hGl9f"}],"loaKI":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var expm1 = require('../internals/math-expm1');
var abs = Math.abs;
var exp = Math.exp;
var E = Math.E;
var FORCED = fails(function() {
    // eslint-disable-next-line es/no-math-sinh -- required for testing
    return Math.sinh(-0.00000000000000002) != -0.00000000000000002;
});
// `Math.sinh` method
// https://tc39.es/ecma262/#sec-math.sinh
// V8 near Chromium 38 has a problem with very small numbers
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    sinh: function sinh(x) {
        return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/math-expm1":"iqG48"}],"dwPS4":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
var exp = Math.exp;
// `Math.tanh` method
// https://tc39.es/ecma262/#sec-math.tanh
$({
    target: 'Math',
    stat: true
}, {
    tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }
});

},{"../internals/export":"2mZbc","../internals/math-expm1":"iqG48"}],"96Wzg":[function(require,module,exports) {
var setToStringTag = require('../internals/set-to-string-tag');
// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);

},{"../internals/set-to-string-tag":"cFbSt"}],"31xhu":[function(require,module,exports) {
var $ = require('../internals/export');
var ceil = Math.ceil;
var floor = Math.floor;
// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
$({
    target: 'Math',
    stat: true
}, {
    trunc: function trunc(it) {
        return (it > 0 ? floor : ceil)(it);
    }
});

},{"../internals/export":"2mZbc"}],"5DN40":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var has = require('../internals/has');
var classof = require('../internals/classof-raw');
var inheritIfRequired = require('../internals/inherit-if-required');
var isSymbol = require('../internals/is-symbol');
var toPrimitive = require('../internals/to-primitive');
var fails = require('../internals/fails');
var create = require('../internals/object-create');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var defineProperty = require('../internals/object-define-property').f;
var trim = require('../internals/string-trim').trim;
var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function(argument) {
    if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a number');
    var it = toPrimitive(argument, 'number');
    var first, third, radix, maxCode, digits, length, index, code;
    if (typeof it == 'string' && it.length > 2) {
        it = trim(it);
        first = it.charCodeAt(0);
        if (first === 43 || first === 45) {
            third = it.charCodeAt(2);
            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
        } else if (first === 48) {
            switch(it.charCodeAt(1)){
                case 66:
                case 98:
                    radix = 2;
                    maxCode = 49;
                    break; // fast equal of /^0b[01]+$/i
                case 79:
                case 111:
                    radix = 8;
                    maxCode = 55;
                    break; // fast equal of /^0o[0-7]+$/i
                default:
                    return +it;
            }
            digits = it.slice(2);
            length = digits.length;
            for(index = 0; index < length; index++){
                code = digits.charCodeAt(index);
                // parseInt parses a string to a first unavailable symbol
                // but ToNumber should return NaN if a string contains unavailable symbols
                if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
        }
    }
    return +it;
};
// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number1(value) {
        var it = arguments.length < 1 ? 0 : value;
        var dummy = this;
        return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
            NumberPrototype.valueOf.call(dummy);
        }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
    };
    for(var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(','), j = 0, key; keys.length > j; j++)if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    redefine(global, NUMBER, NumberWrapper);
}

},{"../internals/descriptors":"kuDzl","../internals/global":"a4GR8","../internals/is-forced":"djqhI","../internals/redefine":"cwrrW","../internals/has":"aVEHj","../internals/classof-raw":"8F0bi","../internals/inherit-if-required":"5Ef3J","../internals/is-symbol":"hfIC8","../internals/to-primitive":"LSiNW","../internals/fails":"byxLb","../internals/object-create":"eYZeq","../internals/object-get-own-property-names":"38UqD","../internals/object-get-own-property-descriptor":"hwpsT","../internals/object-define-property":"iKHmb","../internals/string-trim":"crV5l"}],"crV5l":[function(require,module,exports) {
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var whitespaces = require('../internals/whitespaces');
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');
// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function(TYPE) {
    return function($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
    };
};
module.exports = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
};

},{"../internals/require-object-coercible":"1XURO","../internals/to-string":"k0ZQF","../internals/whitespaces":"l0FoE"}],"l0FoE":[function(require,module,exports) {
// a string of all valid unicode whitespaces
module.exports = "\t\n\v\f\r \xa0              　  ﻿";

},{}],"6N90G":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.EPSILON` constant
// https://tc39.es/ecma262/#sec-number.epsilon
$({
    target: 'Number',
    stat: true
}, {
    EPSILON: Math.pow(2, -52)
});

},{"../internals/export":"2mZbc"}],"hI7wQ":[function(require,module,exports) {
var $ = require('../internals/export');
var numberIsFinite = require('../internals/number-is-finite');
// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
$({
    target: 'Number',
    stat: true
}, {
    isFinite: numberIsFinite
});

},{"../internals/export":"2mZbc","../internals/number-is-finite":"19jl2"}],"19jl2":[function(require,module,exports) {
var global = require('../internals/global');
var globalIsFinite = global.isFinite;
// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe
module.exports = Number.isFinite || function isFinite(it) {
    return typeof it == 'number' && globalIsFinite(it);
};

},{"../internals/global":"a4GR8"}],"57kzb":[function(require,module,exports) {
var $ = require('../internals/export');
var isInteger = require('../internals/is-integer');
// `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger
$({
    target: 'Number',
    stat: true
}, {
    isInteger: isInteger
});

},{"../internals/export":"2mZbc","../internals/is-integer":"eoyrV"}],"eoyrV":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var floor = Math.floor;
// `Number.isInteger` method implementation
// https://tc39.es/ecma262/#sec-number.isinteger
module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"../internals/is-object":"d60Kc"}],"aJ0lS":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan
$({
    target: 'Number',
    stat: true
}, {
    isNaN: function isNaN(number) {
        // eslint-disable-next-line no-self-compare -- NaN check
        return number != number;
    }
});

},{"../internals/export":"2mZbc"}],"2sa8K":[function(require,module,exports) {
var $ = require('../internals/export');
var isInteger = require('../internals/is-integer');
var abs = Math.abs;
// `Number.isSafeInteger` method
// https://tc39.es/ecma262/#sec-number.issafeinteger
$({
    target: 'Number',
    stat: true
}, {
    isSafeInteger: function isSafeInteger(number) {
        return isInteger(number) && abs(number) <= 9007199254740991;
    }
});

},{"../internals/export":"2mZbc","../internals/is-integer":"eoyrV"}],"ceCFQ":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer
$({
    target: 'Number',
    stat: true
}, {
    MAX_SAFE_INTEGER: 9007199254740991
});

},{"../internals/export":"2mZbc"}],"cfRrX":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer
$({
    target: 'Number',
    stat: true
}, {
    MIN_SAFE_INTEGER: -9007199254740991
});

},{"../internals/export":"2mZbc"}],"9MahJ":[function(require,module,exports) {
var $ = require('../internals/export');
var parseFloat = require('../internals/number-parse-float');
// `Number.parseFloat` method
// https://tc39.es/ecma262/#sec-number.parseFloat
// eslint-disable-next-line es/no-number-parsefloat -- required for testing
$({
    target: 'Number',
    stat: true,
    forced: Number.parseFloat != parseFloat
}, {
    parseFloat: parseFloat
});

},{"../internals/export":"2mZbc","../internals/number-parse-float":"9D8Wd"}],"9D8Wd":[function(require,module,exports) {
var global = require('../internals/global');
var toString = require('../internals/to-string');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var $parseFloat = global.parseFloat;
var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;
// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
    var trimmedString = trim(toString(string));
    var result = $parseFloat(trimmedString);
    return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"../internals/global":"a4GR8","../internals/to-string":"k0ZQF","../internals/string-trim":"crV5l","../internals/whitespaces":"l0FoE"}],"lJYd7":[function(require,module,exports) {
var $ = require('../internals/export');
var parseInt = require('../internals/number-parse-int');
// `Number.parseInt` method
// https://tc39.es/ecma262/#sec-number.parseint
// eslint-disable-next-line es/no-number-parseint -- required for testing
$({
    target: 'Number',
    stat: true,
    forced: Number.parseInt != parseInt
}, {
    parseInt: parseInt
});

},{"../internals/export":"2mZbc","../internals/number-parse-int":"aSmbJ"}],"aSmbJ":[function(require,module,exports) {
var global = require('../internals/global');
var toString = require('../internals/to-string');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;
// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
    var S = trim(toString(string));
    return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : $parseInt;

},{"../internals/global":"a4GR8","../internals/to-string":"k0ZQF","../internals/string-trim":"crV5l","../internals/whitespaces":"l0FoE"}],"THlev":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toInteger = require('../internals/to-integer');
var thisNumberValue = require('../internals/this-number-value');
var repeat = require('../internals/string-repeat');
var fails = require('../internals/fails');
var nativeToFixed = 1..toFixed;
var floor = Math.floor;
var pow = function(x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x) {
    var n = 0;
    var x2 = x;
    while(x2 >= 4096){
        n += 12;
        x2 /= 4096;
    }
    while(x2 >= 2){
        n += 1;
        x2 /= 2;
    }
    return n;
};
var multiply = function(data, n, c) {
    var index = -1;
    var c2 = c;
    while((++index) < 6){
        c2 += n * data[index];
        data[index] = c2 % 10000000;
        c2 = floor(c2 / 10000000);
    }
};
var divide = function(data, n) {
    var index = 6;
    var c = 0;
    while((--index) >= 0){
        c += data[index];
        data[index] = floor(c / n);
        c = c % n * 10000000;
    }
};
var dataToString = function(data) {
    var index = 6;
    var s = '';
    while((--index) >= 0)if (s !== '' || index === 0 || data[index] !== 0) {
        var t = String(data[index]);
        s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
    return s;
};
var FORCED = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000100..toFixed(0) !== '1000000000000000128') || !fails(function() {
    // V8 ~ Android 4.3-
    nativeToFixed.call({
    });
});
// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({
    target: 'Number',
    proto: true,
    forced: FORCED
}, {
    toFixed: function toFixed(fractionDigits) {
        var number = thisNumberValue(this);
        var fractDigits = toInteger(fractionDigits);
        var data = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        var sign = '';
        var result = '0';
        var e, z, j, k;
        if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
        // eslint-disable-next-line no-self-compare -- NaN check
        if (number != number) return 'NaN';
        if (number <= -1000000000000000000000 || number >= 1000000000000000000000) return String(number);
        if (number < 0) {
            sign = '-';
            number = -number;
        }
        if (number > 0.000000000000000000001) {
            e = log(number * pow(2, 69, 1)) - 69;
            z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
                multiply(data, 0, z);
                j = fractDigits;
                while(j >= 7){
                    multiply(data, 10000000, 0);
                    j -= 7;
                }
                multiply(data, pow(10, j, 1), 0);
                j = e - 1;
                while(j >= 23){
                    divide(data, 8388608);
                    j -= 23;
                }
                divide(data, 1 << j);
                multiply(data, 1, 1);
                divide(data, 2);
                result = dataToString(data);
            } else {
                multiply(data, 0, z);
                multiply(data, 1 << -e, 0);
                result = dataToString(data) + repeat.call('0', fractDigits);
            }
        }
        if (fractDigits > 0) {
            k = result.length;
            result = sign + (k <= fractDigits ? '0.' + repeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
        } else result = sign + result;
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/to-integer":"gOCws","../internals/this-number-value":"94b57","../internals/string-repeat":"8cSMA","../internals/fails":"byxLb"}],"94b57":[function(require,module,exports) {
var classof = require('../internals/classof-raw');
// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = function(value) {
    if (typeof value != 'number' && classof(value) != 'Number') throw TypeError('Incorrect invocation');
    return +value;
};

},{"../internals/classof-raw":"8F0bi"}],"kVGGb":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var thisNumberValue = require('../internals/this-number-value');
var nativeToPrecision = 1..toPrecision;
var FORCED = fails(function() {
    // IE7-
    return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function() {
    // V8 ~ Android 4.3-
    nativeToPrecision.call({
    });
});
// `Number.prototype.toPrecision` method
// https://tc39.es/ecma262/#sec-number.prototype.toprecision
$({
    target: 'Number',
    proto: true,
    forced: FORCED
}, {
    toPrecision: function toPrecision(precision) {
        return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/this-number-value":"94b57"}],"6ZqF3":[function(require,module,exports) {
var $ = require('../internals/export');
var assign = require('../internals/object-assign');
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({
    target: 'Object',
    stat: true,
    forced: Object.assign !== assign
}, {
    assign: assign
});

},{"../internals/export":"2mZbc","../internals/object-assign":"5r2ci"}],"5r2ci":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function() {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS && $assign({
        b: 1
    }, $assign(defineProperty({
    }, 'a', {
        enumerable: true,
        get: function() {
            defineProperty(this, 'b', {
                value: 3,
                enumerable: false
            });
        }
    }), {
        b: 2
    })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {
    };
    var B = {
    };
    // eslint-disable-next-line es/no-symbol -- safe
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function(chr) {
        B[chr] = chr;
    });
    return $assign({
    }, A)[symbol] != 7 || objectKeys($assign({
    }, B)).join('') != alphabet;
}) ? function assign(target, source) {
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    while(argumentsLength > index){
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while(length > j){
            key = keys[j++];
            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
        }
    }
    return T;
} : $assign;

},{"../internals/descriptors":"kuDzl","../internals/fails":"byxLb","../internals/object-keys":"7so9x","../internals/object-get-own-property-symbols":"3jR7g","../internals/object-property-is-enumerable":"6JYDE","../internals/to-object":"ghTKi","../internals/indexed-object":"1hg9G"}],"2xLMD":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var create = require('../internals/object-create');
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS
}, {
    create: create
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-create":"eYZeq"}],"606Pz":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var aFunction = require('../internals/a-function');
var definePropertyModule = require('../internals/object-define-property');
// `Object.prototype.__defineGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __defineGetter__: function __defineGetter__(P, getter) {
        definePropertyModule.f(toObject(this), P, {
            get: aFunction(getter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-prototype-accessors-forced":"k3GQq","../internals/to-object":"ghTKi","../internals/a-function":"43ldr","../internals/object-define-property":"iKHmb"}],"k3GQq":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var fails = require('../internals/fails');
var WEBKIT = require('../internals/engine-webkit-version');
// Forced replacement object prototype accessors methods
module.exports = IS_PURE || !fails(function() {
    // This feature detection crashes old WebKit
    // https://github.com/zloirock/core-js/issues/232
    if (WEBKIT && WEBKIT < 535) return;
    var key = Math.random();
    // In FF throws only define methods
    // eslint-disable-next-line no-undef, no-useless-call -- required for testing
    __defineSetter__.call(null, key, function() {
    });
    delete global[key];
});

},{"../internals/is-pure":"dlbEd","../internals/global":"a4GR8","../internals/fails":"byxLb","../internals/engine-webkit-version":"6Jcx4"}],"fJ9J2":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var defineProperties = require('../internals/object-define-properties');
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
$({
    target: 'Object',
    stat: true,
    forced: !DESCRIPTORS,
    sham: !DESCRIPTORS
}, {
    defineProperties: defineProperties
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-define-properties":"4aS77"}],"59EGR":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModile = require('../internals/object-define-property');
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
$({
    target: 'Object',
    stat: true,
    forced: !DESCRIPTORS,
    sham: !DESCRIPTORS
}, {
    defineProperty: objectDefinePropertyModile.f
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-define-property":"iKHmb"}],"cFhpw":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var aFunction = require('../internals/a-function');
var definePropertyModule = require('../internals/object-define-property');
// `Object.prototype.__defineSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __defineSetter__: function __defineSetter__(P, setter) {
        definePropertyModule.f(toObject(this), P, {
            set: aFunction(setter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-prototype-accessors-forced":"k3GQq","../internals/to-object":"ghTKi","../internals/a-function":"43ldr","../internals/object-define-property":"iKHmb"}],"e5Xxq":[function(require,module,exports) {
var $ = require('../internals/export');
var $entries = require('../internals/object-to-array').entries;
// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({
    target: 'Object',
    stat: true
}, {
    entries: function entries(O) {
        return $entries(O);
    }
});

},{"../internals/export":"2mZbc","../internals/object-to-array":"awU7u"}],"awU7u":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var objectKeys = require('../internals/object-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;
// `Object.{ entries, values }` methods implementation
var createMethod = function(TO_ENTRIES) {
    return function(it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while(length > i){
            key = keys[i++];
            if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) result.push(TO_ENTRIES ? [
                key,
                O[key]
            ] : O[key]);
        }
        return result;
    };
};
module.exports = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod(false)
};

},{"../internals/descriptors":"kuDzl","../internals/object-keys":"7so9x","../internals/to-indexed-object":"9N8sJ","../internals/object-property-is-enumerable":"6JYDE"}],"312H3":[function(require,module,exports) {
var $ = require('../internals/export');
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function() {
    $freeze(1);
});
// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
    }
});

},{"../internals/export":"2mZbc","../internals/freezing":"8zb2E","../internals/fails":"byxLb","../internals/is-object":"d60Kc","../internals/internal-metadata":"5OjLO"}],"e3o3h":[function(require,module,exports) {
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var createProperty = require('../internals/create-property');
// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({
    target: 'Object',
    stat: true
}, {
    fromEntries: function fromEntries(iterable) {
        var obj = {
        };
        iterate(iterable, function(k, v) {
            createProperty(obj, k, v);
        }, {
            AS_ENTRIES: true
        });
        return obj;
    }
});

},{"../internals/export":"2mZbc","../internals/iterate":"a4R19","../internals/create-property":"9DQWQ"}],"ihm1S":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var DESCRIPTORS = require('../internals/descriptors');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeGetOwnPropertyDescriptor(1);
});
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({
    target: 'Object',
    stat: true,
    forced: FORCED,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/to-indexed-object":"9N8sJ","../internals/object-get-own-property-descriptor":"hwpsT","../internals/descriptors":"kuDzl"}],"9OScw":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var ownKeys = require('../internals/own-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var createProperty = require('../internals/create-property');
// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIndexedObject(object);
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys(O);
        var result = {
        };
        var index = 0;
        var key, descriptor;
        while(keys.length > index){
            descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
            if (descriptor !== undefined) createProperty(result, key, descriptor);
        }
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/own-keys":"dGiV1","../internals/to-indexed-object":"9N8sJ","../internals/object-get-own-property-descriptor":"hwpsT","../internals/create-property":"9DQWQ"}],"iic1E":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var getOwnPropertyNames = require('../internals/object-get-own-property-names-external').f;
// eslint-disable-next-line es/no-object-getownpropertynames -- required for testing
var FAILS_ON_PRIMITIVES = fails(function() {
    return !Object.getOwnPropertyNames(1);
});
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    getOwnPropertyNames: getOwnPropertyNames
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/object-get-own-property-names-external":"ivjog"}],"e7kbe":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var nativeGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeGetPrototypeOf(1);
});
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !CORRECT_PROTOTYPE_GETTER
}, {
    getPrototypeOf: function getPrototypeOf(it) {
        return nativeGetPrototypeOf(toObject(it));
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/to-object":"ghTKi","../internals/object-get-prototype-of":"4Xd6L","../internals/correct-prototype-getter":"dMqx3"}],"5qpSm":[function(require,module,exports) {
var $ = require('../internals/export');
var is = require('../internals/same-value');
// `Object.is` method
// https://tc39.es/ecma262/#sec-object.is
$({
    target: 'Object',
    stat: true
}, {
    is: is
});

},{"../internals/export":"2mZbc","../internals/same-value":"4xcdM"}],"4xcdM":[function(require,module,exports) {
// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"5Df9G":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isExtensible(1);
});
// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    isExtensible: function isExtensible(it) {
        return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/is-object":"d60Kc"}],"jrP45":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
// eslint-disable-next-line es/no-object-isfrozen -- safe
var $isFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isFrozen(1);
});
// `Object.isFrozen` method
// https://tc39.es/ecma262/#sec-object.isfrozen
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    isFrozen: function isFrozen(it) {
        return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/is-object":"d60Kc"}],"9946V":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
// eslint-disable-next-line es/no-object-issealed -- safe
var $isSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isSealed(1);
});
// `Object.isSealed` method
// https://tc39.es/ecma262/#sec-object.issealed
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    isSealed: function isSealed(it) {
        return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    }
});

},{"../internals/export":"2mZbc","../internals/fails":"byxLb","../internals/is-object":"d60Kc"}],"boYMK":[function(require,module,exports) {
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var nativeKeys = require('../internals/object-keys');
var fails = require('../internals/fails');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeKeys(1);
});
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    keys: function keys(it) {
        return nativeKeys(toObject(it));
    }
});

},{"../internals/export":"2mZbc","../internals/to-object":"ghTKi","../internals/object-keys":"7so9x","../internals/fails":"byxLb"}],"TD7HT":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var toPropertyKey = require('../internals/to-property-key');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Object.prototype.__lookupGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __lookupGetter__: function __lookupGetter__(P) {
        var O = toObject(this);
        var key = toPropertyKey(P);
        var desc;
        do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
        }while (O = getPrototypeOf(O))
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-prototype-accessors-forced":"k3GQq","../internals/to-object":"ghTKi","../internals/to-property-key":"99Lby","../internals/object-get-prototype-of":"4Xd6L","../internals/object-get-own-property-descriptor":"hwpsT"}],"chseq":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var toPropertyKey = require('../internals/to-property-key');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Object.prototype.__lookupSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __lookupSetter__: function __lookupSetter__(P) {
        var O = toObject(this);
        var key = toPropertyKey(P);
        var desc;
        do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
        }while (O = getPrototypeOf(O))
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/object-prototype-accessors-forced":"k3GQq","../internals/to-object":"ghTKi","../internals/to-property-key":"99Lby","../internals/object-get-prototype-of":"4Xd6L","../internals/object-get-own-property-descriptor":"hwpsT"}],"YDDty":[function(require,module,exports) {
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-preventextensions -- safe
var $preventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function() {
    $preventExtensions(1);
});
// `Object.preventExtensions` method
// https://tc39.es/ecma262/#sec-object.preventextensions
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    preventExtensions: function preventExtensions(it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(onFreeze(it)) : it;
    }
});

},{"../internals/export":"2mZbc","../internals/is-object":"d60Kc","../internals/internal-metadata":"5OjLO","../internals/freezing":"8zb2E","../internals/fails":"byxLb"}],"81CbY":[function(require,module,exports) {
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-seal -- safe
var $seal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function() {
    $seal(1);
});
// `Object.seal` method
// https://tc39.es/ecma262/#sec-object.seal
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    seal: function seal(it) {
        return $seal && isObject(it) ? $seal(onFreeze(it)) : it;
    }
});

},{"../internals/export":"2mZbc","../internals/is-object":"d60Kc","../internals/internal-metadata":"5OjLO","../internals/freezing":"8zb2E","../internals/fails":"byxLb"}],"kDpCL":[function(require,module,exports) {
var $ = require('../internals/export');
var setPrototypeOf = require('../internals/object-set-prototype-of');
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({
    target: 'Object',
    stat: true
}, {
    setPrototypeOf: setPrototypeOf
});

},{"../internals/export":"2mZbc","../internals/object-set-prototype-of":"k1Sl0"}],"bBRVN":[function(require,module,exports) {
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var redefine = require('../internals/redefine');
var toString = require('../internals/object-to-string');
// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) redefine(Object.prototype, 'toString', toString, {
    unsafe: true
});

},{"../internals/to-string-tag-support":"eaplU","../internals/redefine":"cwrrW","../internals/object-to-string":"eYll4"}],"eYll4":[function(require,module,exports) {
'use strict';
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classof = require('../internals/classof');
// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? ({
}).toString : function toString() {
    return '[object ' + classof(this) + ']';
};

},{"../internals/to-string-tag-support":"eaplU","../internals/classof":"gO6DW"}],"gTDYu":[function(require,module,exports) {
var $ = require('../internals/export');
var $values = require('../internals/object-to-array').values;
// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({
    target: 'Object',
    stat: true
}, {
    values: function values(O) {
        return $values(O);
    }
});

},{"../internals/export":"2mZbc","../internals/object-to-array":"awU7u"}],"iXVt6":[function(require,module,exports) {
var $ = require('../internals/export');
var parseFloatImplementation = require('../internals/number-parse-float');
// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
$({
    global: true,
    forced: parseFloat != parseFloatImplementation
}, {
    parseFloat: parseFloatImplementation
});

},{"../internals/export":"2mZbc","../internals/number-parse-float":"9D8Wd"}],"dHCty":[function(require,module,exports) {
var $ = require('../internals/export');
var parseIntImplementation = require('../internals/number-parse-int');
// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
$({
    global: true,
    forced: parseInt != parseIntImplementation
}, {
    parseInt: parseIntImplementation
});

},{"../internals/export":"2mZbc","../internals/number-parse-int":"aSmbJ"}],"kYha9":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var NativePromise = require('../internals/native-promise-constructor');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var isObject = require('../internals/is-object');
var aFunction = require('../internals/a-function');
var anInstance = require('../internals/an-instance');
var inspectSource = require('../internals/inspect-source');
var iterate = require('../internals/iterate');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var promiseResolve = require('../internals/promise-resolve');
var hostReportErrors = require('../internals/host-report-errors');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var InternalStateModule = require('../internals/internal-state');
var isForced = require('../internals/is-forced');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_BROWSER = require('../internals/engine-is-browser');
var IS_NODE = require('../internals/engine-is-node');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromiseConstructorPrototype = NativePromisePrototype;
var TypeError1 = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function() {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    // We need Promise#finally in the pure version for preventing prototype pollution
    if (IS_PURE && !PromiseConstructorPrototype['finally']) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = new PromiseConstructor(function(resolve) {
        resolve(1);
    });
    var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
    };
    var constructor = promise.constructor = {
    };
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
    PromiseConstructor.all(iterable)['catch'](function() {
    });
});
// helpers
var isThenable = function(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function(state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function() {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index = 0;
        // variable length - can't use forEach
        while(chain.length > index){
            var reaction = chain[index++];
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;
            try {
                if (handler) {
                    if (!ok) {
                        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
                        state.rejection = HANDLED;
                    }
                    if (handler === true) result = value;
                    else {
                        if (domain) domain.enter();
                        result = handler(value); // can throw
                        if (domain) {
                            domain.exit();
                            exited = true;
                        }
                    }
                    if (result === reaction.promise) reject(TypeError1('Promise-chain cycle'));
                    else if (then = isThenable(result)) then.call(result, resolve, reject);
                    else resolve(result);
                } else reject(value);
            } catch (error) {
                if (domain && !exited) domain.exit();
                reject(error);
            }
        }
        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
    });
};
var dispatchEvent = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
        event = document.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global.dispatchEvent(event);
    } else event = {
        promise: promise,
        reason: reason
    };
    if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function(state) {
    task.call(global, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
            result = perform(function() {
                if (IS_NODE) process.emit('unhandledRejection', value, promise);
                else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
        }
    });
};
var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
    task.call(global, function() {
        var promise = state.facade;
        if (IS_NODE) process.emit('rejectionHandled', promise);
        else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
};
var bind = function(fn, state, unwrap) {
    return function(value) {
        fn(state, value, unwrap);
    };
};
var internalReject = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
        if (state.facade === value) throw TypeError1("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) microtask(function() {
            var wrapper = {
                done: false
            };
            try {
                then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
            } catch (error) {
                internalReject(wrapper, error, state);
            }
        });
        else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
        }
    } catch (error) {
        internalReject({
            done: false
        }, error, state);
    }
};
// constructor polyfill
if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise1(executor) {
        anInstance(this, PromiseConstructor, PROMISE);
        aFunction(executor);
        Internal.call(this);
        var state = getInternalState(this);
        try {
            executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
            internalReject(state, error);
        }
    };
    PromiseConstructorPrototype = PromiseConstructor.prototype;
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise2(executor) {
        setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: [],
            rejection: false,
            state: PENDING,
            value: undefined
        });
    };
    Internal.prototype = redefineAll(PromiseConstructorPrototype, {
        // `Promise.prototype.then` method
        // https://tc39.es/ecma262/#sec-promise.prototype.then
        then: function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = IS_NODE ? process.domain : undefined;
            state.parent = true;
            state.reactions.push(reaction);
            if (state.state != PENDING) notify(state, false);
            return reaction.promise;
        },
        // `Promise.prototype.catch` method
        // https://tc39.es/ecma262/#sec-promise.prototype.catch
        'catch': function(onRejected) {
            return this.then(undefined, onRejected);
        }
    });
    OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
    if (!IS_PURE && typeof NativePromise == 'function' && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!SUBCLASSING) {
            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
            redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
                var that = this;
                return new PromiseConstructor(function(resolve, reject) {
                    nativeThen.call(that, resolve, reject);
                }).then(onFulfilled, onRejected);
            // https://github.com/zloirock/core-js/issues/640
            }, {
                unsafe: true
            });
            // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
            redefine(NativePromisePrototype, 'catch', PromiseConstructorPrototype['catch'], {
                unsafe: true
            });
        }
        // make `.constructor === Promise` work for native promise-based APIs
        try {
            delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        // make `instanceof Promise` work for native promise-based APIs
        if (setPrototypeOf) setPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype);
    }
}
$({
    global: true,
    wrap: true,
    forced: FORCED
}, {
    Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);
// statics
$({
    target: PROMISE,
    stat: true,
    forced: FORCED
}, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
        var capability = newPromiseCapability(this);
        capability.reject.call(undefined, r);
        return capability.promise;
    }
});
$({
    target: PROMISE,
    stat: true,
    forced: IS_PURE || FORCED
}, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
    }
});
$({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION
}, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                values.push(undefined);
                remaining++;
                $promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = value;
                    (--remaining) || resolve(values);
                }, reject);
            });
            (--remaining) || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            iterate(iterable, function(promise) {
                $promiseResolve.call(C, promise).then(capability.resolve, reject);
            });
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"2mZbc","../internals/is-pure":"dlbEd","../internals/global":"a4GR8","../internals/get-built-in":"hqegu","../internals/native-promise-constructor":"aTMBS","../internals/redefine":"cwrrW","../internals/redefine-all":"4a8AR","../internals/object-set-prototype-of":"k1Sl0","../internals/set-to-string-tag":"cFbSt","../internals/set-species":"99lPJ","../internals/is-object":"d60Kc","../internals/a-function":"43ldr","../internals/an-instance":"gTr5k","../internals/inspect-source":"yqC5G","../internals/iterate":"a4R19","../internals/check-correctness-of-iteration":"lO6Bq","../internals/species-constructor":"6tv7V","../internals/task":"iBmTD","../internals/microtask":"8Si7u","../internals/promise-resolve":"iNQOY","../internals/host-report-errors":"9DqXn","../internals/new-promise-capability":"cqmSH","../internals/perform":"iovRC","../internals/internal-state":"ceuiK","../internals/is-forced":"djqhI","../internals/well-known-symbol":"6sZ59","../internals/engine-is-browser":"fHGoO","../internals/engine-is-node":"gpWpt","../internals/engine-v8-version":"8Ofbb"}],"aTMBS":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = global.Promise;

},{"../internals/global":"a4GR8"}],"iBmTD":[function(require,module,exports) {
var global = require('../internals/global');
var fails = require('../internals/fails');
var bind = require('../internals/function-bind-context');
var html = require('../internals/html');
var createElement = require('../internals/document-create-element');
var IS_IOS = require('../internals/engine-is-ios');
var IS_NODE = require('../internals/engine-is-node');
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel1 = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {
};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location, defer, channel, port;
try {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    location = global.location;
} catch (error) {
}
var run = function(id) {
    // eslint-disable-next-line no-prototype-builtins -- safe
    if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};
var runner = function(id) {
    return function() {
        run(id);
    };
};
var listener = function(event) {
    run(event.data);
};
var post = function(id) {
    // old engines have not location.origin
    global.postMessage(String(id), location.protocol + '//' + location.host);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
    set = function setImmediate(fn) {
        var args = [];
        var argumentsLength = arguments.length;
        var i = 1;
        while(argumentsLength > i)args.push(arguments[i++]);
        queue[++counter] = function() {
            // eslint-disable-next-line no-new-func -- spec requirement
            (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
        };
        defer(counter);
        return counter;
    };
    clear = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (IS_NODE) defer = function(id) {
        process.nextTick(runner(id));
    };
    else if (Dispatch && Dispatch.now) defer = function(id) {
        Dispatch.now(runner(id));
    };
    else if (MessageChannel1 && !IS_IOS) {
        channel = new MessageChannel1();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
        defer = post;
        global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement('script')) defer = function(id) {
        html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
        };
    };
    else defer = function(id) {
        setTimeout(runner(id), 0);
    };
}
module.exports = {
    set: set,
    clear: clear
};

},{"../internals/global":"a4GR8","../internals/fails":"byxLb","../internals/function-bind-context":"1epb9","../internals/html":"38cYd","../internals/document-create-element":"2WwO0","../internals/engine-is-ios":"6qN38","../internals/engine-is-node":"gpWpt"}],"6qN38":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
module.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(userAgent);

},{"../internals/engine-user-agent":"ihes9"}],"8Si7u":[function(require,module,exports) {
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var macrotask = require('../internals/task').set;
var IS_IOS = require('../internals/engine-is-ios');
var IS_IOS_PEBBLE = require('../internals/engine-is-ios-pebble');
var IS_WEBOS_WEBKIT = require('../internals/engine-is-webos-webkit');
var IS_NODE = require('../internals/engine-is-node');
var MutationObserver1 = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise1 = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then;
// modern engines have queueMicrotask method
if (!queueMicrotask) {
    flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();
        while(head){
            fn = head.fn;
            head = head.next;
            try {
                fn();
            } catch (error) {
                if (head) notify();
                else last = undefined;
                throw error;
            }
        }
        last = undefined;
        if (parent) parent.enter();
    };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver1 && document) {
        toggle = true;
        node = document.createTextNode('');
        new MutationObserver1(flush).observe(node, {
            characterData: true
        });
        notify = function() {
            node.data = toggle = !toggle;
        };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!IS_IOS_PEBBLE && Promise1 && Promise1.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise1.resolve(undefined);
        // workaround of WebKit ~ iOS Safari 10.1 bug
        promise.constructor = Promise1;
        then = promise.then;
        notify = function() {
            then.call(promise, flush);
        };
    // Node.js without promises
    } else if (IS_NODE) notify = function() {
        process.nextTick(flush);
    };
    else notify = function() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global, flush);
    };
}
module.exports = queueMicrotask || function(fn) {
    var task = {
        fn: fn,
        next: undefined
    };
    if (last) last.next = task;
    if (!head) {
        head = task;
        notify();
    }
    last = task;
};

},{"../internals/global":"a4GR8","../internals/object-get-own-property-descriptor":"hwpsT","../internals/task":"iBmTD","../internals/engine-is-ios":"6qN38","../internals/engine-is-ios-pebble":"dMp0t","../internals/engine-is-webos-webkit":"bbp6h","../internals/engine-is-node":"gpWpt"}],"dMp0t":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var global = require('../internals/global');
module.exports = /iphone|ipod|ipad/i.test(userAgent) && global.Pebble !== undefined;

},{"../internals/engine-user-agent":"ihes9","../internals/global":"a4GR8"}],"bbp6h":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
module.exports = /web0s(?!.*chrome)/i.test(userAgent);

},{"../internals/engine-user-agent":"ihes9"}],"iNQOY":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');
module.exports = function(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
};

},{"../internals/an-object":"9unxM","../internals/is-object":"d60Kc","../internals/new-promise-capability":"cqmSH"}],"cqmSH":[function(require,module,exports) {
'use strict';
var aFunction = require('../internals/a-function');
var PromiseCapability = function(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
    });
    this.resolve = aFunction(resolve);
    this.reject = aFunction(reject);
};
// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function(C) {
    return new PromiseCapability(C);
};

},{"../internals/a-function":"43ldr"}],"9DqXn":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = function(a, b) {
    var console = global.console;
    if (console && console.error) arguments.length === 1 ? console.error(a) : console.error(a, b);
};

},{"../internals/global":"a4GR8"}],"iovRC":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return {
            error: false,
            value: exec()
        };
    } catch (error) {
        return {
            error: true,
            value: error
        };
    }
};

},{}],"fHGoO":[function(require,module,exports) {
module.exports = typeof window == 'object';

},{}],"iKqpp":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({
    target: 'Promise',
    stat: true
}, {
    allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aFunction(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                values.push(undefined);
                remaining++;
                promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: 'fulfilled',
                        value: value
                    };
                    (--remaining) || resolve(values);
                }, function(error) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: 'rejected',
                        reason: error
                    };
                    (--remaining) || resolve(values);
                });
            });
            (--remaining) || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"2mZbc","../internals/a-function":"43ldr","../internals/new-promise-capability":"cqmSH","../internals/perform":"iovRC","../internals/iterate":"a4R19"}],"8inPk":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var getBuiltIn = require('../internals/get-built-in');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_ANY_ERROR = 'No one promise resolved';
// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({
    target: 'Promise',
    stat: true
}, {
    any: function any(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aFunction(C.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyRejected = false;
                errors.push(undefined);
                remaining++;
                promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyResolved = true;
                    resolve(value);
                }, function(error) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyRejected = true;
                    errors[index] = error;
                    (--remaining) || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
                });
            });
            (--remaining) || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"2mZbc","../internals/a-function":"43ldr","../internals/get-built-in":"hqegu","../internals/new-promise-capability":"cqmSH","../internals/perform":"iovRC","../internals/iterate":"a4R19"}],"bPigD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromise = require('../internals/native-promise-constructor');
var fails = require('../internals/fails');
var getBuiltIn = require('../internals/get-built-in');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var redefine = require('../internals/redefine');
// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function() {
    NativePromise.prototype['finally'].call({
        then: function() {
        }
    }, function() {
    });
});
// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({
    target: 'Promise',
    proto: true,
    real: true,
    forced: NON_GENERIC
}, {
    'finally': function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn('Promise'));
        var isFunction = typeof onFinally == 'function';
        return this.then(isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
                return x;
            });
        } : onFinally, isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
                throw e;
            });
        } : onFinally);
    }
});
// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && typeof NativePromise == 'function') {
    var method = getBuiltIn('Promise').prototype['finally'];
    if (NativePromise.prototype['finally'] !== method) redefine(NativePromise.prototype, 'finally', method, {
        unsafe: true
    });
}

},{"../internals/export":"2mZbc","../internals/is-pure":"dlbEd","../internals/native-promise-constructor":"aTMBS","../internals/fails":"byxLb","../internals/get-built-in":"hqegu","../internals/species-constructor":"6tv7V","../internals/promise-resolve":"iNQOY","../internals/redefine":"cwrrW"}],"lncJ8":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var fails = require('../internals/fails');
var nativeApply = getBuiltIn('Reflect', 'apply');
var functionApply = Function.apply;
// MS Edge argumentsList argument is optional
var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
    nativeApply(function() {
    });
});
// `Reflect.apply` method
// https://tc39.es/ecma262/#sec-reflect.apply
$({
    target: 'Reflect',
    stat: true,
    forced: OPTIONAL_ARGUMENTS_LIST
}, {
    apply: function apply(target, thisArgument, argumentsList) {
        aFunction(target);
        anObject(argumentsList);
        return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
    }
});

},{"../internals/export":"2mZbc","../internals/get-built-in":"hqegu","../internals/a-function":"43ldr","../internals/an-object":"9unxM","../internals/fails":"byxLb"}],"ff1SM":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var bind = require('../internals/function-bind');
var fails = require('../internals/fails');
var nativeConstruct = getBuiltIn('Reflect', 'construct');
// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function() {
    function F() {
    }
    return !(nativeConstruct(function() {
    }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function() {
    nativeConstruct(function() {
    });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;
$({
    target: 'Reflect',
    stat: true,
    forced: FORCED,
    sham: FORCED
}, {
    construct: function construct(Target, args /* , newTarget */ ) {
        aFunction(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
        if (Target == newTarget) {
            // w/o altered newTarget, optimization for 0-4 arguments
            switch(args.length){
                case 0:
                    return new Target();
                case 1:
                    return new Target(args[0]);
                case 2:
                    return new Target(args[0], args[1]);
                case 3:
                    return new Target(args[0], args[1], args[2]);
                case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
            }
            // w/o altered newTarget, lot of arguments case
            var $args = [
                null
            ];
            $args.push.apply($args, args);
            return new (bind.apply(Target, $args))();
        }
        // with altered newTarget, not support built-in constructors
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : Object.prototype);
        var result = Function.apply.call(Target, instance, args);
        return isObject(result) ? result : instance;
    }
});

},{"../internals/export":"2mZbc","../internals/get-built-in":"hqegu","../internals/a-function":"43ldr","../internals/an-object":"9unxM","../internals/is-object":"d60Kc","../internals/object-create":"eYZeq","../internals/function-bind":"5QaOT","../internals/fails":"byxLb"}],"dW0sW":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var toPropertyKey = require('../internals/to-property-key');
var definePropertyModule = require('../internals/object-define-property');
var fails = require('../internals/fails');
// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
var ERROR_INSTEAD_OF_FALSE = fails(function() {
    // eslint-disable-next-line es/no-reflect -- required for testing
    Reflect.defineProperty(definePropertyModule.f({
    }, 1, {
        value: 1
    }), 1, {
        value: 2
    });
});
// `Reflect.defineProperty` method
// https://tc39.es/ecma262/#sec-reflect.defineproperty
$({
    target: 'Reflect',
    stat: true,
    forced: ERROR_INSTEAD_OF_FALSE,
    sham: !DESCRIPTORS
}, {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        var key = toPropertyKey(propertyKey);
        anObject(attributes);
        try {
            definePropertyModule.f(target, key, attributes);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/an-object":"9unxM","../internals/to-property-key":"99Lby","../internals/object-define-property":"iKHmb","../internals/fails":"byxLb"}],"7DsVb":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Reflect.deleteProperty` method
// https://tc39.es/ecma262/#sec-reflect.deleteproperty
$({
    target: 'Reflect',
    stat: true
}, {
    deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
    }
});

},{"../internals/export":"2mZbc","../internals/an-object":"9unxM","../internals/object-get-own-property-descriptor":"hwpsT"}],"jaVFn":[function(require,module,exports) {
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var has = require('../internals/has');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */ ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var descriptor, prototype;
    if (anObject(target) === receiver) return target[propertyKey];
    if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
    if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}
$({
    target: 'Reflect',
    stat: true
}, {
    get: get
});

},{"../internals/export":"2mZbc","../internals/is-object":"d60Kc","../internals/an-object":"9unxM","../internals/has":"aVEHj","../internals/object-get-own-property-descriptor":"hwpsT","../internals/object-get-prototype-of":"4Xd6L"}],"kVW26":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
// `Reflect.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor
$({
    target: 'Reflect',
    stat: true,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
    }
});

},{"../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/an-object":"9unxM","../internals/object-get-own-property-descriptor":"hwpsT"}],"hBOtV":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var objectGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
// `Reflect.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.getprototypeof
$({
    target: 'Reflect',
    stat: true,
    sham: !CORRECT_PROTOTYPE_GETTER
}, {
    getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
    }
});

},{"../internals/export":"2mZbc","../internals/an-object":"9unxM","../internals/object-get-prototype-of":"4Xd6L","../internals/correct-prototype-getter":"dMqx3"}],"gTbyP":[function(require,module,exports) {
var $ = require('../internals/export');
// `Reflect.has` method
// https://tc39.es/ecma262/#sec-reflect.has
$({
    target: 'Reflect',
    stat: true
}, {
    has: function has(target, propertyKey) {
        return propertyKey in target;
    }
});

},{"../internals/export":"2mZbc"}],"VG7RE":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
// eslint-disable-next-line es/no-object-isextensible -- safe
var objectIsExtensible = Object.isExtensible;
// `Reflect.isExtensible` method
// https://tc39.es/ecma262/#sec-reflect.isextensible
$({
    target: 'Reflect',
    stat: true
}, {
    isExtensible: function isExtensible(target) {
        anObject(target);
        return objectIsExtensible ? objectIsExtensible(target) : true;
    }
});

},{"../internals/export":"2mZbc","../internals/an-object":"9unxM"}],"8moRG":[function(require,module,exports) {
var $ = require('../internals/export');
var ownKeys = require('../internals/own-keys');
// `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys
$({
    target: 'Reflect',
    stat: true
}, {
    ownKeys: ownKeys
});

},{"../internals/export":"2mZbc","../internals/own-keys":"dGiV1"}],"gMzOv":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var FREEZING = require('../internals/freezing');
// `Reflect.preventExtensions` method
// https://tc39.es/ecma262/#sec-reflect.preventextensions
$({
    target: 'Reflect',
    stat: true,
    sham: !FREEZING
}, {
    preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
            var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
            if (objectPreventExtensions) objectPreventExtensions(target);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"2mZbc","../internals/get-built-in":"hqegu","../internals/an-object":"9unxM","../internals/freezing":"8zb2E"}],"9isA9":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var has = require('../internals/has');
var fails = require('../internals/fails');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
// `Reflect.set` method
// https://tc39.es/ecma262/#sec-reflect.set
function set(target, propertyKey, V /* , receiver */ ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
    var existingDescriptor, prototype;
    if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf(target))) return set(prototype, propertyKey, V, receiver);
        ownDescriptor = createPropertyDescriptor(0);
    }
    if (has(ownDescriptor, 'value')) {
        if (ownDescriptor.writable === false || !isObject(receiver)) return false;
        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
        return true;
    }
    return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
}
// MS Edge 17-18 Reflect.set allows setting the property to object
// with non-writable property on the prototype
var MS_EDGE_BUG = fails(function() {
    var Constructor = function() {
    };
    var object = definePropertyModule.f(new Constructor(), 'a', {
        configurable: true
    });
    // eslint-disable-next-line es/no-reflect -- required for testing
    return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
});
$({
    target: 'Reflect',
    stat: true,
    forced: MS_EDGE_BUG
}, {
    set: set
});

},{"../internals/export":"2mZbc","../internals/an-object":"9unxM","../internals/is-object":"d60Kc","../internals/has":"aVEHj","../internals/fails":"byxLb","../internals/object-define-property":"iKHmb","../internals/object-get-own-property-descriptor":"hwpsT","../internals/object-get-prototype-of":"4Xd6L","../internals/create-property-descriptor":"5fdHA"}],"6hNd3":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');
var objectSetPrototypeOf = require('../internals/object-set-prototype-of');
// `Reflect.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.setprototypeof
if (objectSetPrototypeOf) $({
    target: 'Reflect',
    stat: true
}, {
    setPrototypeOf: function setPrototypeOf(target, proto) {
        anObject(target);
        aPossiblePrototype(proto);
        try {
            objectSetPrototypeOf(target, proto);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"2mZbc","../internals/an-object":"9unxM","../internals/a-possible-prototype":"4dKE2","../internals/object-set-prototype-of":"k1Sl0"}],"99fpE":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');
$({
    global: true
}, {
    Reflect: {
    }
});
// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(global.Reflect, 'Reflect', true);

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/set-to-string-tag":"cFbSt"}],"dwe4v":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isForced = require('../internals/is-forced');
var inheritIfRequired = require('../internals/inherit-if-required');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var isRegExp = require('../internals/is-regexp');
var toString = require('../internals/to-string');
var getFlags = require('../internals/regexp-flags');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var has = require('../internals/has');
var enforceInternalState = require('../internals/internal-state').enforce;
var setSpecies = require('../internals/set-species');
var wellKnownSymbol = require('../internals/well-known-symbol');
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');
var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
// TODO: Use only propper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
}));
var handleDotAll = function(string) {
    var length = string.length;
    var index = 0;
    var result = '';
    var brackets = false;
    var chr;
    for(; index <= length; index++){
        chr = string.charAt(index);
        if (chr === '\\') {
            result += chr + string.charAt(++index);
            continue;
        }
        if (!brackets && chr === '.') result += '[\\s\\S]';
        else {
            if (chr === '[') brackets = true;
            else if (chr === ']') brackets = false;
            result += chr;
        }
    }
    return result;
};
var handleNCG = function(string) {
    var length = string.length;
    var index = 0;
    var result = '';
    var named = [];
    var names = {
    };
    var brackets = false;
    var ncg = false;
    var groupid = 0;
    var groupname = '';
    var chr;
    for(; index <= length; index++){
        chr = string.charAt(index);
        if (chr === '\\') chr = chr + string.charAt(++index);
        else if (chr === ']') brackets = false;
        else if (!brackets) switch(true){
            case chr === '[':
                brackets = true;
                break;
            case chr === '(':
                if (IS_NCG.test(string.slice(index + 1))) {
                    index += 2;
                    ncg = true;
                }
                result += chr;
                groupid++;
                continue;
            case chr === '>' && ncg:
                if (groupname === '' || has(names, groupname)) throw new SyntaxError('Invalid capture group name');
                names[groupname] = true;
                named.push([
                    groupname,
                    groupid
                ]);
                ncg = false;
                groupname = '';
                continue;
        }
        if (ncg) groupname += chr;
        else result += chr;
    }
    return [
        result,
        named
    ];
};
// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
    var RegExpWrapper = function RegExp1(pattern, flags) {
        var thisIsRegExp = this instanceof RegExpWrapper;
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === undefined;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) return pattern;
        if (patternIsRegExp || pattern instanceof RegExpWrapper) {
            pattern = pattern.source;
            if (flagsAreUndefined) flags = 'flags' in rawPattern ? rawPattern.flags : getFlags.call(rawPattern);
        }
        pattern = pattern === undefined ? '' : toString(pattern);
        flags = flags === undefined ? '' : toString(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
            dotAll = !!flags && flags.indexOf('s') > -1;
            if (dotAll) flags = flags.replace(/s/g, '');
        }
        rawFlags = flags;
        if (UNSUPPORTED_Y && 'sticky' in re1) {
            sticky = !!flags && flags.indexOf('y') > -1;
            if (sticky) flags = flags.replace(/y/g, '');
        }
        if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
            state = enforceInternalState(result);
            if (dotAll) {
                state.dotAll = true;
                state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky) state.sticky = true;
            if (groups.length) state.groups = groups;
        }
        if (pattern !== rawPattern) try {
            // fails in old engines, but we have no alternatives for unsupported regex syntax
            createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
        } catch (error) {
        }
        return result;
    };
    var proxy = function(key) {
        key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
            configurable: true,
            get: function() {
                return NativeRegExp[key];
            },
            set: function(it) {
                NativeRegExp[key] = it;
            }
        });
    };
    for(var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;)proxy(keys[index++]);
    RegExpPrototype.constructor = RegExpWrapper;
    RegExpWrapper.prototype = RegExpPrototype;
    redefine(global, 'RegExp', RegExpWrapper);
}
// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

},{"../internals/descriptors":"kuDzl","../internals/global":"a4GR8","../internals/is-forced":"djqhI","../internals/inherit-if-required":"5Ef3J","../internals/create-non-enumerable-property":"73EkF","../internals/object-define-property":"iKHmb","../internals/object-get-own-property-names":"38UqD","../internals/is-regexp":"b7miO","../internals/to-string":"k0ZQF","../internals/regexp-flags":"bmq3u","../internals/regexp-sticky-helpers":"4mh9i","../internals/redefine":"cwrrW","../internals/fails":"byxLb","../internals/has":"aVEHj","../internals/internal-state":"ceuiK","../internals/set-species":"99lPJ","../internals/well-known-symbol":"6sZ59","../internals/regexp-unsupported-dot-all":"6Lx4t","../internals/regexp-unsupported-ncg":"3gScj"}],"b7miO":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/is-object":"d60Kc","../internals/classof-raw":"8F0bi","../internals/well-known-symbol":"6sZ59"}],"bmq3u":[function(require,module,exports) {
'use strict';
var anObject = require('../internals/an-object');
// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function() {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
};

},{"../internals/an-object":"9unxM"}],"4mh9i":[function(require,module,exports) {
var fails = require('../internals/fails');
// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
var RE = function(s, f) {
    return RegExp(s, f);
};
exports.UNSUPPORTED_Y = fails(function() {
    var re = RE('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
});
exports.BROKEN_CARET = fails(function() {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = RE('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
});

},{"../internals/fails":"byxLb"}],"6Lx4t":[function(require,module,exports) {
var fails = require('./fails');
module.exports = fails(function() {
    // babel-minify transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
    var re = RegExp('.', "string".charAt(0));
    return !(re.dotAll && re.exec('\n') && re.flags === 's');
});

},{"./fails":"byxLb"}],"3gScj":[function(require,module,exports) {
var fails = require('./fails');
module.exports = fails(function() {
    // babel-minify transpiles RegExp('.', 'g') -> /./g and it causes SyntaxError
    var re = RegExp('(?<a>b)', "string".charAt(5));
    return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
});

},{"./fails":"byxLb"}],"1u6bJ":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var defineProperty = require('../internals/object-define-property').f;
var getInternalState = require('../internals/internal-state').get;
var RegExpPrototype = RegExp.prototype;
// `RegExp.prototype.dotAll` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.dotall
if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) defineProperty(RegExpPrototype, 'dotAll', {
    configurable: true,
    get: function() {
        if (this === RegExpPrototype) return undefined;
        // We can't use InternalStateModule.getterFor because
        // we don't add metadata for regexps created by a literal.
        if (this instanceof RegExp) return !!getInternalState(this).dotAll;
        throw TypeError('Incompatible receiver, RegExp required');
    }
});

},{"../internals/descriptors":"kuDzl","../internals/regexp-unsupported-dot-all":"6Lx4t","../internals/object-define-property":"iKHmb","../internals/internal-state":"ceuiK"}],"lySIs":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var exec = require('../internals/regexp-exec');
// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({
    target: 'RegExp',
    proto: true,
    forced: /./.exec !== exec
}, {
    exec: exec
});

},{"../internals/export":"2mZbc","../internals/regexp-exec":"daEEr"}],"daEEr":[function(require,module,exports) {
'use strict';
/* eslint-disable regexp/no-assertion-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */ /* eslint-disable regexp/no-useless-quantifier -- testing */ var toString = require('../internals/to-string');
var regexpFlags = require('../internals/regexp-flags');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var shared = require('../internals/shared');
var create = require('../internals/object-create');
var getInternalState = require('../internals/internal-state').get;
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');
var nativeExec = RegExp.prototype.exec;
var nativeReplace = shared('native-string-replace', String.prototype.replace);
var patchedExec = nativeExec;
var UPDATES_LAST_INDEX_WRONG = function() {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) // eslint-disable-next-line max-statements -- TODO
patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;
    if (raw) {
        raw.lastIndex = re.lastIndex;
        result = patchedExec.call(raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
        flags = flags.replace('y', '');
        if (flags.indexOf('g') === -1) flags += 'g';
        strCopy = str.slice(re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str.charAt(re.lastIndex - 1) !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
    }
    if (NPCG_INCLUDED) reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(sticky ? reCopy : re, strCopy);
    if (sticky) {
        if (match) {
            match.input = match.input.slice(charsAdded);
            match[0] = match[0].slice(charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    if (NPCG_INCLUDED && match && match.length > 1) // Fix browsers whose `exec` methods don't consistently return `undefined`
    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
    nativeReplace.call(match[0], reCopy, function() {
        for(i = 1; i < arguments.length - 2; i++)if (arguments[i] === undefined) match[i] = undefined;
    });
    if (match && groups) {
        match.groups = object = create(null);
        for(i = 0; i < groups.length; i++){
            group = groups[i];
            object[group[0]] = match[group[1]];
        }
    }
    return match;
};
module.exports = patchedExec;

},{"../internals/to-string":"k0ZQF","../internals/regexp-flags":"bmq3u","../internals/regexp-sticky-helpers":"4mh9i","../internals/shared":"ic92G","../internals/object-create":"eYZeq","../internals/internal-state":"ceuiK","../internals/regexp-unsupported-dot-all":"6Lx4t","../internals/regexp-unsupported-ncg":"3gScj"}],"ecNn9":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModule = require('../internals/object-define-property');
var regExpFlags = require('../internals/regexp-flags');
var fails = require('../internals/fails');
var FORCED = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get.call({
        dotAll: true,
        sticky: true
    }) !== 'sy';
});
// `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
if (FORCED) objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regExpFlags
});

},{"../internals/descriptors":"kuDzl","../internals/object-define-property":"iKHmb","../internals/regexp-flags":"bmq3u","../internals/fails":"byxLb"}],"j9bjG":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var UNSUPPORTED_Y = require('../internals/regexp-sticky-helpers').UNSUPPORTED_Y;
var defineProperty = require('../internals/object-define-property').f;
var getInternalState = require('../internals/internal-state').get;
var RegExpPrototype = RegExp.prototype;
// `RegExp.prototype.sticky` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky
if (DESCRIPTORS && UNSUPPORTED_Y) defineProperty(RegExpPrototype, 'sticky', {
    configurable: true,
    get: function() {
        if (this === RegExpPrototype) return undefined;
        // We can't use InternalStateModule.getterFor because
        // we don't add metadata for regexps created by a literal.
        if (this instanceof RegExp) return !!getInternalState(this).sticky;
        throw TypeError('Incompatible receiver, RegExp required');
    }
});

},{"../internals/descriptors":"kuDzl","../internals/regexp-sticky-helpers":"4mh9i","../internals/object-define-property":"iKHmb","../internals/internal-state":"ceuiK"}],"iP2j2":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4` since it's moved to entry points
require('../modules/es.regexp.exec');
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var DELEGATES_TO_EXEC = function() {
    var execCalled = false;
    var re = /[ac]/;
    re.exec = function() {
        execCalled = true;
        return /./.exec.apply(this, arguments);
    };
    return re.test('abc') === true && execCalled;
}();
var nativeTest = /./.test;
// `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test
$({
    target: 'RegExp',
    proto: true,
    forced: !DELEGATES_TO_EXEC
}, {
    test: function(str) {
        if (typeof this.exec !== 'function') return nativeTest.call(this, str);
        var result = this.exec(str);
        if (result !== null && !isObject(result)) throw new Error('RegExp exec method returned something other than an Object or null');
        return !!result;
    }
});

},{"../modules/es.regexp.exec":"lySIs","../internals/export":"2mZbc","../internals/is-object":"d60Kc"}],"7sKSf":[function(require,module,exports) {
'use strict';
var redefine = require('../internals/redefine');
var anObject = require('../internals/an-object');
var $toString = require('../internals/to-string');
var fails = require('../internals/fails');
var flags = require('../internals/regexp-flags');
var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails(function() {
    return nativeToString.call({
        source: 'a',
        flags: 'b'
    }) != '/a/b';
});
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;
// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = $toString(R.source);
    var rf = R.flags;
    var f = $toString(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
}, {
    unsafe: true
});

},{"../internals/redefine":"cwrrW","../internals/an-object":"9unxM","../internals/to-string":"k0ZQF","../internals/fails":"byxLb","../internals/regexp-flags":"bmq3u"}],"5wbk0":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');
// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
module.exports = collection('Set', function(init) {
    return function Set1() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionStrong);

},{"../internals/collection":"8qCpd","../internals/collection-strong":"hibUM"}],"fviUF":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var codeAt = require('../internals/string-multibyte').codeAt;
// `String.prototype.codePointAt` method
// https://tc39.es/ecma262/#sec-string.prototype.codepointat
$({
    target: 'String',
    proto: true
}, {
    codePointAt: function codePointAt(pos) {
        return codeAt(this, pos);
    }
});

},{"../internals/export":"2mZbc","../internals/string-multibyte":"dPnMz"}],"dPnMz":[function(require,module,exports) {
var toInteger = require('../internals/to-integer');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
// `String.prototype.codePointAt` methods implementation
var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = S.charCodeAt(position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
};
module.exports = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
};

},{"../internals/to-integer":"gOCws","../internals/to-string":"k0ZQF","../internals/require-object-coercible":"1XURO"}],"i8dBj":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
// eslint-disable-next-line es/no-string-prototype-endswith -- safe
var $endsWith = ''.endsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
    return descriptor && !descriptor.writable;
}();
// `String.prototype.endsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.endswith
$({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
    endsWith: function endsWith(searchString /* , endPosition = @length */ ) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = toLength(that.length);
        var end = endPosition === undefined ? len : min(toLength(endPosition), len);
        var search = toString(searchString);
        return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }
});

},{"../internals/export":"2mZbc","../internals/object-get-own-property-descriptor":"hwpsT","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/not-a-regexp":"bmUBS","../internals/require-object-coercible":"1XURO","../internals/correct-is-regexp-logic":"kDBvg","../internals/is-pure":"dlbEd"}],"bmUBS":[function(require,module,exports) {
var isRegExp = require('../internals/is-regexp');
module.exports = function(it) {
    if (isRegExp(it)) throw TypeError("The method doesn't accept regular expressions");
    return it;
};

},{"../internals/is-regexp":"b7miO"}],"kDBvg":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
module.exports = function(METHOD_NAME) {
    var regexp = /./;
    try {
        '/./'[METHOD_NAME](regexp);
    } catch (error1) {
        try {
            regexp[MATCH] = false;
            return '/./'[METHOD_NAME](regexp);
        } catch (error2) {
        }
    }
    return false;
};

},{"../internals/well-known-symbol":"6sZ59"}],"kP5Lw":[function(require,module,exports) {
var $ = require('../internals/export');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var fromCharCode = String.fromCharCode;
// eslint-disable-next-line es/no-string-fromcodepoint -- required for testing
var $fromCodePoint = String.fromCodePoint;
// length should be 1, old FF problem
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;
// `String.fromCodePoint` method
// https://tc39.es/ecma262/#sec-string.fromcodepoint
$({
    target: 'String',
    stat: true,
    forced: INCORRECT_LENGTH
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    fromCodePoint: function fromCodePoint(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while(length > i){
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + ' is not a valid code point');
            elements.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320));
        }
        return elements.join('');
    }
});

},{"../internals/export":"2mZbc","../internals/to-absolute-index":"bWCPe"}],"c28Iv":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({
    target: 'String',
    proto: true,
    forced: !correctIsRegExpLogic('includes')
}, {
    includes: function includes(searchString /* , position = 0 */ ) {
        return !!~toString(requireObjectCoercible(this)).indexOf(toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/not-a-regexp":"bmUBS","../internals/require-object-coercible":"1XURO","../internals/to-string":"k0ZQF","../internals/correct-is-regexp-logic":"kDBvg"}],"79oCt":[function(require,module,exports) {
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
var toString = require('../internals/to-string');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function(iterated) {
    setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
    });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
        value: undefined,
        done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
        value: point,
        done: false
    };
});

},{"../internals/string-multibyte":"dPnMz","../internals/to-string":"k0ZQF","../internals/internal-state":"ceuiK","../internals/define-iterator":"6ZPeX"}],"3bQbi":[function(require,module,exports) {
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');
// @@match logic
fixRegExpWellKnownSymbolLogic('match', function(MATCH, nativeMatch, maybeCallNative) {
    return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = regexp == undefined ? undefined : regexp[MATCH];
            return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](toString(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeMatch, rx, S);
            if (res.done) return res.value;
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while((result = regExpExec(rx, S)) !== null){
                var matchStr = toString(result[0]);
                A[n] = matchStr;
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                n++;
            }
            return n === 0 ? null : A;
        }
    ];
});

},{"../internals/fix-regexp-well-known-symbol-logic":"kKKB8","../internals/an-object":"9unxM","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/require-object-coercible":"1XURO","../internals/advance-string-index":"eZF6s","../internals/regexp-exec-abstract":"cID5l"}],"kKKB8":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4` since it's moved to entry points
require('../modules/es.regexp.exec');
var redefine = require('../internals/redefine');
var regexpExec = require('../internals/regexp-exec');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;
module.exports = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol(KEY);
    var DELEGATES_TO_SYMBOL = !fails(function() {
        // String methods call symbol-named RegEp methods
        var O = {
        };
        O[SYMBOL] = function() {
            return 7;
        };
        return ''[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;
        if (KEY === 'split') {
            // We can't use real regex here since it causes deoptimization
            // and serious performance degradation in V8
            // https://github.com/zloirock/core-js/issues/306
            re = {
            };
            // RegExp[@@split] doesn't call the regex's exec method, but first creates
            // a new one. We need to return the patched regex when creating the new one.
            re.constructor = {
            };
            re.constructor[SPECIES] = function() {
                return re;
            };
            re.flags = '';
            re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
            execCalled = true;
            return null;
        };
        re[SYMBOL]('');
        return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ''[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) // The native String method already delegates to @@method (this
                // polyfilled function), leasing to infinite recursion.
                // We avoid it by directly calling the native @@method method.
                return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                };
                return {
                    done: true,
                    value: nativeMethod.call(str, regexp, arg2)
                };
            }
            return {
                done: false
            };
        });
        redefine(String.prototype, KEY, methods[0]);
        redefine(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};

},{"../modules/es.regexp.exec":"lySIs","../internals/redefine":"cwrrW","../internals/regexp-exec":"daEEr","../internals/fails":"byxLb","../internals/well-known-symbol":"6sZ59","../internals/create-non-enumerable-property":"73EkF"}],"eZF6s":[function(require,module,exports) {
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function(S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
};

},{"../internals/string-multibyte":"dPnMz"}],"cID5l":[function(require,module,exports) {
var classof = require('./classof-raw');
var regexpExec = require('./regexp-exec');
// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function(R, S) {
    var exec = R.exec;
    if (typeof exec === 'function') {
        var result = exec.call(R, S);
        if (typeof result !== 'object') throw TypeError('RegExp exec method returned something other than an Object or null');
        return result;
    }
    if (classof(R) !== 'RegExp') throw TypeError('RegExp#exec called on incompatible receiver');
    return regexpExec.call(R, S);
};

},{"./classof-raw":"8F0bi","./regexp-exec":"daEEr"}],"jEeAs":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-string-prototype-matchall -- safe */ var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var aFunction = require('../internals/a-function');
var anObject = require('../internals/an-object');
var classof = require('../internals/classof-raw');
var isRegExp = require('../internals/is-regexp');
var getRegExpFlags = require('../internals/regexp-flags');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var InternalStateModule = require('../internals/internal-state');
var IS_PURE = require('../internals/is-pure');
var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var regExpBuiltinExec = RegExpPrototype.exec;
var nativeMatchAll = ''.matchAll;
var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function() {
    'a'.matchAll(/./);
});
var regExpExec = function(R, S) {
    var exec = R.exec;
    var result;
    if (typeof exec == 'function') {
        result = exec.call(R, S);
        if (typeof result != 'object') throw TypeError('Incorrect exec result');
        return result;
    }
    return regExpBuiltinExec.call(R, S);
};
// eslint-disable-next-line max-len -- ignore
var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
    setInternalState(this, {
        type: REGEXP_STRING_ITERATOR,
        regexp: regexp,
        string: string,
        global: global,
        unicode: fullUnicode,
        done: false
    });
}, REGEXP_STRING, function next() {
    var state = getInternalState(this);
    if (state.done) return {
        value: undefined,
        done: true
    };
    var R = state.regexp;
    var S = state.string;
    var match = regExpExec(R, S);
    if (match === null) return {
        value: undefined,
        done: state.done = true
    };
    if (state.global) {
        if (toString(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
        return {
            value: match,
            done: false
        };
    }
    state.done = true;
    return {
        value: match,
        done: false
    };
});
var $matchAll = function(string) {
    var R = anObject(this);
    var S = toString(string);
    var C, flagsValue, flags, matcher, global, fullUnicode;
    C = speciesConstructor(R, RegExp);
    flagsValue = R.flags;
    if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) flagsValue = getRegExpFlags.call(R);
    flags = flagsValue === undefined ? '' : toString(flagsValue);
    matcher = new C(C === RegExp ? R.source : R, flags);
    global = !!~flags.indexOf('g');
    fullUnicode = !!~flags.indexOf('u');
    matcher.lastIndex = toLength(R.lastIndex);
    return new $RegExpStringIterator(matcher, S, global, fullUnicode);
};
// `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall
$({
    target: 'String',
    proto: true,
    forced: WORKS_WITH_NON_GLOBAL_REGEX
}, {
    matchAll: function matchAll(regexp) {
        var O = requireObjectCoercible(this);
        var flags, S, matcher, rx;
        if (regexp != null) {
            if (isRegExp(regexp)) {
                flags = toString(requireObjectCoercible('flags' in RegExpPrototype ? regexp.flags : getRegExpFlags.call(regexp)));
                if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
            matcher = regexp[MATCH_ALL];
            if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
            if (matcher != null) return aFunction(matcher).call(regexp, O);
        } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
        S = toString(O);
        rx = new RegExp(regexp, 'g');
        return IS_PURE ? $matchAll.call(rx, S) : rx[MATCH_ALL](S);
    }
});
IS_PURE || MATCH_ALL in RegExpPrototype || createNonEnumerableProperty(RegExpPrototype, MATCH_ALL, $matchAll);

},{"../internals/export":"2mZbc","../internals/create-iterator-constructor":"biz26","../internals/require-object-coercible":"1XURO","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/a-function":"43ldr","../internals/an-object":"9unxM","../internals/classof-raw":"8F0bi","../internals/is-regexp":"b7miO","../internals/regexp-flags":"bmq3u","../internals/create-non-enumerable-property":"73EkF","../internals/fails":"byxLb","../internals/well-known-symbol":"6sZ59","../internals/species-constructor":"6tv7V","../internals/advance-string-index":"eZF6s","../internals/internal-state":"ceuiK","../internals/is-pure":"dlbEd"}],"fEFFM":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $padEnd = require('../internals/string-pad').end;
var WEBKIT_BUG = require('../internals/string-pad-webkit-bug');
// `String.prototype.padEnd` method
// https://tc39.es/ecma262/#sec-string.prototype.padend
$({
    target: 'String',
    proto: true,
    forced: WEBKIT_BUG
}, {
    padEnd: function padEnd(maxLength /* , fillString = ' ' */ ) {
        return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/string-pad":"lqvFq","../internals/string-pad-webkit-bug":"7uDk0"}],"7uDk0":[function(require,module,exports) {
// https://github.com/zloirock/core-js/issues/280
var userAgent = require('../internals/engine-user-agent');
// eslint-disable-next-line unicorn/no-unsafe-regex -- safe
module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);

},{"../internals/engine-user-agent":"ihes9"}],"coZy7":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $padStart = require('../internals/string-pad').start;
var WEBKIT_BUG = require('../internals/string-pad-webkit-bug');
// `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart
$({
    target: 'String',
    proto: true,
    forced: WEBKIT_BUG
}, {
    padStart: function padStart(maxLength /* , fillString = ' ' */ ) {
        return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"2mZbc","../internals/string-pad":"lqvFq","../internals/string-pad-webkit-bug":"7uDk0"}],"d9wUa":[function(require,module,exports) {
var $ = require('../internals/export');
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
// `String.raw` method
// https://tc39.es/ecma262/#sec-string.raw
$({
    target: 'String',
    stat: true
}, {
    raw: function raw(template) {
        var rawTemplate = toIndexedObject(template.raw);
        var literalSegments = toLength(rawTemplate.length);
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;
        while(literalSegments > i){
            elements.push(toString(rawTemplate[i++]));
            if (i < argumentsLength) elements.push(toString(arguments[i]));
        }
        return elements.join('');
    }
});

},{"../internals/export":"2mZbc","../internals/to-indexed-object":"9N8sJ","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF"}],"7f2Bv":[function(require,module,exports) {
var $ = require('../internals/export');
var repeat = require('../internals/string-repeat');
// `String.prototype.repeat` method
// https://tc39.es/ecma262/#sec-string.prototype.repeat
$({
    target: 'String',
    proto: true
}, {
    repeat: repeat
});

},{"../internals/export":"2mZbc","../internals/string-repeat":"8cSMA"}],"2k8lL":[function(require,module,exports) {
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var fails = require('../internals/fails');
var anObject = require('../internals/an-object');
var toInteger = require('../internals/to-integer');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var getSubstitution = require('../internals/get-substitution');
var regExpExec = require('../internals/regexp-exec-abstract');
var wellKnownSymbol = require('../internals/well-known-symbol');
var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var maybeToString = function(it) {
    return it === undefined ? it : String(it);
};
// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = function() {
    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
    return 'a'.replace(/./, '$0') === '$0';
}();
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
    if (/./[REPLACE]) return /./[REPLACE]('a', '$0') === '';
    return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
    var re = /./;
    re.exec = function() {
        var result = [];
        result.groups = {
            a: '7'
        };
        return result;
    };
    return ''.replace(re, '$<a>') !== '7';
});
// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function(_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
    return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
            return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(toString(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
            var rx = anObject(this);
            var S = toString(string);
            if (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1 && replaceValue.indexOf('$<') === -1) {
                var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
                if (res.done) return res.value;
            }
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = toString(replaceValue);
            var global = rx.global;
            if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
            }
            var results = [];
            while(true){
                var result = regExpExec(rx, S);
                if (result === null) break;
                results.push(result);
                if (!global) break;
                var matchStr = toString(result[0]);
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = '';
            var nextSourcePosition = 0;
            for(var i = 0; i < results.length; i++){
                result = results[i];
                var matched = toString(result[0]);
                var position = max(min(toInteger(result.index), S.length), 0);
                var captures = [];
                // NOTE: This is equivalent to
                //   captures = result.slice(1).map(maybeToString)
                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                for(var j = 1; j < result.length; j++)captures.push(maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                    var replacerArgs = [
                        matched
                    ].concat(captures, position, S);
                    if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                    var replacement = toString(replaceValue.apply(undefined, replacerArgs));
                } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                if (position >= nextSourcePosition) {
                    accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                }
            }
            return accumulatedResult + S.slice(nextSourcePosition);
        }
    ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

},{"../internals/fix-regexp-well-known-symbol-logic":"kKKB8","../internals/fails":"byxLb","../internals/an-object":"9unxM","../internals/to-integer":"gOCws","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/require-object-coercible":"1XURO","../internals/advance-string-index":"eZF6s","../internals/get-substitution":"hs6aX","../internals/regexp-exec-abstract":"cID5l","../internals/well-known-symbol":"6sZ59"}],"hs6aX":[function(require,module,exports) {
var toObject = require('../internals/to-object');
var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace.call(replacement, symbols, function(match, ch) {
        var capture;
        switch(ch.charAt(0)){
            case '$':
                return '$';
            case '&':
                return matched;
            case '`':
                return str.slice(0, position);
            case "'":
                return str.slice(tailPos);
            case '<':
                capture = namedCaptures[ch.slice(1, -1)];
                break;
            default:
                var n = +ch;
                if (n === 0) return match;
                if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                }
                capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
    });
};

},{"../internals/to-object":"ghTKi"}],"8IJOq":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var requireObjectCoercible = require('../internals/require-object-coercible');
var isRegExp = require('../internals/is-regexp');
var toString = require('../internals/to-string');
var getRegExpFlags = require('../internals/regexp-flags');
var getSubstitution = require('../internals/get-substitution');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var REPLACE = wellKnownSymbol('replace');
var RegExpPrototype = RegExp.prototype;
var max = Math.max;
var stringIndexOf = function(string, searchValue, fromIndex) {
    if (fromIndex > string.length) return -1;
    if (searchValue === '') return fromIndex;
    return string.indexOf(searchValue, fromIndex);
};
// `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall
$({
    target: 'String',
    proto: true
}, {
    replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
        var position = 0;
        var endOfLastMatch = 0;
        var result = '';
        if (searchValue != null) {
            IS_REG_EXP = isRegExp(searchValue);
            if (IS_REG_EXP) {
                flags = toString(requireObjectCoercible('flags' in RegExpPrototype ? searchValue.flags : getRegExpFlags.call(searchValue)));
                if (!~flags.indexOf('g')) throw TypeError('`.replaceAll` does not allow non-global regexes');
            }
            replacer = searchValue[REPLACE];
            if (replacer !== undefined) return replacer.call(searchValue, O, replaceValue);
            else if (IS_PURE && IS_REG_EXP) return toString(O).replace(searchValue, replaceValue);
        }
        string = toString(O);
        searchString = toString(searchValue);
        functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max(1, searchLength);
        position = stringIndexOf(string, searchString, 0);
        while(position !== -1){
            if (functionalReplace) replacement = toString(replaceValue(searchString, position, string));
            else replacement = getSubstitution(searchString, string, position, [], undefined, replaceValue);
            result += string.slice(endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = stringIndexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) result += string.slice(endOfLastMatch);
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/require-object-coercible":"1XURO","../internals/is-regexp":"b7miO","../internals/to-string":"k0ZQF","../internals/regexp-flags":"bmq3u","../internals/get-substitution":"hs6aX","../internals/well-known-symbol":"6sZ59","../internals/is-pure":"dlbEd"}],"9LcVn":[function(require,module,exports) {
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var sameValue = require('../internals/same-value');
var toString = require('../internals/to-string');
var regExpExec = require('../internals/regexp-exec-abstract');
// @@search logic
fixRegExpWellKnownSymbolLogic('search', function(SEARCH, nativeSearch, maybeCallNative) {
    return [
        // `String.prototype.search` method
        // https://tc39.es/ecma262/#sec-string.prototype.search
        function search(regexp) {
            var O = requireObjectCoercible(this);
            var searcher = regexp == undefined ? undefined : regexp[SEARCH];
            return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
        function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeSearch, rx, S);
            if (res.done) return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
        }
    ];
});

},{"../internals/fix-regexp-well-known-symbol-logic":"kKKB8","../internals/an-object":"9unxM","../internals/require-object-coercible":"1XURO","../internals/same-value":"4xcdM","../internals/to-string":"k0ZQF","../internals/regexp-exec-abstract":"cID5l"}],"5yIFY":[function(require,module,exports) {
'use strict';
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var isRegExp = require('../internals/is-regexp');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var callRegExpExec = require('../internals/regexp-exec-abstract');
var regexpExec = require('../internals/regexp-exec');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var fails = require('../internals/fails');
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 4294967295;
// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function() {
        return originalExec.apply(this, arguments);
    };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});
// @@split logic
fixRegExpWellKnownSymbolLogic('split', function(SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 || ''.split(/.?/).length) // based on es5-shim implementation, need to rework it
    internalSplit = function(separator, limit) {
        var string = toString(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [
            string
        ];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) return nativeSplit.call(string, separator, lim);
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while(match = regexpExec.call(separatorCopy, string)){
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
                output.push(string.slice(lastLastIndex, match.index));
                if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= lim) break;
            }
            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
            if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output.length > lim ? output.slice(0, lim) : output;
    };
    else if ('0'.split(undefined, 0).length) internalSplit = function(separator, limit) {
        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
    else internalSplit = nativeSplit;
    return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = separator == undefined ? undefined : separator[SPLIT];
            return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(toString(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y ? 'g' : 'y');
            // ^(? + rx + ) is needed, in combination with some S slicing, to
            // simulate the 'y' flag.
            var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [
                S
            ] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while(q < S.length){
                splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
                var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
                var e;
                if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) q = advanceStringIndex(S, q, unicodeMatching);
                else {
                    A.push(S.slice(p, q));
                    if (A.length === lim) return A;
                    for(var i = 1; i <= z.length - 1; i++){
                        A.push(z[i]);
                        if (A.length === lim) return A;
                    }
                    q = p = e;
                }
            }
            A.push(S.slice(p));
            return A;
        }
    ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

},{"../internals/fix-regexp-well-known-symbol-logic":"kKKB8","../internals/is-regexp":"b7miO","../internals/an-object":"9unxM","../internals/require-object-coercible":"1XURO","../internals/species-constructor":"6tv7V","../internals/advance-string-index":"eZF6s","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/regexp-exec-abstract":"cID5l","../internals/regexp-exec":"daEEr","../internals/regexp-sticky-helpers":"4mh9i","../internals/fails":"byxLb"}],"5IlYf":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var $startsWith = ''.startsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
    return descriptor && !descriptor.writable;
}();
// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
    startsWith: function startsWith(searchString /* , position = 0 */ ) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
        var search = toString(searchString);
        return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
});

},{"../internals/export":"2mZbc","../internals/object-get-own-property-descriptor":"hwpsT","../internals/to-length":"coWuj","../internals/to-string":"k0ZQF","../internals/not-a-regexp":"bmUBS","../internals/require-object-coercible":"1XURO","../internals/correct-is-regexp-logic":"kDBvg","../internals/is-pure":"dlbEd"}],"ffj2Y":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toInteger = require('../internals/to-integer');
var toString = require('../internals/to-string');
var slice = ''.slice;
var max = Math.max;
var min = Math.min;
// `String.prototype.substr` method
// https://tc39.es/ecma262/#sec-string.prototype.substr
$({
    target: 'String',
    proto: true
}, {
    substr: function substr(start, length) {
        var that = toString(requireObjectCoercible(this));
        var size = that.length;
        var intStart = toInteger(start);
        var intLength, intEnd;
        if (intStart === Infinity) intStart = 0;
        if (intStart < 0) intStart = max(size + intStart, 0);
        intLength = length === undefined ? size : toInteger(length);
        if (intLength <= 0 || intLength === Infinity) return '';
        intEnd = min(intStart + intLength, size);
        return intStart >= intEnd ? '' : slice.call(that, intStart, intEnd);
    }
});

},{"../internals/export":"2mZbc","../internals/require-object-coercible":"1XURO","../internals/to-integer":"gOCws","../internals/to-string":"k0ZQF"}],"1UwM0":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trim = require('../internals/string-trim').trim;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({
    target: 'String',
    proto: true,
    forced: forcedStringTrimMethod('trim')
}, {
    trim: function trim() {
        return $trim(this);
    }
});

},{"../internals/export":"2mZbc","../internals/string-trim":"crV5l","../internals/string-trim-forced":"gdmgb"}],"gdmgb":[function(require,module,exports) {
var fails = require('../internals/fails');
var whitespaces = require('../internals/whitespaces');
var non = '\u200B\u0085\u180E';
// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function(METHOD_NAME) {
    return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
};

},{"../internals/fails":"byxLb","../internals/whitespaces":"l0FoE"}],"67bv8":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trimEnd = require('../internals/string-trim').end;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
var FORCED = forcedStringTrimMethod('trimEnd');
var trimEnd = FORCED ? function trimEnd1() {
    return $trimEnd(this);
// eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
} : ''.trimEnd;
// `String.prototype.{ trimEnd, trimRight }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// https://tc39.es/ecma262/#String.prototype.trimright
$({
    target: 'String',
    proto: true,
    forced: FORCED
}, {
    trimEnd: trimEnd,
    trimRight: trimEnd
});

},{"../internals/export":"2mZbc","../internals/string-trim":"crV5l","../internals/string-trim-forced":"gdmgb"}],"cbyCh":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trimStart = require('../internals/string-trim').start;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
var FORCED = forcedStringTrimMethod('trimStart');
var trimStart = FORCED ? function trimStart1() {
    return $trimStart(this);
// eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
} : ''.trimStart;
// `String.prototype.{ trimStart, trimLeft }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
// https://tc39.es/ecma262/#String.prototype.trimleft
$({
    target: 'String',
    proto: true,
    forced: FORCED
}, {
    trimStart: trimStart,
    trimLeft: trimStart
});

},{"../internals/export":"2mZbc","../internals/string-trim":"crV5l","../internals/string-trim-forced":"gdmgb"}],"h582X":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('anchor')
}, {
    anchor: function anchor(name) {
        return createHTML(this, 'a', 'name', name);
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"8vf9l":[function(require,module,exports) {
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var quot = /"/g;
// `CreateHTML` abstract operation
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function(string, tag, attribute, value) {
    var S = toString(requireObjectCoercible(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + toString(value).replace(quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
};

},{"../internals/require-object-coercible":"1XURO","../internals/to-string":"k0ZQF"}],"jaNbw":[function(require,module,exports) {
var fails = require('../internals/fails');
// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function(METHOD_NAME) {
    return fails(function() {
        var test = ''[METHOD_NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
    });
};

},{"../internals/fails":"byxLb"}],"gSDtA":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.big` method
// https://tc39.es/ecma262/#sec-string.prototype.big
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('big')
}, {
    big: function big() {
        return createHTML(this, 'big', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"lTrep":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.blink` method
// https://tc39.es/ecma262/#sec-string.prototype.blink
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('blink')
}, {
    blink: function blink() {
        return createHTML(this, 'blink', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"kk4wr":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.bold` method
// https://tc39.es/ecma262/#sec-string.prototype.bold
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('bold')
}, {
    bold: function bold() {
        return createHTML(this, 'b', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"kdH1X":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fixed` method
// https://tc39.es/ecma262/#sec-string.prototype.fixed
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fixed')
}, {
    fixed: function fixed() {
        return createHTML(this, 'tt', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"412V5":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fontcolor` method
// https://tc39.es/ecma262/#sec-string.prototype.fontcolor
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fontcolor')
}, {
    fontcolor: function fontcolor(color) {
        return createHTML(this, 'font', 'color', color);
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"7TWRa":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fontsize` method
// https://tc39.es/ecma262/#sec-string.prototype.fontsize
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fontsize')
}, {
    fontsize: function fontsize(size) {
        return createHTML(this, 'font', 'size', size);
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"iOrbm":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.italics` method
// https://tc39.es/ecma262/#sec-string.prototype.italics
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('italics')
}, {
    italics: function italics() {
        return createHTML(this, 'i', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"3BgXC":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.link` method
// https://tc39.es/ecma262/#sec-string.prototype.link
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('link')
}, {
    link: function link(url) {
        return createHTML(this, 'a', 'href', url);
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"7usyq":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.small` method
// https://tc39.es/ecma262/#sec-string.prototype.small
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('small')
}, {
    small: function small() {
        return createHTML(this, 'small', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"6sGtc":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.strike` method
// https://tc39.es/ecma262/#sec-string.prototype.strike
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('strike')
}, {
    strike: function strike() {
        return createHTML(this, 'strike', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"k998D":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.sub` method
// https://tc39.es/ecma262/#sec-string.prototype.sub
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('sub')
}, {
    sub: function sub() {
        return createHTML(this, 'sub', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"a5Yf5":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.sup` method
// https://tc39.es/ecma262/#sec-string.prototype.sup
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('sup')
}, {
    sup: function sup() {
        return createHTML(this, 'sup', '', '');
    }
});

},{"../internals/export":"2mZbc","../internals/create-html":"8vf9l","../internals/string-html-forced":"jaNbw"}],"f9m3z":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float32', function(init) {
    return function Float32Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"1GFmu":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayBufferModule = require('../internals/array-buffer');
var anInstance = require('../internals/an-instance');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var isInteger = require('../internals/is-integer');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var toOffset = require('../internals/to-offset');
var toPropertyKey = require('../internals/to-property-key');
var has = require('../internals/has');
var classof = require('../internals/classof');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var create = require('../internals/object-create');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var typedArrayFrom = require('../internals/typed-array-from');
var forEach = require('../internals/array-iteration').forEach;
var setSpecies = require('../internals/set-species');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var InternalStateModule = require('../internals/internal-state');
var inheritIfRequired = require('../internals/inherit-if-required');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError1 = global.RangeError;
var ArrayBuffer1 = ArrayBufferModule.ArrayBuffer;
var DataView1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';
var fromList = function(C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while(length > index)result[index] = list[index++];
    return result;
};
var addGetter = function(it, key) {
    nativeDefineProperty(it, key, {
        get: function() {
            return getInternalState(this)[key];
        }
    });
};
var isArrayBuffer = function(it) {
    var klass;
    return it instanceof ArrayBuffer1 || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};
var isTypedArrayIndex = function(target, key) {
    return isTypedArray(target) && !isSymbol(key) && key in target && isInteger(+key) && key >= 0;
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    key = toPropertyKey(key);
    return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    key = toPropertyKey(key);
    if (isTypedArrayIndex(target, key) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
    }
    return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, 'buffer');
        addGetter(TypedArrayPrototype, 'byteOffset');
        addGetter(TypedArrayPrototype, 'byteLength');
        addGetter(TypedArrayPrototype, 'length');
    }
    $({
        target: 'Object',
        stat: true,
        forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
    });
    module.exports = function(TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+$/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + TYPE;
        var SETTER = 'set' + TYPE;
        var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {
        };
        var getter = function(that, index) {
            var data = getInternalState(that);
            return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };
        var setter = function(that, index, value) {
            var data = getInternalState(that);
            if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
            data.view[SETTER](index * BYTES + data.byteOffset, value, true);
        };
        var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
                get: function() {
                    return getter(this, index);
                },
                set: function(value) {
                    return setter(this, index, value);
                },
                enumerable: true
            });
        };
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                var index = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject(data)) {
                    length = toIndex(data);
                    byteLength = length * BYTES;
                    buffer = new ArrayBuffer1(byteLength);
                } else if (isArrayBuffer(data)) {
                    buffer = data;
                    byteOffset = toOffset(offset, BYTES);
                    var $len = data.byteLength;
                    if ($length === undefined) {
                        if ($len % BYTES) throw RangeError1(WRONG_LENGTH);
                        byteLength = $len - byteOffset;
                        if (byteLength < 0) throw RangeError1(WRONG_LENGTH);
                    } else {
                        byteLength = toLength($length) * BYTES;
                        if (byteLength + byteOffset > $len) throw RangeError1(WRONG_LENGTH);
                    }
                    length = byteLength / BYTES;
                } else if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                else return typedArrayFrom.call(TypedArrayConstructor, data);
                setInternalState(that, {
                    buffer: buffer,
                    byteOffset: byteOffset,
                    byteLength: byteLength,
                    length: length,
                    view: new DataView1(buffer)
                });
                while(index < length)addElement(that, index++);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                return inheritIfRequired(function() {
                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                    if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                    return typedArrayFrom.call(TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }
        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
        if (TYPED_ARRAY_TAG) createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        $({
            global: true,
            forced: TypedArrayConstructor != NativeTypedArrayConstructor,
            sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        setSpecies(CONSTRUCTOR_NAME);
    };
} else module.exports = function() {
};

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/descriptors":"kuDzl","../internals/typed-array-constructors-require-wrappers":"ke2up","../internals/array-buffer-view-core":"zd7ve","../internals/array-buffer":"hMeAx","../internals/an-instance":"gTr5k","../internals/create-property-descriptor":"5fdHA","../internals/create-non-enumerable-property":"73EkF","../internals/is-integer":"eoyrV","../internals/to-length":"coWuj","../internals/to-index":"iXt4Q","../internals/to-offset":"1WjsL","../internals/to-property-key":"99Lby","../internals/has":"aVEHj","../internals/classof":"gO6DW","../internals/is-object":"d60Kc","../internals/is-symbol":"hfIC8","../internals/object-create":"eYZeq","../internals/object-set-prototype-of":"k1Sl0","../internals/object-get-own-property-names":"38UqD","../internals/typed-array-from":"ceD5b","../internals/array-iteration":"ciNJ0","../internals/set-species":"99lPJ","../internals/object-define-property":"iKHmb","../internals/object-get-own-property-descriptor":"hwpsT","../internals/internal-state":"ceuiK","../internals/inherit-if-required":"5Ef3J"}],"ke2up":[function(require,module,exports) {
/* eslint-disable no-new -- required for testing */ var global = require('../internals/global');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer1 = global.ArrayBuffer;
var Int8Array1 = global.Int8Array;
module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
    Int8Array1(1);
}) || !fails(function() {
    new Int8Array1(-1);
}) || !checkCorrectnessOfIteration(function(iterable) {
    new Int8Array1();
    new Int8Array1(null);
    new Int8Array1(1.5);
    new Int8Array1(iterable);
}, true) || fails(function() {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array1(new ArrayBuffer1(2), 1, undefined).length !== 1;
});

},{"../internals/global":"a4GR8","../internals/fails":"byxLb","../internals/check-correctness-of-iteration":"lO6Bq","../internals/array-buffer-view-core":"zd7ve"}],"1WjsL":[function(require,module,exports) {
var toPositiveInteger = require('../internals/to-positive-integer');
module.exports = function(it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError('Wrong offset');
    return offset;
};

},{"../internals/to-positive-integer":"59Bw6"}],"59Bw6":[function(require,module,exports) {
var toInteger = require('../internals/to-integer');
module.exports = function(it) {
    var result = toInteger(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
};

},{"../internals/to-integer":"gOCws"}],"ceD5b":[function(require,module,exports) {
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var getIteratorMethod = require('../internals/get-iterator-method');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var bind = require('../internals/function-bind-context');
var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;
module.exports = function from(source /* , mapfn, thisArg */ ) {
    var O = toObject(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next;
    if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = iteratorMethod.call(O);
        next = iterator.next;
        O = [];
        while(!(step = next.call(iterator)).done)O.push(step.value);
    }
    if (mapping && argumentsLength > 2) mapfn = bind(mapfn, arguments[2], 2);
    length = toLength(O.length);
    result = new (aTypedArrayConstructor(this))(length);
    for(i = 0; length > i; i++)result[i] = mapping ? mapfn(O[i], i) : O[i];
    return result;
};

},{"../internals/to-object":"ghTKi","../internals/to-length":"coWuj","../internals/get-iterator-method":"btrxT","../internals/is-array-iterator-method":"fEVgY","../internals/function-bind-context":"1epb9","../internals/array-buffer-view-core":"zd7ve"}],"ky6XR":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float64', function(init) {
    return function Float64Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"lEs7k":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int8', function(init) {
    return function Int8Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"5EyRk":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int16', function(init) {
    return function Int16Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"cDL8j":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int32', function(init) {
    return function Int32Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"2HsmO":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function(init) {
    return function Uint8Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"dFa8q":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function(init) {
    return function Uint8ClampedArray1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
}, true);

},{"../internals/typed-array-constructor":"1GFmu"}],"aykHi":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint16', function(init) {
    return function Uint16Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"2oUhq":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint32', function(init) {
    return function Uint32Array1(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"1GFmu"}],"3ktIi":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $copyWithin = require('../internals/array-copy-within');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */ ) {
    return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-copy-within":"gaD2u"}],"5DxE6":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $every = require('../internals/array-iteration').every;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */ ) {
    return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0"}],"fqjtk":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $fill = require('../internals/array-fill');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('fill', function fill(value /* , start, end */ ) {
    return $fill.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-fill":"hYFo3"}],"1uzjz":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filter = require('../internals/array-iteration').filter;
var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */ ) {
    var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return fromSpeciesAndList(this, list);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0","../internals/typed-array-from-species-and-list":"7zmLU"}],"7zmLU":[function(require,module,exports) {
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
module.exports = function(instance, list) {
    return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
};

},{"../internals/array-from-constructor-and-list":"eZkfw","../internals/typed-array-species-constructor":"9xT79"}],"eZkfw":[function(require,module,exports) {
module.exports = function(Constructor, list) {
    var index = 0;
    var length = list.length;
    var result = new Constructor(length);
    while(length > index)result[index] = list[index++];
    return result;
};

},{}],"9xT79":[function(require,module,exports) {
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var speciesConstructor = require('../internals/species-constructor');
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
// a part of `TypedArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#typedarray-species-create
module.exports = function(originalArray) {
    return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
};

},{"../internals/array-buffer-view-core":"zd7ve","../internals/species-constructor":"6tv7V"}],"d7VSQ":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $find = require('../internals/array-iteration').find;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */ ) {
    return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0"}],"llIwb":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findIndex = require('../internals/array-iteration').findIndex;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */ ) {
    return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0"}],"Wrhx0":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $forEach = require('../internals/array-iteration').forEach;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */ ) {
    $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0"}],"fgrPV":[function(require,module,exports) {
'use strict';
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var exportTypedArrayStaticMethod = require('../internals/array-buffer-view-core').exportTypedArrayStaticMethod;
var typedArrayFrom = require('../internals/typed-array-from');
// `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/typed-array-constructors-require-wrappers":"ke2up","../internals/array-buffer-view-core":"zd7ve","../internals/typed-array-from":"ceD5b"}],"afXwJ":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $includes = require('../internals/array-includes').includes;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */ ) {
    return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-includes":"cmRkV"}],"ffWJN":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $indexOf = require('../internals/array-includes').indexOf;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */ ) {
    return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-includes":"cmRkV"}],"dWqIW":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayIterators = require('../modules/es.array.iterator');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array1 = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array1 && Uint8Array1.prototype[ITERATOR];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
var typedArrayValues = function values() {
    return arrayValues.call(aTypedArray(this));
};
// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
    return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
    return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

},{"../internals/global":"a4GR8","../internals/array-buffer-view-core":"zd7ve","../modules/es.array.iterator":"8YPvt","../internals/well-known-symbol":"6sZ59"}],"30Fjw":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;
// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('join', function join(separator) {
    return $join.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":"zd7ve"}],"fUt12":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $lastIndexOf = require('../internals/array-last-index-of');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */ ) {
    return $lastIndexOf.apply(aTypedArray(this), arguments);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-last-index-of":"3G0we"}],"abKo8":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $map = require('../internals/array-iteration').map;
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */ ) {
    return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function(O, length) {
        return new (typedArraySpeciesConstructor(O))(length);
    });
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0","../internals/typed-array-species-constructor":"9xT79"}],"aASoo":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
// `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod('of', function of() {
    var index = 0;
    var length = arguments.length;
    var result = new (aTypedArrayConstructor(this))(length);
    while(length > index)result[index] = arguments[index++];
    return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/array-buffer-view-core":"zd7ve","../internals/typed-array-constructors-require-wrappers":"ke2up"}],"cw3bd":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduce = require('../internals/array-reduce').left;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */ ) {
    return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-reduce":"8zC1E"}],"fIIbY":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduceRight = require('../internals/array-reduce').right;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */ ) {
    return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-reduce":"8zC1E"}],"aYS8V":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;
// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
    var that = this;
    var length = aTypedArray(that).length;
    var middle = floor(length / 2);
    var index = 0;
    var value;
    while(index < middle){
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
    }
    return that;
});

},{"../internals/array-buffer-view-core":"zd7ve"}],"4UlXb":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toOffset = require('../internals/to-offset');
var toObject = require('../internals/to-object');
var fails = require('../internals/fails');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var FORCED = fails(function() {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    new Int8Array(1).set({
    });
});
// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */ ) {
    aTypedArray(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError('Wrong length');
    while(index < len)this[offset + index] = src[index++];
}, FORCED);

},{"../internals/array-buffer-view-core":"zd7ve","../internals/to-length":"coWuj","../internals/to-offset":"1WjsL","../internals/to-object":"ghTKi","../internals/fails":"byxLb"}],"fmByv":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var fails = require('../internals/fails');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;
var FORCED = fails(function() {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    new Int8Array(1).slice();
});
// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
    var list = $slice.call(aTypedArray(this), start, end);
    var C = typedArraySpeciesConstructor(this);
    var index = 0;
    var length = list.length;
    var result = new C(length);
    while(length > index)result[index] = list[index++];
    return result;
}, FORCED);

},{"../internals/array-buffer-view-core":"zd7ve","../internals/typed-array-species-constructor":"9xT79","../internals/fails":"byxLb"}],"adzA5":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $some = require('../internals/array-iteration').some;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */ ) {
    return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/array-iteration":"ciNJ0"}],"7J6wI":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var global = require('../internals/global');
var fails = require('../internals/fails');
var aFunction = require('../internals/a-function');
var toLength = require('../internals/to-length');
var internalSort = require('../internals/array-sort');
var FF = require('../internals/engine-ff-version');
var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
var V8 = require('../internals/engine-v8-version');
var WEBKIT = require('../internals/engine-webkit-version');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array1 = global.Uint16Array;
var nativeSort = Uint16Array1 && Uint16Array1.prototype.sort;
// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !fails(function() {
    var array = new Uint16Array1(2);
    array.sort(null);
    array.sort({
    });
});
var STABLE_SORT = !!nativeSort && !fails(function() {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 74;
    if (FF) return FF < 67;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 602;
    var array = new Uint16Array1(516);
    var expected = Array(516);
    var index, mod;
    for(index = 0; index < 516; index++){
        mod = index % 4;
        array[index] = 515 - index;
        expected[index] = index - 2 * mod + 3;
    }
    array.sort(function(a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
    });
    for(index = 0; index < 516; index++){
        if (array[index] !== expected[index]) return true;
    }
});
var getSortCompare = function(comparefn) {
    return function(x, y) {
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        // eslint-disable-next-line no-self-compare -- NaN check
        if (y !== y) return -1;
        // eslint-disable-next-line no-self-compare -- NaN check
        if (x !== x) return 1;
        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
    };
};
// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
    var array = this;
    if (comparefn !== undefined) aFunction(comparefn);
    if (STABLE_SORT) return nativeSort.call(array, comparefn);
    aTypedArray(array);
    var arrayLength = toLength(array.length);
    var items = Array(arrayLength);
    var index;
    for(index = 0; index < arrayLength; index++)items[index] = array[index];
    items = internalSort(array, getSortCompare(comparefn));
    for(index = 0; index < arrayLength; index++)array[index] = items[index];
    return array;
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

},{"../internals/array-buffer-view-core":"zd7ve","../internals/global":"a4GR8","../internals/fails":"byxLb","../internals/a-function":"43ldr","../internals/to-length":"coWuj","../internals/array-sort":"aFml7","../internals/engine-ff-version":"ftzYY","../internals/engine-is-ie-or-edge":"5GiwV","../internals/engine-v8-version":"8Ofbb","../internals/engine-webkit-version":"6Jcx4"}],"ghLDl":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
    var O = aTypedArray(this);
    var length = O.length;
    var beginIndex = toAbsoluteIndex(begin, length);
    var C = typedArraySpeciesConstructor(O);
    return new C(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

},{"../internals/array-buffer-view-core":"zd7ve","../internals/to-length":"coWuj","../internals/to-absolute-index":"bWCPe","../internals/typed-array-species-constructor":"9xT79"}],"kaAyh":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var fails = require('../internals/fails');
var Int8Array1 = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;
// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array1 && fails(function() {
    $toLocaleString.call(new Int8Array1(1));
});
var FORCED = fails(function() {
    return [
        1,
        2
    ].toLocaleString() != new Int8Array1([
        1,
        2
    ]).toLocaleString();
}) || !fails(function() {
    Int8Array1.prototype.toLocaleString.call([
        1,
        2
    ]);
});
// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);

},{"../internals/global":"a4GR8","../internals/array-buffer-view-core":"zd7ve","../internals/fails":"byxLb"}],"4lkfC":[function(require,module,exports) {
'use strict';
var exportTypedArrayMethod = require('../internals/array-buffer-view-core').exportTypedArrayMethod;
var fails = require('../internals/fails');
var global = require('../internals/global');
var Uint8Array1 = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array1 && Uint8Array1.prototype || {
};
var arrayToString = [].toString;
var arrayJoin = [].join;
if (fails(function() {
    arrayToString.call({
    });
})) arrayToString = function toString() {
    return arrayJoin.call(this);
};
var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

},{"../internals/array-buffer-view-core":"zd7ve","../internals/fails":"byxLb","../internals/global":"a4GR8"}],"gnnik":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toString = require('../internals/to-string');
var fromCharCode = String.fromCharCode;
var hex2 = /^[\da-f]{2}$/i;
var hex4 = /^[\da-f]{4}$/i;
// `unescape` method
// https://tc39.es/ecma262/#sec-unescape-string
$({
    global: true
}, {
    unescape: function unescape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, slice;
        while(index < length){
            chr = str.charAt(index++);
            if (chr === '%') {
                if (str.charAt(index) === 'u') {
                    slice = str.slice(index + 1, index + 5);
                    if (hex4.test(slice)) {
                        result += fromCharCode(parseInt(slice, 16));
                        index += 5;
                        continue;
                    }
                } else {
                    slice = str.slice(index, index + 2);
                    if (hex2.test(slice)) {
                        result += fromCharCode(parseInt(slice, 16));
                        index += 2;
                        continue;
                    }
                }
            }
            result += chr;
        }
        return result;
    }
});

},{"../internals/export":"2mZbc","../internals/to-string":"k0ZQF"}],"7VYon":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var redefineAll = require('../internals/redefine-all');
var InternalMetadataModule = require('../internals/internal-metadata');
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
var isObject = require('../internals/is-object');
var enforceIternalState = require('../internals/internal-state').enforce;
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = Object.isExtensible;
var InternalWeakMap;
var wrapper = function(init) {
    return function WeakMap1() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
};
// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);
// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
    InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
    InternalMetadataModule.enable();
    var WeakMapPrototype = $WeakMap.prototype;
    var nativeDelete = WeakMapPrototype['delete'];
    var nativeHas = WeakMapPrototype.has;
    var nativeGet = WeakMapPrototype.get;
    var nativeSet = WeakMapPrototype.set;
    redefineAll(WeakMapPrototype, {
        'delete': function(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceIternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeDelete.call(this, key) || state.frozen['delete'](key);
            }
            return nativeDelete.call(this, key);
        },
        has: function has(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceIternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas.call(this, key) || state.frozen.has(key);
            }
            return nativeHas.call(this, key);
        },
        get: function get(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceIternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
            }
            return nativeGet.call(this, key);
        },
        set: function set(key, value) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceIternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
            } else nativeSet.call(this, key, value);
            return this;
        }
    });
}

},{"../internals/global":"a4GR8","../internals/redefine-all":"4a8AR","../internals/internal-metadata":"5OjLO","../internals/collection":"8qCpd","../internals/collection-weak":"h7PPS","../internals/is-object":"d60Kc","../internals/internal-state":"ceuiK","../internals/native-weak-map":"kny3R"}],"h7PPS":[function(require,module,exports) {
'use strict';
var redefineAll = require('../internals/redefine-all');
var getWeakData = require('../internals/internal-metadata').getWeakData;
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var ArrayIterationModule = require('../internals/array-iteration');
var $has = require('../internals/has');
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0;
// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(store) {
    return store.frozen || (store.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
    this.entries = [];
};
var findUncaughtFrozen = function(store, key) {
    return find(store.entries, function(it) {
        return it[0] === key;
    });
};
UncaughtFrozenStore.prototype = {
    get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
    },
    has: function(key) {
        return !!findUncaughtFrozen(this, key);
    },
    set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;
        else this.entries.push([
            key,
            value
        ]);
    },
    'delete': function(key) {
        var index = findIndex(this.entries, function(it) {
            return it[0] === key;
        });
        if (~index) this.entries.splice(index, 1);
        return !!~index;
    }
};
module.exports = {
    getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
            anInstance(that, C, CONSTRUCTOR_NAME);
            setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                id: id++,
                frozen: undefined
            });
            if (iterable != undefined) iterate(iterable, that[ADDER], {
                that: that,
                AS_ENTRIES: IS_MAP
            });
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
            var state = getInternalState(that);
            var data = getWeakData(anObject(key), true);
            if (data === true) uncaughtFrozenStore(state).set(key, value);
            else data[state.id] = value;
            return that;
        };
        redefineAll(C.prototype, {
            // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
            // https://tc39.es/ecma262/#sec-weakset.prototype.delete
            'delete': function(key) {
                var state = getInternalState(this);
                if (!isObject(key)) return false;
                var data = getWeakData(key);
                if (data === true) return uncaughtFrozenStore(state)['delete'](key);
                return data && $has(data, state.id) && delete data[state.id];
            },
            // `{ WeakMap, WeakSet }.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.has
            // https://tc39.es/ecma262/#sec-weakset.prototype.has
            has: function has(key) {
                var state = getInternalState(this);
                if (!isObject(key)) return false;
                var data = getWeakData(key);
                if (data === true) return uncaughtFrozenStore(state).has(key);
                return data && $has(data, state.id);
            }
        });
        redefineAll(C.prototype, IS_MAP ? {
            // `WeakMap.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.get
            get: function get(key) {
                var state = getInternalState(this);
                if (isObject(key)) {
                    var data = getWeakData(key);
                    if (data === true) return uncaughtFrozenStore(state).get(key);
                    return data ? data[state.id] : undefined;
                }
            },
            // `WeakMap.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.set
            set: function set(key, value) {
                return define(this, key, value);
            }
        } : {
            // `WeakSet.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-weakset.prototype.add
            add: function add(value) {
                return define(this, value, true);
            }
        });
        return C;
    }
};

},{"../internals/redefine-all":"4a8AR","../internals/internal-metadata":"5OjLO","../internals/an-object":"9unxM","../internals/is-object":"d60Kc","../internals/an-instance":"gTr5k","../internals/iterate":"a4R19","../internals/array-iteration":"ciNJ0","../internals/has":"aVEHj","../internals/internal-state":"ceuiK"}],"kMVCu":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
// `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor
collection('WeakSet', function(init) {
    return function WeakSet1() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionWeak);

},{"../internals/collection":"8qCpd","../internals/collection-weak":"h7PPS"}],"917na":[function(require,module,exports) {
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var forEach = require('../internals/array-for-each');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
for(var COLLECTION_NAME in DOMIterables){
    var Collection = global[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
    } catch (error) {
        CollectionPrototype.forEach = forEach;
    }
}

},{"../internals/global":"a4GR8","../internals/dom-iterables":"2Umkc","../internals/array-for-each":"dwspA","../internals/create-non-enumerable-property":"73EkF"}],"2Umkc":[function(require,module,exports) {
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
};

},{}],"gC8gE":[function(require,module,exports) {
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var ArrayIteratorMethods = require('../modules/es.array.iterator');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;
for(var COLLECTION_NAME in DOMIterables){
    var Collection = global[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
        }
        if (!CollectionPrototype[TO_STRING_TAG]) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
        }
    }
}

},{"../internals/global":"a4GR8","../internals/dom-iterables":"2Umkc","../modules/es.array.iterator":"8YPvt","../internals/create-non-enumerable-property":"73EkF","../internals/well-known-symbol":"6sZ59"}],"6VxKM":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var task = require('../internals/task');
var FORCED = !global.setImmediate || !global.clearImmediate;
// http://w3c.github.io/setImmediate/
$({
    global: true,
    bind: true,
    enumerable: true,
    forced: FORCED
}, {
    // `setImmediate` method
    // http://w3c.github.io/setImmediate/#si-setImmediate
    setImmediate: task.set,
    // `clearImmediate` method
    // http://w3c.github.io/setImmediate/#si-clearImmediate
    clearImmediate: task.clear
});

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/task":"iBmTD"}],"kIUUV":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var microtask = require('../internals/microtask');
var IS_NODE = require('../internals/engine-is-node');
var process = global.process;
// `queueMicrotask` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
$({
    global: true,
    enumerable: true,
    noTargetGet: true
}, {
    queueMicrotask: function queueMicrotask(fn) {
        var domain = IS_NODE && process.domain;
        microtask(domain ? domain.bind(fn) : fn);
    }
});

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/microtask":"8Si7u","../internals/engine-is-node":"gpWpt"}],"8IM6S":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function(scheduler) {
    return function(handler, timeout /* , ...arguments */ ) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? slice.call(arguments, 2) : undefined;
        return scheduler(boundArgs ? function() {
            // eslint-disable-next-line no-new-func -- spec requirement
            (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
        } : handler, timeout);
    };
};
// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
$({
    global: true,
    bind: true,
    forced: MSIE
}, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global.setInterval)
});

},{"../internals/export":"2mZbc","../internals/global":"a4GR8","../internals/engine-user-agent":"ihes9"}],"c61iN":[function(require,module,exports) {
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.string.iterator');
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var USE_NATIVE_URL = require('../internals/native-url');
var global = require('../internals/global');
var defineProperties = require('../internals/object-define-properties');
var redefine = require('../internals/redefine');
var anInstance = require('../internals/an-instance');
var has = require('../internals/has');
var assign = require('../internals/object-assign');
var arrayFrom = require('../internals/array-from');
var codeAt = require('../internals/string-multibyte').codeAt;
var toASCII = require('../internals/string-punycode-to-ascii');
var $toString = require('../internals/to-string');
var setToStringTag = require('../internals/set-to-string-tag');
var URLSearchParamsModule = require('../modules/web.url-search-params');
var InternalStateModule = require('../internals/internal-state');
var NativeURL = global.URL;
var URLSearchParams1 = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[A-Za-z]/;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
/* eslint-disable no-control-regex -- safe */ var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable no-control-regex -- safe */ var EOF;
var parseHost = function(url, input) {
    var result, codePoints, index;
    if (input.charAt(0) == '[') {
        if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
        result = parseIPv6(input.slice(1, -1));
        if (!result) return INVALID_HOST;
        url.host = result;
    // opaque host
    } else if (!isSpecial(url)) {
        if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
        result = '';
        codePoints = arrayFrom(input);
        for(index = 0; index < codePoints.length; index++)result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
        url.host = result;
    } else {
        input = toASCII(input);
        if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
        result = parseIPv4(input);
        if (result === null) return INVALID_HOST;
        url.host = result;
    }
};
var parseIPv4 = function(input) {
    var parts = input.split('.');
    var partsLength, numbers, index, part, radix, number, ipv4;
    if (parts.length && parts[parts.length - 1] == '') parts.pop();
    partsLength = parts.length;
    if (partsLength > 4) return input;
    numbers = [];
    for(index = 0; index < partsLength; index++){
        part = parts[index];
        if (part == '') return input;
        radix = 10;
        if (part.length > 1 && part.charAt(0) == '0') {
            radix = HEX_START.test(part) ? 16 : 8;
            part = part.slice(radix == 8 ? 1 : 2);
        }
        if (part === '') number = 0;
        else {
            if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
            number = parseInt(part, radix);
        }
        numbers.push(number);
    }
    for(index = 0; index < partsLength; index++){
        number = numbers[index];
        if (index == partsLength - 1) {
            if (number >= pow(256, 5 - partsLength)) return null;
        } else if (number > 255) return null;
    }
    ipv4 = numbers.pop();
    for(index = 0; index < numbers.length; index++)ipv4 += numbers[index] * pow(256, 3 - index);
    return ipv4;
};
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function(input) {
    var address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    var pieceIndex = 0;
    var compress = null;
    var pointer = 0;
    var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
    var char = function() {
        return input.charAt(pointer);
    };
    if (char() == ':') {
        if (input.charAt(1) != ':') return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
    }
    while(char()){
        if (pieceIndex == 8) return;
        if (char() == ':') {
            if (compress !== null) return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
        }
        value = length = 0;
        while(length < 4 && HEX.test(char())){
            value = value * 16 + parseInt(char(), 16);
            pointer++;
            length++;
        }
        if (char() == '.') {
            if (length == 0) return;
            pointer -= length;
            if (pieceIndex > 6) return;
            numbersSeen = 0;
            while(char()){
                ipv4Piece = null;
                if (numbersSeen > 0) {
                    if (char() == '.' && numbersSeen < 4) pointer++;
                    else return;
                }
                if (!DIGIT.test(char())) return;
                while(DIGIT.test(char())){
                    number = parseInt(char(), 10);
                    if (ipv4Piece === null) ipv4Piece = number;
                    else if (ipv4Piece == 0) return;
                    else ipv4Piece = ipv4Piece * 10 + number;
                    if (ipv4Piece > 255) return;
                    pointer++;
                }
                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
            }
            if (numbersSeen != 4) return;
            break;
        } else if (char() == ':') {
            pointer++;
            if (!char()) return;
        } else if (char()) return;
        address[pieceIndex++] = value;
    }
    if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex != 0 && swaps > 0){
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
        }
    } else if (pieceIndex != 8) return;
    return address;
};
var findLongestZeroSequence = function(ipv6) {
    var maxIndex = null;
    var maxLength = 1;
    var currStart = null;
    var currLength = 0;
    var index = 0;
    for(; index < 8; index++)if (ipv6[index] !== 0) {
        if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
        }
        currStart = null;
        currLength = 0;
    } else {
        if (currStart === null) currStart = index;
        ++currLength;
    }
    if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
    }
    return maxIndex;
};
var serializeHost = function(host) {
    var result, index, compress, ignore0;
    // ipv4
    if (typeof host == 'number') {
        result = [];
        for(index = 0; index < 4; index++){
            result.unshift(host % 256);
            host = floor(host / 256);
        }
        return result.join('.');
    // ipv6
    } else if (typeof host == 'object') {
        result = '';
        compress = findLongestZeroSequence(host);
        for(index = 0; index < 8; index++){
            if (ignore0 && host[index] === 0) continue;
            if (ignore0) ignore0 = false;
            if (compress === index) {
                result += index ? ':' : '::';
                ignore0 = true;
            } else {
                result += host[index].toString(16);
                if (index < 7) result += ':';
            }
        }
        return '[' + result + ']';
    }
    return host;
};
var C0ControlPercentEncodeSet = {
};
var fragmentPercentEncodeSet = assign({
}, C0ControlPercentEncodeSet, {
    ' ': 1,
    '"': 1,
    '<': 1,
    '>': 1,
    '`': 1
});
var pathPercentEncodeSet = assign({
}, fragmentPercentEncodeSet, {
    '#': 1,
    '?': 1,
    '{': 1,
    '}': 1
});
var userinfoPercentEncodeSet = assign({
}, pathPercentEncodeSet, {
    '/': 1,
    ':': 1,
    ';': 1,
    '=': 1,
    '@': 1,
    '[': 1,
    '\\': 1,
    ']': 1,
    '^': 1,
    '|': 1
});
var percentEncode = function(char, set) {
    var code = codeAt(char, 0);
    return code > 32 && code < 127 && !has(set, char) ? char : encodeURIComponent(char);
};
var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
var isSpecial = function(url) {
    return has(specialSchemes, url.scheme);
};
var includesCredentials = function(url) {
    return url.username != '' || url.password != '';
};
var cannotHaveUsernamePasswordPort = function(url) {
    return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};
var isWindowsDriveLetter = function(string, normalized) {
    var second;
    return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
};
var startsWithWindowsDriveLetter = function(string) {
    var third;
    return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
};
var shortenURLsPath = function(url) {
    var path = url.path;
    var pathSize = path.length;
    if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) path.pop();
};
var isSingleDot = function(segment) {
    return segment === '.' || segment.toLowerCase() === '%2e';
};
var isDoubleDot = function(segment) {
    segment = segment.toLowerCase();
    return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};
// States:
var SCHEME_START = {
};
var SCHEME = {
};
var NO_SCHEME = {
};
var SPECIAL_RELATIVE_OR_AUTHORITY = {
};
var PATH_OR_AUTHORITY = {
};
var RELATIVE = {
};
var RELATIVE_SLASH = {
};
var SPECIAL_AUTHORITY_SLASHES = {
};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {
};
var AUTHORITY = {
};
var HOST = {
};
var HOSTNAME = {
};
var PORT = {
};
var FILE = {
};
var FILE_SLASH = {
};
var FILE_HOST = {
};
var PATH_START = {
};
var PATH = {
};
var CANNOT_BE_A_BASE_URL_PATH = {
};
var QUERY = {
};
var FRAGMENT = {
};
// eslint-disable-next-line max-statements -- TODO
var parseURL = function(url, input, stateOverride, base) {
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, char, bufferCodePoints, failure;
    if (!stateOverride) {
        url.scheme = '';
        url.username = '';
        url.password = '';
        url.host = null;
        url.port = null;
        url.path = [];
        url.query = null;
        url.fragment = null;
        url.cannotBeABaseURL = false;
        input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
    }
    input = input.replace(TAB_AND_NEW_LINE, '');
    codePoints = arrayFrom(input);
    while(pointer <= codePoints.length){
        char = codePoints[pointer];
        switch(state){
            case SCHEME_START:
                if (char && ALPHA.test(char)) {
                    buffer += char.toLowerCase();
                    state = SCHEME;
                } else if (!stateOverride) {
                    state = NO_SCHEME;
                    continue;
                } else return INVALID_SCHEME;
                break;
            case SCHEME:
                if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) buffer += char.toLowerCase();
                else if (char == ':') {
                    if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
                    url.scheme = buffer;
                    if (stateOverride) {
                        if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
                        return;
                    }
                    buffer = '';
                    if (url.scheme == 'file') state = FILE;
                    else if (isSpecial(url) && base && base.scheme == url.scheme) state = SPECIAL_RELATIVE_OR_AUTHORITY;
                    else if (isSpecial(url)) state = SPECIAL_AUTHORITY_SLASHES;
                    else if (codePoints[pointer + 1] == '/') {
                        state = PATH_OR_AUTHORITY;
                        pointer++;
                    } else {
                        url.cannotBeABaseURL = true;
                        url.path.push('');
                        state = CANNOT_BE_A_BASE_URL_PATH;
                    }
                } else if (!stateOverride) {
                    buffer = '';
                    state = NO_SCHEME;
                    pointer = 0;
                    continue;
                } else return INVALID_SCHEME;
                break;
            case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME;
                if (base.cannotBeABaseURL && char == '#') {
                    url.scheme = base.scheme;
                    url.path = base.path.slice();
                    url.query = base.query;
                    url.fragment = '';
                    url.cannotBeABaseURL = true;
                    state = FRAGMENT;
                    break;
                }
                state = base.scheme == 'file' ? FILE : RELATIVE;
                continue;
            case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (char == '/' && codePoints[pointer + 1] == '/') {
                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                    pointer++;
                } else {
                    state = RELATIVE;
                    continue;
                }
                break;
            case PATH_OR_AUTHORITY:
                if (char == '/') {
                    state = AUTHORITY;
                    break;
                } else {
                    state = PATH;
                    continue;
                }
            case RELATIVE:
                url.scheme = base.scheme;
                if (char == EOF) {
                    url.username = base.username;
                    url.password = base.password;
                    url.host = base.host;
                    url.port = base.port;
                    url.path = base.path.slice();
                    url.query = base.query;
                } else if (char == '/' || char == '\\' && isSpecial(url)) state = RELATIVE_SLASH;
                else if (char == '?') {
                    url.username = base.username;
                    url.password = base.password;
                    url.host = base.host;
                    url.port = base.port;
                    url.path = base.path.slice();
                    url.query = '';
                    state = QUERY;
                } else if (char == '#') {
                    url.username = base.username;
                    url.password = base.password;
                    url.host = base.host;
                    url.port = base.port;
                    url.path = base.path.slice();
                    url.query = base.query;
                    url.fragment = '';
                    state = FRAGMENT;
                } else {
                    url.username = base.username;
                    url.password = base.password;
                    url.host = base.host;
                    url.port = base.port;
                    url.path = base.path.slice();
                    url.path.pop();
                    state = PATH;
                    continue;
                }
                break;
            case RELATIVE_SLASH:
                if (isSpecial(url) && (char == '/' || char == '\\')) state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                else if (char == '/') state = AUTHORITY;
                else {
                    url.username = base.username;
                    url.password = base.password;
                    url.host = base.host;
                    url.port = base.port;
                    state = PATH;
                    continue;
                }
                break;
            case SPECIAL_AUTHORITY_SLASHES:
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
                pointer++;
                break;
            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (char != '/' && char != '\\') {
                    state = AUTHORITY;
                    continue;
                }
                break;
            case AUTHORITY:
                if (char == '@') {
                    if (seenAt) buffer = '%40' + buffer;
                    seenAt = true;
                    bufferCodePoints = arrayFrom(buffer);
                    for(var i = 0; i < bufferCodePoints.length; i++){
                        var codePoint = bufferCodePoints[i];
                        if (codePoint == ':' && !seenPasswordToken) {
                            seenPasswordToken = true;
                            continue;
                        }
                        var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                        if (seenPasswordToken) url.password += encodedCodePoints;
                        else url.username += encodedCodePoints;
                    }
                    buffer = '';
                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                    if (seenAt && buffer == '') return INVALID_AUTHORITY;
                    pointer -= arrayFrom(buffer).length + 1;
                    buffer = '';
                    state = HOST;
                } else buffer += char;
                break;
            case HOST:
            case HOSTNAME:
                if (stateOverride && url.scheme == 'file') {
                    state = FILE_HOST;
                    continue;
                } else if (char == ':' && !seenBracket) {
                    if (buffer == '') return INVALID_HOST;
                    failure = parseHost(url, buffer);
                    if (failure) return failure;
                    buffer = '';
                    state = PORT;
                    if (stateOverride == HOSTNAME) return;
                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                    if (isSpecial(url) && buffer == '') return INVALID_HOST;
                    if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
                    failure = parseHost(url, buffer);
                    if (failure) return failure;
                    buffer = '';
                    state = PATH_START;
                    if (stateOverride) return;
                    continue;
                } else {
                    if (char == '[') seenBracket = true;
                    else if (char == ']') seenBracket = false;
                    buffer += char;
                }
                break;
            case PORT:
                if (DIGIT.test(char)) buffer += char;
                else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
                    if (buffer != '') {
                        var port = parseInt(buffer, 10);
                        if (port > 65535) return INVALID_PORT;
                        url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
                        buffer = '';
                    }
                    if (stateOverride) return;
                    state = PATH_START;
                    continue;
                } else return INVALID_PORT;
                break;
            case FILE:
                url.scheme = 'file';
                if (char == '/' || char == '\\') state = FILE_SLASH;
                else if (base && base.scheme == 'file') {
                    if (char == EOF) {
                        url.host = base.host;
                        url.path = base.path.slice();
                        url.query = base.query;
                    } else if (char == '?') {
                        url.host = base.host;
                        url.path = base.path.slice();
                        url.query = '';
                        state = QUERY;
                    } else if (char == '#') {
                        url.host = base.host;
                        url.path = base.path.slice();
                        url.query = base.query;
                        url.fragment = '';
                        state = FRAGMENT;
                    } else {
                        if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                            url.host = base.host;
                            url.path = base.path.slice();
                            shortenURLsPath(url);
                        }
                        state = PATH;
                        continue;
                    }
                } else {
                    state = PATH;
                    continue;
                }
                break;
            case FILE_SLASH:
                if (char == '/' || char == '\\') {
                    state = FILE_HOST;
                    break;
                }
                if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                    if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
                    else url.host = base.host;
                }
                state = PATH;
                continue;
            case FILE_HOST:
                if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
                    if (!stateOverride && isWindowsDriveLetter(buffer)) state = PATH;
                    else if (buffer == '') {
                        url.host = '';
                        if (stateOverride) return;
                        state = PATH_START;
                    } else {
                        failure = parseHost(url, buffer);
                        if (failure) return failure;
                        if (url.host == 'localhost') url.host = '';
                        if (stateOverride) return;
                        buffer = '';
                        state = PATH_START;
                    }
                    continue;
                } else buffer += char;
                break;
            case PATH_START:
                if (isSpecial(url)) {
                    state = PATH;
                    if (char != '/' && char != '\\') continue;
                } else if (!stateOverride && char == '?') {
                    url.query = '';
                    state = QUERY;
                } else if (!stateOverride && char == '#') {
                    url.fragment = '';
                    state = FRAGMENT;
                } else if (char != EOF) {
                    state = PATH;
                    if (char != '/') continue;
                }
                break;
            case PATH:
                if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
                    if (isDoubleDot(buffer)) {
                        shortenURLsPath(url);
                        if (char != '/' && !(char == '\\' && isSpecial(url))) url.path.push('');
                    } else if (isSingleDot(buffer)) {
                        if (char != '/' && !(char == '\\' && isSpecial(url))) url.path.push('');
                    } else {
                        if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                            if (url.host) url.host = '';
                            buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
                        }
                        url.path.push(buffer);
                    }
                    buffer = '';
                    if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) while(url.path.length > 1 && url.path[0] === '')url.path.shift();
                    if (char == '?') {
                        url.query = '';
                        state = QUERY;
                    } else if (char == '#') {
                        url.fragment = '';
                        state = FRAGMENT;
                    }
                } else buffer += percentEncode(char, pathPercentEncodeSet);
                break;
            case CANNOT_BE_A_BASE_URL_PATH:
                if (char == '?') {
                    url.query = '';
                    state = QUERY;
                } else if (char == '#') {
                    url.fragment = '';
                    state = FRAGMENT;
                } else if (char != EOF) url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
                break;
            case QUERY:
                if (!stateOverride && char == '#') {
                    url.fragment = '';
                    state = FRAGMENT;
                } else if (char != EOF) {
                    if (char == "'" && isSpecial(url)) url.query += '%27';
                    else if (char == '#') url.query += '%23';
                    else url.query += percentEncode(char, C0ControlPercentEncodeSet);
                }
                break;
            case FRAGMENT:
                if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
                break;
        }
        pointer++;
    }
};
// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL1(url /* , base */ ) {
    var that = anInstance(this, URLConstructor, 'URL');
    var base = arguments.length > 1 ? arguments[1] : undefined;
    var urlString = $toString(url);
    var state = setInternalState(that, {
        type: 'URL'
    });
    var baseState, failure;
    if (base !== undefined) {
        if (base instanceof URLConstructor) baseState = getInternalURLState(base);
        else {
            failure = parseURL(baseState = {
            }, $toString(base));
            if (failure) throw TypeError(failure);
        }
    }
    failure = parseURL(state, urlString, null, baseState);
    if (failure) throw TypeError(failure);
    var searchParams = state.searchParams = new URLSearchParams1();
    var searchParamsState = getInternalSearchParamsState(searchParams);
    searchParamsState.updateSearchParams(state.query);
    searchParamsState.updateURL = function() {
        state.query = String(searchParams) || null;
    };
    if (!DESCRIPTORS) {
        that.href = serializeURL.call(that);
        that.origin = getOrigin.call(that);
        that.protocol = getProtocol.call(that);
        that.username = getUsername.call(that);
        that.password = getPassword.call(that);
        that.host = getHost.call(that);
        that.hostname = getHostname.call(that);
        that.port = getPort.call(that);
        that.pathname = getPathname.call(that);
        that.search = getSearch.call(that);
        that.searchParams = getSearchParams.call(that);
        that.hash = getHash.call(that);
    }
};
var URLPrototype = URLConstructor.prototype;
var serializeURL = function() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';
    if (host !== null) {
        output += '//';
        if (includesCredentials(url)) output += username + (password ? ':' + password : '') + '@';
        output += serializeHost(host);
        if (port !== null) output += ':' + port;
    } else if (scheme == 'file') output += '//';
    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
};
var getOrigin = function() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var port = url.port;
    if (scheme == 'blob') try {
        return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
        return 'null';
    }
    if (scheme == 'file' || !isSpecial(url)) return 'null';
    return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};
var getProtocol = function() {
    return getInternalURLState(this).scheme + ':';
};
var getUsername = function() {
    return getInternalURLState(this).username;
};
var getPassword = function() {
    return getInternalURLState(this).password;
};
var getHost = function() {
    var url = getInternalURLState(this);
    var host = url.host;
    var port = url.port;
    return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
};
var getHostname = function() {
    var host = getInternalURLState(this).host;
    return host === null ? '' : serializeHost(host);
};
var getPort = function() {
    var port = getInternalURLState(this).port;
    return port === null ? '' : String(port);
};
var getPathname = function() {
    var url = getInternalURLState(this);
    var path = url.path;
    return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};
var getSearch = function() {
    var query = getInternalURLState(this).query;
    return query ? '?' + query : '';
};
var getSearchParams = function() {
    return getInternalURLState(this).searchParams;
};
var getHash = function() {
    var fragment = getInternalURLState(this).fragment;
    return fragment ? '#' + fragment : '';
};
var accessorDescriptor = function(getter, setter) {
    return {
        get: getter,
        set: setter,
        configurable: true,
        enumerable: true
    };
};
if (DESCRIPTORS) defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function(href) {
        var url = getInternalURLState(this);
        var urlString = $toString(href);
        var failure = parseURL(url, urlString);
        if (failure) throw TypeError(failure);
        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function(protocol) {
        var url = getInternalURLState(this);
        parseURL(url, $toString(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function(username) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom($toString(username));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.username = '';
        for(var i = 0; i < codePoints.length; i++)url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function(password) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom($toString(password));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.password = '';
        for(var i = 0; i < codePoints.length; i++)url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function(host) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, $toString(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function(hostname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, $toString(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function(port) {
        var url = getInternalURLState(this);
        if (cannotHaveUsernamePasswordPort(url)) return;
        port = $toString(port);
        if (port == '') url.port = null;
        else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function(pathname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        url.path = [];
        parseURL(url, $toString(pathname), PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function(search) {
        var url = getInternalURLState(this);
        search = $toString(search);
        if (search == '') url.query = null;
        else {
            if ('?' == search.charAt(0)) search = search.slice(1);
            url.query = '';
            parseURL(url, search, QUERY);
        }
        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function(hash) {
        var url = getInternalURLState(this);
        hash = $toString(hash);
        if (hash == '') {
            url.fragment = null;
            return;
        }
        if ('#' == hash.charAt(0)) hash = hash.slice(1);
        url.fragment = '';
        parseURL(url, hash, FRAGMENT);
    })
});
// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
    return serializeURL.call(this);
}, {
    enumerable: true
});
// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
    return serializeURL.call(this);
}, {
    enumerable: true
});
if (NativeURL) {
    var nativeCreateObjectURL = NativeURL.createObjectURL;
    var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
    // `URL.createObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
        return nativeCreateObjectURL.apply(NativeURL, arguments);
    });
    // `URL.revokeObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
        return nativeRevokeObjectURL.apply(NativeURL, arguments);
    });
}
setToStringTag(URLConstructor, 'URL');
$({
    global: true,
    forced: !USE_NATIVE_URL,
    sham: !DESCRIPTORS
}, {
    URL: URLConstructor
});

},{"../modules/es.string.iterator":"79oCt","../internals/export":"2mZbc","../internals/descriptors":"kuDzl","../internals/native-url":"9EjVH","../internals/global":"a4GR8","../internals/object-define-properties":"4aS77","../internals/redefine":"cwrrW","../internals/an-instance":"gTr5k","../internals/has":"aVEHj","../internals/object-assign":"5r2ci","../internals/array-from":"hkJ4P","../internals/string-multibyte":"dPnMz","../internals/string-punycode-to-ascii":"5mwWr","../internals/to-string":"k0ZQF","../internals/set-to-string-tag":"cFbSt","../modules/web.url-search-params":"dj0GL","../internals/internal-state":"ceuiK"}],"9EjVH":[function(require,module,exports) {
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = !fails(function() {
    var url = new URL('b?a=1&b=2&c=3', 'http://a');
    var searchParams = url.searchParams;
    var result = '';
    url.pathname = 'c%20d';
    searchParams.forEach(function(value, key) {
        searchParams['delete']('b');
        result += key + value;
    });
    return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://тест').host !== 'xn--e1aybc' || new URL('http://a#б').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';
});

},{"../internals/fails":"byxLb","../internals/well-known-symbol":"6sZ59","../internals/is-pure":"dlbEd"}],"5mwWr":[function(require,module,exports) {
'use strict';
// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */ var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while(counter < length){
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
            // It's a high surrogate, and there is a next character.
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value);
                counter--;
            }
        } else output.push(value);
    }
    return output;
};
/**
 * Converts a digit/integer into a basic code point.
 */ var digitToBasic = function(digit) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26);
};
/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */ var adapt = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */ // eslint-disable-next-line max-statements -- TODO
var encode = function(input) {
    var output = [];
    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);
    // Cache the length.
    var inputLength = input.length;
    // Initialize the state.
    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    var i, currentValue;
    // Handle the basic code points.
    for(i = 0; i < input.length; i++){
        currentValue = input[i];
        if (currentValue < 128) output.push(stringFromCharCode(currentValue));
    }
    var basicLength = output.length; // number of basic code points.
    var handledCPCount = basicLength; // number of code points that have been handled;
    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) output.push(delimiter);
    // Main encoding loop:
    while(handledCPCount < inputLength){
        // All non-basic code points < n have been handled already. Find the next larger one:
        var m = maxInt;
        for(i = 0; i < input.length; i++){
            currentValue = input[i];
            if (currentValue >= n && currentValue < m) m = currentValue;
        }
        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) throw RangeError(OVERFLOW_ERROR);
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for(i = 0; i < input.length; i++){
            currentValue = input[i];
            if (currentValue < n && (++delta) > maxInt) throw RangeError(OVERFLOW_ERROR);
            if (currentValue == n) {
                // Represent delta as a generalized variable-length integer.
                var q = delta;
                for(var k = base;; k += base){
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) break;
                    var qMinusT = q - t;
                    var baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                    q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join('');
};
module.exports = function(input) {
    var encoded = [];
    var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
    var i, label;
    for(i = 0; i < labels.length; i++){
        label = labels[i];
        encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
    }
    return encoded.join('.');
};

},{}],"dj0GL":[function(require,module,exports) {
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.array.iterator');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var USE_NATIVE_URL = require('../internals/native-url');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');
var anInstance = require('../internals/an-instance');
var hasOwn = require('../internals/has');
var bind = require('../internals/function-bind-context');
var classof = require('../internals/classof');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var $toString = require('../internals/to-string');
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var wellKnownSymbol = require('../internals/well-known-symbol');
var nativeFetch = getBuiltIn('fetch');
var NativeRequest = getBuiltIn('Request');
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var Headers1 = getBuiltIn('Headers');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var plus = /\+/g;
var sequences = Array(4);
var percentSequence = function(bytes) {
    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};
var percentDecode = function(sequence) {
    try {
        return decodeURIComponent(sequence);
    } catch (error) {
        return sequence;
    }
};
var deserialize = function(it) {
    var result = it.replace(plus, ' ');
    var bytes = 4;
    try {
        return decodeURIComponent(result);
    } catch (error) {
        while(bytes)result = result.replace(percentSequence(bytes--), percentDecode);
        return result;
    }
};
var find = /[!'()~]|%20/g;
var replace = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+'
};
var replacer = function(match) {
    return replace[match];
};
var serialize = function(it) {
    return encodeURIComponent(it).replace(find, replacer);
};
var parseSearchParams = function(result, query) {
    if (query) {
        var attributes = query.split('&');
        var index = 0;
        var attribute, entry;
        while(index < attributes.length){
            attribute = attributes[index++];
            if (attribute.length) {
                entry = attribute.split('=');
                result.push({
                    key: deserialize(entry.shift()),
                    value: deserialize(entry.join('='))
                });
            }
        }
    }
};
var updateSearchParams = function(query) {
    this.entries.length = 0;
    parseSearchParams(this.entries, query);
};
var validateArgumentsLength = function(passed, required) {
    if (passed < required) throw TypeError('Not enough arguments');
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
    setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        iterator: getIterator(getInternalParamsState(params).entries),
        kind: kind
    });
}, 'Iterator', function next() {
    var state = getInternalIteratorState(this);
    var kind = state.kind;
    var step = state.iterator.next();
    var entry = step.value;
    if (!step.done) step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [
        entry.key,
        entry.value
    ];
    return step;
});
// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams1() {
    anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    var init = arguments.length > 0 ? arguments[0] : undefined;
    var that = this;
    var entries = [];
    var iteratorMethod, iterator, next1, step, entryIterator, entryNext, first, second, key;
    setInternalState(that, {
        type: URL_SEARCH_PARAMS,
        entries: entries,
        updateURL: function() {
        },
        updateSearchParams: updateSearchParams
    });
    if (init !== undefined) {
        if (isObject(init)) {
            iteratorMethod = getIteratorMethod(init);
            if (typeof iteratorMethod === 'function') {
                iterator = iteratorMethod.call(init);
                next1 = iterator.next;
                while(!(step = next1.call(iterator)).done){
                    entryIterator = getIterator(anObject(step.value));
                    entryNext = entryIterator.next;
                    if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
                    entries.push({
                        key: $toString(first.value),
                        value: $toString(second.value)
                    });
                }
            } else for(key in init)if (hasOwn(init, key)) entries.push({
                key: key,
                value: $toString(init[key])
            });
        } else parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : $toString(init));
    }
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
    // `URLSearchParams.prototype.append` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-append
    append: function append(name, value) {
        validateArgumentsLength(arguments.length, 2);
        var state = getInternalParamsState(this);
        state.entries.push({
            key: $toString(name),
            value: $toString(value)
        });
        state.updateURL();
    },
    // `URLSearchParams.prototype.delete` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
    'delete': function(name) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var key = $toString(name);
        var index = 0;
        while(index < entries.length)if (entries[index].key === key) entries.splice(index, 1);
        else index++;
        state.updateURL();
    },
    // `URLSearchParams.prototype.get` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-get
    get: function get(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index = 0;
        for(; index < entries.length; index++){
            if (entries[index].key === key) return entries[index].value;
        }
        return null;
    },
    // `URLSearchParams.prototype.getAll` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
    getAll: function getAll(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var result = [];
        var index = 0;
        for(; index < entries.length; index++)if (entries[index].key === key) result.push(entries[index].value);
        return result;
    },
    // `URLSearchParams.prototype.has` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-has
    has: function has(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index = 0;
        while(index < entries.length){
            if (entries[index++].key === key) return true;
        }
        return false;
    },
    // `URLSearchParams.prototype.set` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-set
    set: function set(name, value) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var found = false;
        var key = $toString(name);
        var val = $toString(value);
        var index = 0;
        var entry;
        for(; index < entries.length; index++){
            entry = entries[index];
            if (entry.key === key) {
                if (found) entries.splice(index--, 1);
                else {
                    found = true;
                    entry.value = val;
                }
            }
        }
        if (!found) entries.push({
            key: key,
            value: val
        });
        state.updateURL();
    },
    // `URLSearchParams.prototype.sort` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
    sort: function sort() {
        var state = getInternalParamsState(this);
        var entries = state.entries;
        // Array#sort is not stable in some engines
        var slice = entries.slice();
        var entry, entriesIndex, sliceIndex;
        entries.length = 0;
        for(sliceIndex = 0; sliceIndex < slice.length; sliceIndex++){
            entry = slice[sliceIndex];
            for(entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++)if (entries[entriesIndex].key > entry.key) {
                entries.splice(entriesIndex, 0, entry);
                break;
            }
            if (entriesIndex === sliceIndex) entries.push(entry);
        }
        state.updateURL();
    },
    // `URLSearchParams.prototype.forEach` method
    forEach: function forEach(callback /* , thisArg */ ) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
        var index = 0;
        var entry;
        while(index < entries.length){
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
        }
    },
    // `URLSearchParams.prototype.keys` method
    keys: function keys() {
        return new URLSearchParamsIterator(this, 'keys');
    },
    // `URLSearchParams.prototype.values` method
    values: function values() {
        return new URLSearchParamsIterator(this, 'values');
    },
    // `URLSearchParams.prototype.entries` method
    entries: function entries() {
        return new URLSearchParamsIterator(this, 'entries');
    }
}, {
    enumerable: true
});
// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
    var entries = getInternalParamsState(this).entries;
    var result = [];
    var index = 0;
    var entry;
    while(index < entries.length){
        entry = entries[index++];
        result.push(serialize(entry.key) + '=' + serialize(entry.value));
    }
    return result.join('&');
}, {
    enumerable: true
});
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$({
    global: true,
    forced: !USE_NATIVE_URL
}, {
    URLSearchParams: URLSearchParamsConstructor
});
// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && typeof Headers1 == 'function') {
    var wrapRequestOptions = function(init) {
        if (isObject(init)) {
            var body = init.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
                headers = init.headers ? new Headers1(init.headers) : new Headers1();
                if (!headers.has('content-type')) headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                return create(init, {
                    body: createPropertyDescriptor(0, String(body)),
                    headers: createPropertyDescriptor(0, headers)
                });
            }
        }
        return init;
    };
    if (typeof nativeFetch == 'function') $({
        global: true,
        enumerable: true,
        forced: true
    }, {
        fetch: function fetch(input /* , init */ ) {
            return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {
            });
        }
    });
    if (typeof NativeRequest == 'function') {
        var RequestConstructor = function Request1(input /* , init */ ) {
            anInstance(this, RequestConstructor, 'Request');
            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {
            });
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({
            global: true,
            forced: true
        }, {
            Request: RequestConstructor
        });
    }
}
module.exports = {
    URLSearchParams: URLSearchParamsConstructor,
    getState: getInternalParamsState
};

},{"../modules/es.array.iterator":"8YPvt","../internals/export":"2mZbc","../internals/get-built-in":"hqegu","../internals/native-url":"9EjVH","../internals/redefine":"cwrrW","../internals/redefine-all":"4a8AR","../internals/set-to-string-tag":"cFbSt","../internals/create-iterator-constructor":"biz26","../internals/internal-state":"ceuiK","../internals/an-instance":"gTr5k","../internals/has":"aVEHj","../internals/function-bind-context":"1epb9","../internals/classof":"gO6DW","../internals/an-object":"9unxM","../internals/is-object":"d60Kc","../internals/to-string":"k0ZQF","../internals/object-create":"eYZeq","../internals/create-property-descriptor":"5fdHA","../internals/get-iterator":"erkff","../internals/get-iterator-method":"btrxT","../internals/well-known-symbol":"6sZ59"}],"erkff":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var getIteratorMethod = require('../internals/get-iterator-method');
module.exports = function(it) {
    var iteratorMethod = getIteratorMethod(it);
    if (typeof iteratorMethod != 'function') throw TypeError(String(it) + ' is not iterable');
    return anObject(iteratorMethod.call(it));
};

},{"../internals/an-object":"9unxM","../internals/get-iterator-method":"btrxT"}],"fBskR":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({
    target: 'URL',
    proto: true,
    enumerable: true
}, {
    toJSON: function toJSON() {
        return URL.prototype.toString.call(this);
    }
});

},{"../internals/export":"2mZbc"}],"pj5Me":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _localStorage = require("./localStorage");
var _faceApiJs = require("face-api.js");
var _uuid = require("uuid");
window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
const uploadFile = (file)=>{
    return new Promise((resolve, reject)=>{
        window.requestFileSystem(window.TEMPORARY, 1048576, function(fs) {
            fs.root.getFile(`${file.name}${_uuid.v4()}`, {
                create: true,
                exclusive: true
            }, function(fileEntry) {
                fileEntry.createWriter(function(fileWriter) {
                    fileWriter.write(file);
                    resolve(fileEntry);
                }, (e)=>console.log(e)
                );
            }, (e)=>console.log(e)
            );
        });
    });
};
const fileEntryPathToObjectUrl = async (fileEntryPath)=>{
    return URL.createObjectURL(await new Promise((resolve, reject)=>{
        window.requestFileSystem(window.TEMPORARY, 1048576, function(fs) {
            fs.root.getFile(fileEntryPath, {
                create: true,
                exclusive: false
            }, function(fileEntry) {
                fileEntry.file(resolve, reject);
            }, (e)=>console.log(e)
            );
        });
    }));
};
const uploader = (submitSelector, imagesListSelector)=>{
    const submit = document.querySelector(submitSelector);
    const imagesList = document.querySelector(imagesListSelector);
    const syncImages = ()=>{
        while(imagesList.firstChild)imagesList.removeChild(imagesList.firstChild);
        _localStorage.read().forEach(async (image)=>{
            const imageContainer = document.createElement('div');
            const label = document.createElement('input');
            const imageElement = document.createElement('img');
            //status
            const deleteLink = document.createElement('a');
            imageContainer.classList.add('image-container');
            deleteLink.classList.add('cerrar');
            imageElement.classList.add('card-img-top');
            imageContainer.id = image.id;
            deleteLink.href = '#';
            deleteLink.innerText = 'x';
            //status classlist
            imageElement.src = await fileEntryPathToObjectUrl(image.path);
            label.value = image.name;
            deleteLink.addEventListener('click', (e)=>{
                e.preventDefault();
                _localStorage.destroy(image.id);
                syncImages();
            });
            imageContainer.appendChild(deleteLink);
            imageContainer.appendChild(imageElement);
            //imageContainer.appendChild(label);
            imagesList.appendChild(imageContainer);
        });
    };
    submit.addEventListener('change', async (e)=>{
        const fileEntry = await uploadFile(e.target.files[0]);
        _localStorage.write([
            ..._localStorage.read(),
            {
                id: _uuid.v4(),
                path: fileEntry.fullPath,
                name: _uuid.v4().toString()
            }
        ]);
        syncImages();
    });
    syncImages();
};
exports.default = uploader;

},{"./localStorage":"bWBwM","face-api.js":"8MSAD","uuid":"97bbV","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bWBwM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "read", ()=>read
);
parcelHelpers.export(exports, "write", ()=>write
);
parcelHelpers.export(exports, "destroy", ()=>destroy
);
const itemName = 'imagenes';
const read = ()=>{
    const store = localStorage.getItem(itemName);
    return store ? JSON.parse(store) : [];
};
const write = (content)=>{
    localStorage.setItem(itemName, JSON.stringify(content));
};
const destroy = (id)=>{
    const tmp = [
        ...read()
    ];
    const index = tmp.findIndex((item)=>item.id === id
    );
    tmp.splice(index, 1);
    write(tmp);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"JacNc":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule') return;
        // Skip duplicate re-exports when they have the same value.
        if (key in dest && dest[key] === source[key]) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"8MSAD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "draw", ()=>_draw
);
parcelHelpers.export(exports, "utils", ()=>_utils
);
parcelHelpers.export(exports, "tf", ()=>_tfjsCore
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _draw = require("./draw");
var _utils = require("./utils");
var _index = require("./ageGenderNet/index");
parcelHelpers.exportAll(_index, exports);
var _index1 = require("./classes/index");
parcelHelpers.exportAll(_index1, exports);
var _index2 = require("./dom/index");
parcelHelpers.exportAll(_index2, exports);
var _index3 = require("./env/index");
parcelHelpers.exportAll(_index3, exports);
var _index4 = require("./faceExpressionNet/index");
parcelHelpers.exportAll(_index4, exports);
var _index5 = require("./faceLandmarkNet/index");
parcelHelpers.exportAll(_index5, exports);
var _index6 = require("./faceRecognitionNet/index");
parcelHelpers.exportAll(_index6, exports);
var _index7 = require("./factories/index");
parcelHelpers.exportAll(_index7, exports);
var _index8 = require("./globalApi/index");
parcelHelpers.exportAll(_index8, exports);
var _index9 = require("./mtcnn/index");
parcelHelpers.exportAll(_index9, exports);
var _index10 = require("./ops/index");
parcelHelpers.exportAll(_index10, exports);
var _index11 = require("./ssdMobilenetv1/index");
parcelHelpers.exportAll(_index11, exports);
var _index12 = require("./tinyFaceDetector/index");
parcelHelpers.exportAll(_index12, exports);
var _index13 = require("./tinyYolov2/index");
parcelHelpers.exportAll(_index13, exports);
var _euclideanDistance = require("./euclideanDistance");
parcelHelpers.exportAll(_euclideanDistance, exports);
var _neuralNetwork = require("./NeuralNetwork");
parcelHelpers.exportAll(_neuralNetwork, exports);
var _resizeResults = require("./resizeResults");
parcelHelpers.exportAll(_resizeResults, exports);

},{"@tensorflow/tfjs-core":"82lJf","./draw":"4NrvZ","./utils":"1iSuU","./ageGenderNet/index":"jgWeC","./classes/index":"6Yf93","./dom/index":"eQw1p","./env/index":"aqpPn","./faceExpressionNet/index":"32FcX","./faceLandmarkNet/index":"3vPhu","./faceRecognitionNet/index":"jiEYF","./factories/index":"aAWYN","./globalApi/index":"bkc93","./mtcnn/index":"2tQQl","./ops/index":"cSYle","./ssdMobilenetv1/index":"5kiyG","./tinyFaceDetector/index":"1SiVg","./tinyYolov2/index":"3qveU","./euclideanDistance":"7sP78","./NeuralNetwork":"lrDwN","./resizeResults":"7hGCC","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"82lJf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AdadeltaOptimizer", ()=>bd
);
parcelHelpers.export(exports, "AdagradOptimizer", ()=>wd
);
parcelHelpers.export(exports, "AdamOptimizer", ()=>Cd
);
parcelHelpers.export(exports, "AdamaxOptimizer", ()=>Ed
);
parcelHelpers.export(exports, "DataStorage", ()=>xo
);
parcelHelpers.export(exports, "ENV", ()=>s
);
parcelHelpers.export(exports, "Environment", ()=>o6
);
parcelHelpers.export(exports, "KernelBackend", ()=>bo
);
parcelHelpers.export(exports, "MomentumOptimizer", ()=>Id
);
parcelHelpers.export(exports, "Optimizer", ()=>xd
);
parcelHelpers.export(exports, "RMSPropOptimizer", ()=>kd
);
parcelHelpers.export(exports, "Rank", ()=>Ct
);
parcelHelpers.export(exports, "Reduction", ()=>ch
);
parcelHelpers.export(exports, "SGDOptimizer", ()=>Rd
);
parcelHelpers.export(exports, "Tensor", ()=>wt
);
parcelHelpers.export(exports, "TensorBuffer", ()=>gt
);
parcelHelpers.export(exports, "Variable", ()=>St
);
parcelHelpers.export(exports, "abs", ()=>ru
);
parcelHelpers.export(exports, "acos", ()=>ou
);
parcelHelpers.export(exports, "acosh", ()=>au
);
parcelHelpers.export(exports, "add", ()=>rc
);
parcelHelpers.export(exports, "addN", ()=>oc
);
parcelHelpers.export(exports, "addStrict", ()=>ac
);
parcelHelpers.export(exports, "all", ()=>Cl
);
parcelHelpers.export(exports, "any", ()=>El
);
parcelHelpers.export(exports, "argMax", ()=>Rl
);
parcelHelpers.export(exports, "argMin", ()=>Il
);
parcelHelpers.export(exports, "asin", ()=>iu
);
parcelHelpers.export(exports, "asinh", ()=>su
);
parcelHelpers.export(exports, "atan", ()=>uu
);
parcelHelpers.export(exports, "atan2", ()=>ic
);
parcelHelpers.export(exports, "atanh", ()=>cu
);
parcelHelpers.export(exports, "avgPool", ()=>fl
);
parcelHelpers.export(exports, "avgPool3d", ()=>vl
);
parcelHelpers.export(exports, "backend", ()=>hn
);
parcelHelpers.export(exports, "backend_util", ()=>Uo
);
parcelHelpers.export(exports, "basicLSTMCell", ()=>zl
);
parcelHelpers.export(exports, "batchNorm", ()=>ju
);
parcelHelpers.export(exports, "batchNorm2d", ()=>Xu
);
parcelHelpers.export(exports, "batchNorm3d", ()=>Yu
);
parcelHelpers.export(exports, "batchNorm4d", ()=>$u
);
parcelHelpers.export(exports, "batchNormalization", ()=>Ku
);
parcelHelpers.export(exports, "batchNormalization2d", ()=>Gu
);
parcelHelpers.export(exports, "batchNormalization3d", ()=>Hu
);
parcelHelpers.export(exports, "batchNormalization4d", ()=>qu
);
parcelHelpers.export(exports, "batchToSpaceND", ()=>vr
);
parcelHelpers.export(exports, "booleanMaskAsync", ()=>Uc
);
parcelHelpers.export(exports, "broadcastTo", ()=>mr
);
parcelHelpers.export(exports, "browser", ()=>id
);
parcelHelpers.export(exports, "buffer", ()=>dr
);
parcelHelpers.export(exports, "cast", ()=>gr
);
parcelHelpers.export(exports, "ceil", ()=>lu
);
parcelHelpers.export(exports, "clipByValue", ()=>hu
);
parcelHelpers.export(exports, "clone", ()=>yr
);
parcelHelpers.export(exports, "complex", ()=>Dn
);
parcelHelpers.export(exports, "concat", ()=>Yn
);
parcelHelpers.export(exports, "concat1d", ()=>$n
);
parcelHelpers.export(exports, "concat2d", ()=>Qn
);
parcelHelpers.export(exports, "concat3d", ()=>Jn
);
parcelHelpers.export(exports, "concat4d", ()=>Zn
);
parcelHelpers.export(exports, "conv1d", ()=>Hc
);
parcelHelpers.export(exports, "conv2d", ()=>qc
);
parcelHelpers.export(exports, "conv2dTranspose", ()=>Zc
);
parcelHelpers.export(exports, "conv3d", ()=>Kc
);
parcelHelpers.export(exports, "conv3dTranspose", ()=>tl
);
parcelHelpers.export(exports, "cos", ()=>fu
);
parcelHelpers.export(exports, "cosh", ()=>du
);
parcelHelpers.export(exports, "cumsum", ()=>xr
);
parcelHelpers.export(exports, "customGrad", ()=>vo
);
parcelHelpers.export(exports, "deprecationWarn", ()=>Xe
);
parcelHelpers.export(exports, "depthToSpace", ()=>br
);
parcelHelpers.export(exports, "depthwiseConv2d", ()=>Yc
);
parcelHelpers.export(exports, "diag", ()=>eh
);
parcelHelpers.export(exports, "disableDeprecationWarnings", ()=>je
);
parcelHelpers.export(exports, "dispose", ()=>tn
);
parcelHelpers.export(exports, "disposeVariables", ()=>Ye
);
parcelHelpers.export(exports, "div", ()=>sc
);
parcelHelpers.export(exports, "divNoNan", ()=>uc
);
parcelHelpers.export(exports, "divStrict", ()=>cc
);
parcelHelpers.export(exports, "dot", ()=>nl
);
parcelHelpers.export(exports, "dropout", ()=>nh
);
parcelHelpers.export(exports, "elu", ()=>_l
);
parcelHelpers.export(exports, "enableDebugMode", ()=>Ke
);
parcelHelpers.export(exports, "enableProdMode", ()=>qe
);
parcelHelpers.export(exports, "engine", ()=>$e
);
parcelHelpers.export(exports, "env", ()=>i15
);
parcelHelpers.export(exports, "equal", ()=>Rc
);
parcelHelpers.export(exports, "equalStrict", ()=>Ic
);
parcelHelpers.export(exports, "erf", ()=>pu
);
parcelHelpers.export(exports, "exp", ()=>vu
);
parcelHelpers.export(exports, "expandDims", ()=>wr
);
parcelHelpers.export(exports, "expm1", ()=>mu
);
parcelHelpers.export(exports, "eye", ()=>Cr
);
parcelHelpers.export(exports, "fft", ()=>Xl
);
parcelHelpers.export(exports, "fill", ()=>Hn
);
parcelHelpers.export(exports, "findBackend", ()=>un
);
parcelHelpers.export(exports, "findBackendFactory", ()=>cn
);
parcelHelpers.export(exports, "floor", ()=>gu
);
parcelHelpers.export(exports, "floorDiv", ()=>lc
);
parcelHelpers.export(exports, "frame", ()=>ih
);
parcelHelpers.export(exports, "fused", ()=>zh
);
parcelHelpers.export(exports, "gather", ()=>Lc
);
parcelHelpers.export(exports, "gatherND", ()=>th
);
parcelHelpers.export(exports, "gather_util", ()=>Xr
);
parcelHelpers.export(exports, "getBackend", ()=>an
);
parcelHelpers.export(exports, "getGradient", ()=>h
);
parcelHelpers.export(exports, "getKernel", ()=>l
);
parcelHelpers.export(exports, "getKernelsForBackend", ()=>f
);
parcelHelpers.export(exports, "grad", ()=>co
);
parcelHelpers.export(exports, "grads", ()=>lo
);
parcelHelpers.export(exports, "greater", ()=>kc
);
parcelHelpers.export(exports, "greaterEqual", ()=>Sc
);
parcelHelpers.export(exports, "greaterEqualStrict", ()=>Ac
);
parcelHelpers.export(exports, "greaterStrict", ()=>Dc
);
parcelHelpers.export(exports, "hammingWindow", ()=>ah
);
parcelHelpers.export(exports, "hannWindow", ()=>oh
);
parcelHelpers.export(exports, "ifft", ()=>Yl
);
parcelHelpers.export(exports, "imag", ()=>Nn
);
parcelHelpers.export(exports, "image", ()=>Oh
);
parcelHelpers.export(exports, "inTopKAsync", ()=>lh
);
parcelHelpers.export(exports, "io", ()=>ed
);
parcelHelpers.export(exports, "irfft", ()=>Ql
);
parcelHelpers.export(exports, "isFinite", ()=>Du
);
parcelHelpers.export(exports, "isInf", ()=>Au
);
parcelHelpers.export(exports, "isNaN", ()=>Su
);
parcelHelpers.export(exports, "keep", ()=>en
);
parcelHelpers.export(exports, "leakyRelu", ()=>Ol
);
parcelHelpers.export(exports, "less", ()=>Tc
);
parcelHelpers.export(exports, "lessEqual", ()=>Nc
);
parcelHelpers.export(exports, "lessEqualStrict", ()=>Fc
);
parcelHelpers.export(exports, "lessStrict", ()=>_c
);
parcelHelpers.export(exports, "linalg", ()=>Ih
);
parcelHelpers.export(exports, "linspace", ()=>qn
);
parcelHelpers.export(exports, "localResponseNormalization", ()=>Ul
);
parcelHelpers.export(exports, "log", ()=>yu
);
parcelHelpers.export(exports, "log1p", ()=>xu
);
parcelHelpers.export(exports, "logSigmoid", ()=>bu
);
parcelHelpers.export(exports, "logSoftmax", ()=>yo
);
parcelHelpers.export(exports, "logSumExp", ()=>kl
);
parcelHelpers.export(exports, "logicalAnd", ()=>Qu
);
parcelHelpers.export(exports, "logicalNot", ()=>Ju
);
parcelHelpers.export(exports, "logicalOr", ()=>Zu
);
parcelHelpers.export(exports, "logicalXor", ()=>tc
);
parcelHelpers.export(exports, "losses", ()=>bh
);
parcelHelpers.export(exports, "matMul", ()=>el
);
parcelHelpers.export(exports, "math", ()=>od
);
parcelHelpers.export(exports, "max", ()=>Sl
);
parcelHelpers.export(exports, "maxPool", ()=>hl
);
parcelHelpers.export(exports, "maxPool3d", ()=>pl
);
parcelHelpers.export(exports, "maximum", ()=>hc
);
parcelHelpers.export(exports, "maximumStrict", ()=>fc
);
parcelHelpers.export(exports, "mean", ()=>Al
);
parcelHelpers.export(exports, "memory", ()=>Qe
);
parcelHelpers.export(exports, "min", ()=>Dl
);
parcelHelpers.export(exports, "minimum", ()=>dc
);
parcelHelpers.export(exports, "minimumStrict", ()=>pc
);
parcelHelpers.export(exports, "mod", ()=>vc
);
parcelHelpers.export(exports, "modStrict", ()=>mc
);
parcelHelpers.export(exports, "moments", ()=>Tl
);
parcelHelpers.export(exports, "movingAverage", ()=>Hl
);
parcelHelpers.export(exports, "mul", ()=>gc
);
parcelHelpers.export(exports, "mulStrict", ()=>yc
);
parcelHelpers.export(exports, "multiRNNCell", ()=>Gl
);
parcelHelpers.export(exports, "multinomial", ()=>Er
);
parcelHelpers.export(exports, "neg", ()=>wu
);
parcelHelpers.export(exports, "nextFrame", ()=>Td
);
parcelHelpers.export(exports, "norm", ()=>Vl
);
parcelHelpers.export(exports, "notEqual", ()=>Oc
);
parcelHelpers.export(exports, "notEqualStrict", ()=>Mc
);
parcelHelpers.export(exports, "oneHot", ()=>Rr
);
parcelHelpers.export(exports, "ones", ()=>zn
);
parcelHelpers.export(exports, "onesLike", ()=>jn
);
parcelHelpers.export(exports, "op", ()=>An
);
parcelHelpers.export(exports, "outerProduct", ()=>rl
);
parcelHelpers.export(exports, "pad", ()=>Ir
);
parcelHelpers.export(exports, "pad1d", ()=>kr
);
parcelHelpers.export(exports, "pad2d", ()=>Sr
);
parcelHelpers.export(exports, "pad3d", ()=>Ar
);
parcelHelpers.export(exports, "pad4d", ()=>Dr
);
parcelHelpers.export(exports, "pool", ()=>dl
);
parcelHelpers.export(exports, "pow", ()=>xc
);
parcelHelpers.export(exports, "powStrict", ()=>bc
);
parcelHelpers.export(exports, "prelu", ()=>Ml
);
parcelHelpers.export(exports, "print", ()=>pr
);
parcelHelpers.export(exports, "prod", ()=>Fl
);
parcelHelpers.export(exports, "profile", ()=>Je
);
parcelHelpers.export(exports, "rand", ()=>Tr
);
parcelHelpers.export(exports, "randomGamma", ()=>Fr
);
parcelHelpers.export(exports, "randomNormal", ()=>Nr
);
parcelHelpers.export(exports, "randomUniform", ()=>_r
);
parcelHelpers.export(exports, "range", ()=>Kn
);
parcelHelpers.export(exports, "ready", ()=>on
);
parcelHelpers.export(exports, "real", ()=>Tn
);
parcelHelpers.export(exports, "reciprocal", ()=>Cu
);
parcelHelpers.export(exports, "registerBackend", ()=>ln
);
parcelHelpers.export(exports, "registerGradient", ()=>p2
);
parcelHelpers.export(exports, "registerKernel", ()=>d2
);
parcelHelpers.export(exports, "relu", ()=>Bl
);
parcelHelpers.export(exports, "relu6", ()=>Pl
);
parcelHelpers.export(exports, "removeBackend", ()=>sn
);
parcelHelpers.export(exports, "reshape", ()=>Or
);
parcelHelpers.export(exports, "reverse", ()=>ol
);
parcelHelpers.export(exports, "reverse1d", ()=>al
);
parcelHelpers.export(exports, "reverse2d", ()=>il
);
parcelHelpers.export(exports, "reverse3d", ()=>sl
);
parcelHelpers.export(exports, "reverse4d", ()=>ul
);
parcelHelpers.export(exports, "rfft", ()=>$l
);
parcelHelpers.export(exports, "round", ()=>Eu
);
parcelHelpers.export(exports, "rsqrt", ()=>Ru
);
parcelHelpers.export(exports, "scalar", ()=>On
);
parcelHelpers.export(exports, "scatterND", ()=>jl
);
parcelHelpers.export(exports, "scatter_util", ()=>to
);
parcelHelpers.export(exports, "selu", ()=>Ll
);
parcelHelpers.export(exports, "separableConv2d", ()=>Jc
);
parcelHelpers.export(exports, "serialization", ()=>ld
);
parcelHelpers.export(exports, "setBackend", ()=>rn
);
parcelHelpers.export(exports, "setPlatform", ()=>fn
);
parcelHelpers.export(exports, "setdiff1dAsync", ()=>Vr
);
parcelHelpers.export(exports, "sigmoid", ()=>Iu
);
parcelHelpers.export(exports, "sign", ()=>ku
);
parcelHelpers.export(exports, "signal", ()=>uh
);
parcelHelpers.export(exports, "sin", ()=>Tu
);
parcelHelpers.export(exports, "sinh", ()=>Nu
);
parcelHelpers.export(exports, "slice", ()=>ml
);
parcelHelpers.export(exports, "slice1d", ()=>gl
);
parcelHelpers.export(exports, "slice2d", ()=>yl
);
parcelHelpers.export(exports, "slice3d", ()=>xl
);
parcelHelpers.export(exports, "slice4d", ()=>bl
);
parcelHelpers.export(exports, "slice_util", ()=>uo
);
parcelHelpers.export(exports, "softmax", ()=>go
);
parcelHelpers.export(exports, "softplus", ()=>Fu
);
parcelHelpers.export(exports, "spaceToBatchND", ()=>Mr
);
parcelHelpers.export(exports, "sparseToDense", ()=>Zl
);
parcelHelpers.export(exports, "spectral", ()=>Jl
);
parcelHelpers.export(exports, "split", ()=>tr
);
parcelHelpers.export(exports, "sqrt", ()=>_u
);
parcelHelpers.export(exports, "square", ()=>tu
);
parcelHelpers.export(exports, "squaredDifference", ()=>nu
);
parcelHelpers.export(exports, "squaredDifferenceStrict", ()=>wc
);
parcelHelpers.export(exports, "squeeze", ()=>Br
);
parcelHelpers.export(exports, "stack", ()=>Pr
);
parcelHelpers.export(exports, "step", ()=>Ou
);
parcelHelpers.export(exports, "stft", ()=>sh
);
parcelHelpers.export(exports, "stridedSlice", ()=>ql
);
parcelHelpers.export(exports, "sub", ()=>Cc
);
parcelHelpers.export(exports, "subStrict", ()=>Ec
);
parcelHelpers.export(exports, "sum", ()=>Nl
);
parcelHelpers.export(exports, "sumOutType", ()=>Tt
);
parcelHelpers.export(exports, "tan", ()=>Mu
);
parcelHelpers.export(exports, "tanh", ()=>Bu
);
parcelHelpers.export(exports, "tensor", ()=>Fn
);
parcelHelpers.export(exports, "tensor1d", ()=>Mn
);
parcelHelpers.export(exports, "tensor2d", ()=>Bn
);
parcelHelpers.export(exports, "tensor3d", ()=>Pn
);
parcelHelpers.export(exports, "tensor4d", ()=>Ln
);
parcelHelpers.export(exports, "tensor5d", ()=>Wn
);
parcelHelpers.export(exports, "tensor6d", ()=>Un
);
parcelHelpers.export(exports, "tensor_util", ()=>Mt
);
parcelHelpers.export(exports, "test_util", ()=>md
);
parcelHelpers.export(exports, "tidy", ()=>Ze
);
parcelHelpers.export(exports, "tile", ()=>Lr
);
parcelHelpers.export(exports, "time", ()=>nn
);
parcelHelpers.export(exports, "topk", ()=>Kl
);
parcelHelpers.export(exports, "train", ()=>Ad
);
parcelHelpers.export(exports, "transpose", ()=>Wl
);
parcelHelpers.export(exports, "truncatedNormal", ()=>Wr
);
parcelHelpers.export(exports, "unregisterGradient", ()=>m2
);
parcelHelpers.export(exports, "unregisterKernel", ()=>v2
);
parcelHelpers.export(exports, "unsortedSegmentSum", ()=>Wc
);
parcelHelpers.export(exports, "unstack", ()=>Ur
);
parcelHelpers.export(exports, "util", ()=>st
);
parcelHelpers.export(exports, "valueAndGrad", ()=>ho
);
parcelHelpers.export(exports, "valueAndGrads", ()=>fo
);
parcelHelpers.export(exports, "variable", ()=>Vn
);
parcelHelpers.export(exports, "variableGrads", ()=>po
);
parcelHelpers.export(exports, "version_core", ()=>gd
);
parcelHelpers.export(exports, "webgl", ()=>yd
);
parcelHelpers.export(exports, "where", ()=>ec
);
parcelHelpers.export(exports, "whereAsync", ()=>nc
);
parcelHelpers.export(exports, "zeros", ()=>Gn
);
parcelHelpers.export(exports, "zerosLike", ()=>Xn
);
var process = require("process");
var global = arguments[3];
var Buffer = require("buffer").Buffer;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var t6 = function(e, n) {
    return (t6 = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(t1, e1) {
        t1.__proto__ = e1;
    } || function(t1, e1) {
        for(var n1 in e1)e1.hasOwnProperty(n1) && (t1[n1] = e1[n1]);
    })(e, n);
};
function e(e1, n) {
    function r() {
        this.constructor = e1;
    }
    t6(e1, n), e1.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r);
}
function n10(t1, e1, n1, r) {
    return new (n1 || (n1 = Promise))(function(o, a) {
        function i(t2) {
            try {
                u(r.next(t2));
            } catch (t3) {
                a(t3);
            }
        }
        function s(t2) {
            try {
                u(r.throw(t2));
            } catch (t3) {
                a(t3);
            }
        }
        function u(t2) {
            t2.done ? o(t2.value) : new n1(function(e2) {
                e2(t2.value);
            }).then(i, s);
        }
        u((r = r.apply(t1, e1 || [])).next());
    });
}
function r17(t1, e1) {
    var n1, r1, o, a, i = {
        label: 0,
        sent: function() {
            if (1 & o[0]) throw o[1];
            return o[1];
        },
        trys: [],
        ops: []
    };
    function s(a1) {
        return function(s1) {
            return (function(a2) {
                if (n1) throw new TypeError("Generator is already executing.");
                for(; i;)try {
                    if (n1 = 1, r1 && (o = 2 & a2[0] ? r1.return : a2[0] ? r1.throw || ((o = r1.return) && o.call(r1), 0) : r1.next) && !(o = o.call(r1, a2[1])).done) return o;
                    switch(r1 = 0, o && (a2 = [
                        2 & a2[0],
                        o.value
                    ]), a2[0]){
                        case 0:
                        case 1:
                            o = a2;
                            break;
                        case 4:
                            return i.label++, {
                                value: a2[1],
                                done: !1
                            };
                        case 5:
                            i.label++, r1 = a2[1], a2 = [
                                0
                            ];
                            continue;
                        case 7:
                            a2 = i.ops.pop(), i.trys.pop();
                            continue;
                        default:
                            if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a2[0] || 2 === a2[0])) {
                                i = 0;
                                continue;
                            }
                            if (3 === a2[0] && (!o || a2[1] > o[0] && a2[1] < o[3])) {
                                i.label = a2[1];
                                break;
                            }
                            if (6 === a2[0] && i.label < o[1]) {
                                i.label = o[1], o = a2;
                                break;
                            }
                            if (o && i.label < o[2]) {
                                i.label = o[2], i.ops.push(a2);
                                break;
                            }
                            o[2] && i.ops.pop(), i.trys.pop();
                            continue;
                    }
                    a2 = e1.call(t1, i);
                } catch (t2) {
                    a2 = [
                        6,
                        t2
                    ], r1 = 0;
                } finally{
                    n1 = o = 0;
                }
                if (5 & a2[0]) throw a2[1];
                return {
                    value: a2[0] ? a2[1] : void 0,
                    done: !0
                };
            })([
                a1,
                s1
            ]);
        };
    }
    return a = {
        next: s(0),
        throw: s(1),
        return: s(2)
    }, "function" == typeof Symbol && (a[Symbol.iterator] = function() {
        return this;
    }), a;
}
var o6 = function() {
    function t1(t2) {
        this.global = t2, this.flags = {
        }, this.flagRegistry = {
        }, this.urlFlags = {
        }, this.populateURLFlags();
    }
    return t1.prototype.setPlatform = function(t2, e1) {
        null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e1 + "."), this.platformName = t2, this.platform = e1;
    }, t1.prototype.registerFlag = function(t2, e1, n1) {
        if (this.flagRegistry[t2] = {
            evaluationFn: e1,
            setHook: n1
        }, null != this.urlFlags[t2]) {
            var r1 = this.urlFlags[t2];
            console.warn("Setting feature override from URL " + t2 + ": " + r1 + "."), this.set(t2, r1);
        }
    }, t1.prototype.get = function(t2) {
        return t2 in this.flags ? this.flags[t2] : (this.flags[t2] = this.evaluateFlag(t2), this.flags[t2]);
    }, t1.prototype.getNumber = function(t2) {
        return this.get(t2);
    }, t1.prototype.getBool = function(t2) {
        return this.get(t2);
    }, t1.prototype.getFlags = function() {
        return this.flags;
    }, Object.defineProperty(t1.prototype, "features", {
        get: function() {
            return this.flags;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.set = function(t2, e1) {
        if (null == this.flagRegistry[t2]) throw new Error("Cannot set flag " + t2 + " as it has not been registered.");
        this.flags[t2] = e1, null != this.flagRegistry[t2].setHook && this.flagRegistry[t2].setHook(e1);
    }, t1.prototype.evaluateFlag = function(t2) {
        if (null == this.flagRegistry[t2]) throw new Error("Cannot evaluate flag '" + t2 + "': no evaluation function found.");
        return this.flagRegistry[t2].evaluationFn();
    }, t1.prototype.setFlags = function(t2) {
        this.flags = Object.assign({
        }, t2);
    }, t1.prototype.reset = function() {
        this.flags = {
        }, this.urlFlags = {
        }, this.populateURLFlags();
    }, t1.prototype.populateURLFlags = function() {
        var t2 = this;
        if ((void 0) !== this.global && (void 0) !== this.global.location && (void 0) !== this.global.location.search) {
            var e1, n1, r2 = (e1 = this.global.location.search, n1 = {
            }, e1.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t3) {
                for(var e2 = [], r3 = 1; r3 < arguments.length; r3++)e2[r3 - 1] = arguments[r3];
                return a17(n1, e2[0], e2[1]), e2.join("=");
            }), n1);
            if ("tfjsflags" in r2) r2.tfjsflags.split(",").forEach(function(e2) {
                var n2 = e2.split(":"), r3 = n2[0], o1 = n2[1];
                t2.urlFlags[r3] = (function(t3, e3) {
                    if ("true" === (e3 = e3.toLowerCase()) || "false" === e3) return "true" === e3;
                    if ("" + +e3 === e3) return +e3;
                    throw new Error("Could not parse value flag value " + e3 + " for flag " + t3 + ".");
                })(r3, o1);
            });
        }
    }, t1;
}();
function a17(t1, e2, n2) {
    t1[decodeURIComponent(e2)] = decodeURIComponent(n2 || "");
}
function i15() {
    return s;
}
var s = null;
var u = new Map, c = new Map;
function l(t1, e2) {
    var n2 = g(t1, e2);
    return u.get(n2);
}
function h(t1) {
    return c.get(t1);
}
function f(t1) {
    for(var e2 = u.entries(), n2 = [];;){
        var r3 = e2.next(), o1 = r3.done, a1 = r3.value;
        if (o1) break;
        var i1 = a1[0], s1 = a1[1];
        i1.split("_")[0] === t1 && n2.push(s1);
    }
    return n2;
}
function d2(t1) {
    var e2 = t1.kernelName, n2 = t1.backendName, r4 = g(e2, n2);
    if (u.has(r4)) throw new Error("The kernel '" + e2 + "' for backend '" + n2 + "' is already registered");
    u.set(r4, t1);
}
function p2(t1) {
    var e2 = t1.kernelName;
    c.has(e2) && console.warn("Overriding the gradient for '" + e2 + "'"), c.set(e2, t1);
}
function v2(t1, e2) {
    var n2 = g(t1, e2);
    if (!u.has(n2)) throw new Error("The kernel '" + t1 + "' for backend '" + e2 + "' is not registered");
    u.delete(n2);
}
function m2(t1) {
    if (!c.has(t1)) throw new Error("The gradient '" + t1 + "' for backend is not registered");
    c.delete(t1);
}
function g(t1, e2) {
    return e2 + "_" + t1;
}
function y(t1) {
    for(var e2 = t1.length, n2 = 0, r4 = 0; e2 > 0;)r4 = Math.random() * e2 | 0, n2 = t1[--e2], t1[e2] = t1[r4], t1[r4] = n2;
}
function x1(t1, e2, n2) {
    return Math.max(t1, Math.min(e2, n2));
}
function b(t1) {
    return t1 % 2 == 0 ? t1 : t1 + 1;
}
function w(t1) {
    for(var e2 = 0, n2 = 0; n2 < t1.length; n2++)e2 += t1[n2];
    return e2;
}
function C(t1, e2) {
    if (!t1) throw new Error("string" == typeof e2 ? e2 : e2());
}
function E(t1, e2, n2) {
    (void 0) === n2 && (n2 = ""), C(S(t1, e2), function() {
        return n2 + " Shapes " + t1 + " and " + e2 + " must match";
    });
}
function R(t1) {
    C(null != t1, function() {
        return "The input to the tensor constructor must be a non-null value.";
    });
}
function I(t1, e2, n2) {
    if ((void 0) === e2 && (e2 = []), (void 0) === n2 && (n2 = !1), null == e2 && (e2 = []), Array.isArray(t1) || V(t1) && !n2) for(var r4 = 0; r4 < t1.length; ++r4)I(t1[r4], e2, n2);
    else e2.push(t1);
    return e2;
}
function k(t1) {
    if (0 === t1.length) return 1;
    for(var e2 = t1[0], n2 = 1; n2 < t1.length; n2++)e2 *= t1[n2];
    return e2;
}
function S(t1, e2) {
    if (t1 === e2) return !0;
    if (null == t1 || null == e2) return !1;
    if (t1.length !== e2.length) return !1;
    for(var n2 = 0; n2 < t1.length; n2++)if (t1[n2] !== e2[n2]) return !1;
    return !0;
}
function A(t1) {
    return t1 % 1 == 0;
}
function D(t1) {
    if (null != Math.tanh) return Math.tanh(t1);
    if (t1 === 1 / 0) return 1;
    if (t1 === -1 / 0) return -1;
    var e2 = Math.exp(2 * t1);
    return (e2 - 1) / (e2 + 1);
}
function T(t1) {
    var e2 = Math.ceil(Math.sqrt(t1));
    return [
        e2,
        Math.ceil(t1 / e2)
    ];
}
function N(t1, e2) {
    return e2 <= t1.length ? t1 : t1 + " ".repeat(e2 - t1.length);
}
function F(t1, e2, n2) {
    return (void 0) === e2 && (e2 = function(t2) {
        return 0;
    }), new Promise(function(r4, o2) {
        var a2 = 0, i2 = function() {
            if (t1()) r4();
            else {
                a2++;
                var s2 = e2(a2);
                null != n2 && a2 >= n2 ? o2() : setTimeout(i2, s2);
            }
        };
        i2();
    });
}
function _(t1, e2) {
    for(var n2 = 1, r4 = -1, o2 = 0; o2 < t1.length; ++o2)if (t1[o2] >= 0) n2 *= t1[o2];
    else if (-1 === t1[o2]) {
        if (-1 !== r4) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r4 + " and dim " + o2);
        r4 = o2;
    } else if (t1[o2] < 0) throw Error("Shapes can not be < 0. Found " + t1[o2] + " at dim " + o2);
    if (-1 === r4) {
        if (e2 > 0 && e2 !== n2) throw Error("Size(" + e2 + ") must match the product of shape " + t1);
        return t1;
    }
    if (0 === n2) throw Error("Cannot infer the missing size in [" + t1 + "] when there are 0 elements");
    if (e2 % n2 != 0) throw Error("The implicit shape can't be a fractional number. Got " + e2 + " / " + n2);
    var a2 = t1.slice();
    return a2[r4] = e2 / n2, a2;
}
function O(t1, e2) {
    var n2 = e2.length;
    return C((t1 = null == t1 ? e2.map(function(t2, e3) {
        return e3;
    }) : [].concat(t1)).every(function(t2) {
        return t2 >= -n2 && t2 < n2;
    }), function() {
        return "All values in axis param must be in range [-" + n2 + ", " + n2 + ") but got axis " + t1;
    }), C(t1.every(function(t2) {
        return A(t2);
    }), function() {
        return "All values in axis param must be integers but got axis " + t1;
    }), t1.map(function(t2) {
        return t2 < 0 ? n2 + t2 : t2;
    });
}
function M(t1, e2) {
    for(var n2 = [], r4 = [], o2 = null != e2 && Array.isArray(e2) && 0 === e2.length, a2 = null == e2 || o2 ? null : O(e2, t1).sort(), i2 = 0, s3 = 0; s3 < t1.length; ++s3){
        if (null != a2) {
            if (a2[i2] === s3 && 1 !== t1[s3]) throw new Error("Can't squeeze axis " + s3 + " since its dim '" + t1[s3] + "' is not 1");
            (null == a2[i2] || a2[i2] > s3) && 1 === t1[s3] && (n2.push(t1[s3]), r4.push(s3)), a2[i2] <= s3 && i2++;
        }
        1 !== t1[s3] && (n2.push(t1[s3]), r4.push(s3));
    }
    return {
        newShape: n2,
        keptDims: r4
    };
}
function B(t1, e2) {
    var n2 = null;
    if (null == t1 || "float32" === t1) n2 = new Float32Array(e2);
    else if ("int32" === t1) n2 = new Int32Array(e2);
    else {
        if ("bool" !== t1) throw new Error("Unknown data type " + t1);
        n2 = new Uint8Array(e2);
    }
    return n2;
}
function P(t1, e2) {
    var n2 = null;
    if (null == t1 || "float32" === t1) n2 = new Float32Array(e2);
    else if ("int32" === t1) n2 = new Int32Array(e2);
    else if ("bool" === t1) n2 = new Uint8Array(e2);
    else {
        if ("string" !== t1) throw new Error("Unknown data type " + t1);
        n2 = new Array(e2);
    }
    return n2;
}
function L(t1, e2) {
    for(var n2 = 0; n2 < t1.length; n2++){
        var r4 = t1[n2];
        if (isNaN(r4) || !isFinite(r4)) throw Error("A tensor of type " + e2 + " being uploaded contains " + r4 + ".");
    }
}
function W(t1) {
    return "bool" === t1 || "complex64" === t1 || "float32" === t1 || "int32" === t1 || "string" === t1;
}
function U(t1, e2) {
    return "complex64" !== e2 && ("float32" !== e2 || "complex64" === t1) && ("int32" !== e2 || "float32" === t1 || "complex64" === t1) && ("bool" !== e2 || "bool" !== t1);
}
function V(t1) {
    return t1 instanceof Float32Array || t1 instanceof Int32Array || t1 instanceof Uint8Array;
}
function z(t1) {
    if ("float32" === t1 || "int32" === t1) return 4;
    if ("complex64" === t1) return 8;
    if ("bool" === t1) return 1;
    throw new Error("Unknown dtype " + t1);
}
function G(t1) {
    if (null == t1) return 0;
    var e2 = 0;
    return t1.forEach(function(t2) {
        return e2 += t2.length;
    }), e2;
}
function H(t1) {
    return "string" == typeof t1 || t1 instanceof String;
}
function q4(t1) {
    return "boolean" == typeof t1;
}
function K(t1) {
    return "number" == typeof t1;
}
function j(t1) {
    return Array.isArray(t1) ? j(t1[0]) : t1 instanceof Float32Array ? "float32" : t1 instanceof Int32Array || t1 instanceof Uint8Array ? "int32" : K(t1) ? "float32" : H(t1) ? "string" : q4(t1) ? "bool" : "float32";
}
function X(t1) {
    return !!(t1 && t1.constructor && t1.call && t1.apply);
}
function Y(t1, e2) {
    for(var n2 = e2; n2 < t1; ++n2)if (t1 % n2 == 0) return n2;
    return t1;
}
function $(t1) {
    var e2 = t1.length;
    if (e2 < 2) return [];
    var n2 = new Array(e2 - 1);
    n2[e2 - 2] = t1[e2 - 1];
    for(var r5 = e2 - 3; r5 >= 0; --r5)n2[r5] = n2[r5 + 1] * t1[r5 + 1];
    return n2;
}
function Q(t1, e2, n2) {
    if ("string" === e2) throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(t1) && (t1 = I(t1)), n2 && L(t1, e2), (function(t2, e3) {
        return t2 instanceof Float32Array && "float32" === e3 || t2 instanceof Int32Array && "int32" === e3 || t2 instanceof Uint8Array && "bool" === e3;
    })(t1, e2)) return t1;
    if (null == e2 || "float32" === e2 || "complex64" === e2) return new Float32Array(t1);
    if ("int32" === e2) return new Int32Array(t1);
    if ("bool" === e2) {
        for(var r5 = new Uint8Array(t1.length), o2 = 0; o2 < r5.length; ++o2)0 !== Math.round(t1[o2]) && (r5[o2] = 1);
        return r5;
    }
    throw new Error("Unknown data type " + e2);
}
function J(t1, e2) {
    if (0 === t1.length) return e2[0];
    var n2 = t1.reduce(function(t2, e3) {
        return t2 * e3;
    });
    if (0 === n2) return [];
    if (n2 !== e2.length) throw new Error("[" + t1 + "] does not match the input size.");
    return (function t2(e3, n3, r6) {
        var o3 = new Array;
        if (1 === n3.length) for(var a2 = n3[0], i2 = 0; i2 < a2; i2++)o3[i2] = r6[e3 + i2];
        else {
            a2 = n3[0];
            var s3 = n3.slice(1), u1 = s3.reduce(function(t3, e4) {
                return t3 * e4;
            });
            for(i2 = 0; i2 < a2; i2++)o3[i2] = t2(e3 + i2 * u1, s3, r6);
        }
        return o3;
    })(0, t1, e2);
}
function Z(t1, e2) {
    for(var n2 = tt(t1, e2), r6 = 0; r6 < n2.length; r6++)n2[r6] = 1;
    return n2;
}
function tt(t1, e2) {
    if (null == e2 || "float32" === e2 || "complex64" === e2) return new Float32Array(t1);
    if ("int32" === e2) return new Int32Array(t1);
    if ("bool" === e2) return new Uint8Array(t1);
    throw new Error("Unknown data type " + e2);
}
function et() {
    return i15().platform.now();
}
function nt(t1) {
    t1.forEach(function(e2) {
        C(Number.isInteger(e2) && e2 >= 0, function() {
            return "Tensor must have a shape comprised of positive integers but got shape [" + t1 + "].";
        });
    });
}
function rt(t1, e2) {
    return (void 0) === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", i15().platform.encode(t1, e2);
}
function ot(t1, e2) {
    return (void 0) === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", i15().platform.decode(t1, e2);
}
function at(t1, e2, n2) {
    if (0 === e2) return 0;
    if (1 === e2) return t1[0];
    for(var r6 = t1[t1.length - 1], o3 = 0; o3 < t1.length - 1; ++o3)r6 += n2[o3] * t1[o3];
    return r6;
}
function it(t1, e2, n2) {
    if (0 === e2) return [];
    if (1 === e2) return [
        t1
    ];
    for(var r6 = new Array(e2), o3 = 0; o3 < r6.length - 1; ++o3)r6[o3] = Math.floor(t1 / n2[o3]), t1 -= r6[o3] * n2[o3];
    return r6[r6.length - 1] = t1, r6;
}
var st = Object.freeze({
    shuffle: y,
    clamp: x1,
    nearestLargerEven: b,
    sum: w,
    randUniform: function(t1, e2) {
        var n2 = Math.random();
        return e2 * n2 + (1 - n2) * t1;
    },
    distSquared: function(t1, e2) {
        for(var n2 = 0, r6 = 0; r6 < t1.length; r6++){
            var o3 = Number(t1[r6]) - Number(e2[r6]);
            n2 += o3 * o3;
        }
        return n2;
    },
    assert: C,
    assertShapesMatch: E,
    assertNonNull: R,
    flatten: I,
    sizeFromShape: k,
    isScalarShape: function(t1) {
        return 0 === t1.length;
    },
    arraysEqual: S,
    isInt: A,
    tanh: D,
    sizeToSquarishShape: T,
    createShuffledIndices: function(t1) {
        for(var e2 = new Uint32Array(t1), n2 = 0; n2 < t1; ++n2)e2[n2] = n2;
        return y(e2), e2;
    },
    rightPad: N,
    repeatedTry: F,
    inferFromImplicitShape: _,
    parseAxisParam: O,
    squeezeShape: M,
    getTypedArrayFromDType: B,
    getArrayFromDType: P,
    checkConversionForErrors: L,
    isValidDtype: W,
    hasEncodingLoss: U,
    isTypedArray: V,
    bytesPerElement: z,
    bytesFromStringArray: G,
    isString: H,
    isBoolean: q4,
    isNumber: K,
    inferDtype: j,
    isFunction: X,
    nearestDivisor: Y,
    computeStrides: $,
    toTypedArray: Q,
    toNestedArray: J,
    makeOnesTypedArray: Z,
    makeZerosTypedArray: tt,
    now: et,
    assertNonNegativeIntegerDimensions: nt,
    fetch: function(t1, e2) {
        return i15().platform.fetch(t1, e2);
    },
    encodeString: rt,
    decodeString: ot,
    locToIndex: at,
    indexToLoc: it
}), ut = function() {
    function t1(t2, e2) {
        this.backendTimer = t2, this.logger = e2, null == e2 && (this.logger = new ct);
    }
    return t1.prototype.profileKernel = function(t2, e2, n2) {
        var r6, o4 = this, a2 = this.backendTimer.time(function() {
            r6 = n2();
        });
        return r6.forEach(function(n3) {
            n3.data().then(function(r7) {
                !function(t3, e3, n4) {
                    if ("float32" !== e3) return !1;
                    for(var r8 = 0; r8 < t3.length; r8++){
                        var o5 = t3[r8];
                        if (isNaN(o5) || !isFinite(o5)) return console.warn("Found " + o5 + " in the result of '" + n4 + "'"), !0;
                    }
                }(r7, n3.dtype, t2), a2.then(function(a3) {
                    var i2 = "";
                    null != a3.getExtraProfileInfo && (i2 = a3.getExtraProfileInfo()), o4.logger.logKernelProfile(t2, n3, r7, a3.kernelMs, e2, i2);
                });
            });
        }), r6;
    }, t1;
}();
var ct = function() {
    function t1() {
    }
    return t1.prototype.logKernelProfile = function(t2, e2, n2, r6, o4, a2) {
        var i2 = "number" == typeof r6 ? N(r6 + "ms", 9) : r6.error, s4 = N(t2, 25), u2 = e2.rank, c1 = e2.size, l1 = N(e2.shape.toString(), 14), h1 = "";
        for(var f1 in o4){
            var d1 = o4[f1].shape || e2.shape, p1 = d1.length;
            h1 += f1 + ": " + p1 + "D " + (p1 > 0 ? d1 : "") + " ";
        }
        console.log("%c" + s4 + "\t%c" + i2 + "\t%c" + u2 + "D " + l1 + "\t%c" + c1 + "\t%c" + h1 + "\t%c" + a2, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }, t1;
}();
var lt = 20, ht = 3, ft = 7;
function dt(t1, e2, n2, r6) {
    var o4 = $(e2), a2 = function(t2, e3, n3, r7) {
        var o6 = k(e3), a3 = r7[r7.length - 1], i2 = new Array(a3).fill(0), s4 = e3.length, u2 = "complex64" === n3 ? mt(t2) : t2;
        if (s4 > 1) for(var c1 = 0; c1 < o6 / a3; c1++)for(var l1 = c1 * a3, h1 = 0; h1 < a3; h1++)i2[h1] = Math.max(i2[h1], pt(u2[l1 + h1], 0, n3).length);
        return i2;
    }(t1, e2, n2, o4), i2 = e2.length, s4 = function t2(e3, n3, r7, o6, a3, i3) {
        (void 0) === i3 && (i3 = !0);
        var s5 = "complex64" === r7 ? 2 : 1, u2 = n3[0], c1 = n3.length;
        if (0 === c1) return "complex64" === r7 ? [
            pt(mt(e3)[0], 0, r7)
        ] : "bool" === r7 ? [
            vt(e3[0])
        ] : [
            e3[0].toString()
        ];
        if (1 === c1) {
            if (u2 > lt) {
                var l1 = ht * s5, h1 = Array.from(e3.slice(0, l1)), f1 = Array.from(e3.slice((u2 - ht) * s5, u2 * s5));
                return "complex64" === r7 && (h1 = mt(h1), f1 = mt(f1)), [
                    "[" + h1.map(function(t3, e4) {
                        return pt(t3, a3[e4], r7);
                    }).join(", ") + ", ..., " + f1.map(function(t3, e4) {
                        return pt(t3, a3[u2 - ht + e4], r7);
                    }).join(", ") + "]"
                ];
            }
            return [
                "[" + ("complex64" === r7 ? mt(e3) : Array.from(e3)).map(function(t3, e4) {
                    return pt(t3, a3[e4], r7);
                }).join(", ") + "]"
            ];
        }
        var d2 = n3.slice(1), p2 = o6.slice(1), v1 = o6[0] * s5, m1 = [];
        if (u2 > lt) {
            for(var g1 = 0; g1 < ht; g1++){
                var y1 = (x2 = g1 * v1) + v1;
                m1.push.apply(m1, t2(e3.slice(x2, y1), d2, r7, p2, a3, !1));
            }
            m1.push("...");
            for(g1 = u2 - ht; g1 < u2; g1++){
                y1 = (x2 = g1 * v1) + v1;
                m1.push.apply(m1, t2(e3.slice(x2, y1), d2, r7, p2, a3, g1 === u2 - 1));
            }
        } else for(g1 = 0; g1 < u2; g1++){
            var x2;
            y1 = (x2 = g1 * v1) + v1;
            m1.push.apply(m1, t2(e3.slice(x2, y1), d2, r7, p2, a3, g1 === u2 - 1));
        }
        var b1 = 2 === c1 ? "," : "";
        m1[0] = "[" + m1[0] + b1;
        for(g1 = 1; g1 < m1.length - 1; g1++)m1[g1] = " " + m1[g1] + b1;
        var w1 = ",\n";
        for(g1 = 2; g1 < c1; g1++)w1 += "\n";
        return m1[m1.length - 1] = " " + m1[m1.length - 1] + "]" + (i3 ? "" : w1), m1;
    }(t1, e2, n2, o4, a2), u2 = [
        "Tensor"
    ];
    return r6 && (u2.push("  dtype: " + n2), u2.push("  rank: " + i2), u2.push("  shape: [" + e2 + "]"), u2.push("  values:")), u2.push(s4.map(function(t3) {
        return "    " + t3;
    }).join("\n")), u2.join("\n");
}
function pt(t1, e2, n2) {
    return N(Array.isArray(t1) ? parseFloat(t1[0].toFixed(ft)) + " + " + parseFloat(t1[1].toFixed(ft)) + "j" : H(t1) ? "'" + t1 + "'" : "bool" === n2 ? vt(t1) : parseFloat(t1.toFixed(ft)).toString(), e2);
}
function vt(t1) {
    return 0 === t1 ? "false" : "true";
}
function mt(t1) {
    for(var e2 = [], n2 = 0; n2 < t1.length; n2 += 2)e2.push([
        t1[n2],
        t1[n2 + 1]
    ]);
    return e2;
}
var gt = function() {
    function t1(t2, e2, n2) {
        var r6 = this;
        if (this.dtype = e2, this.shape = t2.slice(), this.size = k(t2), null != n2) {
            var o4 = n2.length;
            C(o4 === this.size, function() {
                return "Length of values '" + o4 + "' does not match the size inferred by the shape '" + r6.size + "'.";
            });
        }
        if ("complex64" === e2) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n2 || P(e2, this.size), this.strides = $(t2);
    }
    return t1.prototype.set = function(t2) {
        for(var e2 = this, n2 = [], r6 = 1; r6 < arguments.length; r6++)n2[r6 - 1] = arguments[r6];
        0 === n2.length && (n2 = [
            0
        ]), C(n2.length === this.rank, function() {
            return "The number of provided coordinates (" + n2.length + ") must match the rank (" + e2.rank + ")";
        });
        var o6 = this.locToIndex(n2);
        this.values[o6] = t2;
    }, t1.prototype.get = function() {
        for(var t2 = [], e2 = 0; e2 < arguments.length; e2++)t2[e2] = arguments[e2];
        0 === t2.length && (t2 = [
            0
        ]);
        for(var n2 = 0, r6 = 0, o6 = t2; r6 < o6.length; r6++){
            var a2 = o6[r6];
            if (a2 < 0 || a2 >= this.shape[n2]) {
                var i2 = "Requested out of range element at " + t2 + ".   Buffer shape=" + this.shape;
                throw new Error(i2);
            }
            n2++;
        }
        for(var s4 = t2[t2.length - 1], u2 = 0; u2 < t2.length - 1; ++u2)s4 += this.strides[u2] * t2[u2];
        return this.values[s4];
    }, t1.prototype.locToIndex = function(t2) {
        if (0 === this.rank) return 0;
        if (1 === this.rank) return t2[0];
        for(var e2 = t2[t2.length - 1], n2 = 0; n2 < t2.length - 1; ++n2)e2 += this.strides[n2] * t2[n2];
        return e2;
    }, t1.prototype.indexToLoc = function(t2) {
        if (0 === this.rank) return [];
        if (1 === this.rank) return [
            t2
        ];
        for(var e2 = new Array(this.shape.length), n2 = 0; n2 < e2.length - 1; ++n2)e2[n2] = Math.floor(t2 / this.strides[n2]), t2 -= e2[n2] * this.strides[n2];
        return e2[e2.length - 1] = t2, e2;
    }, Object.defineProperty(t1.prototype, "rank", {
        get: function() {
            return this.shape.length;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.toTensor = function() {
        return yt().makeTensor(this.values, this.shape, this.dtype);
    }, t1;
}(), yt = null, xt = null, bt = null;
var wt = function() {
    function t1(t2, e2, n2, r6) {
        this.kept = !1, this.isDisposedInternal = !1, this.shape = t2.slice(), this.dtype = e2 || "float32", this.size = k(t2), this.strides = $(t2), this.dataId = n2, this.id = r6, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    return t1.prototype.flatten = function() {
        return this.throwIfDisposed(), this.as1D();
    }, t1.prototype.asScalar = function() {
        return this.throwIfDisposed(), C(1 === this.size, function() {
            return "The array must have only 1 element.";
        }), this.reshape([]);
    }, t1.prototype.as1D = function() {
        return this.throwIfDisposed(), this.reshape([
            this.size
        ]);
    }, t1.prototype.as2D = function(t2, e2) {
        return this.throwIfDisposed(), this.reshape([
            t2,
            e2
        ]);
    }, t1.prototype.as3D = function(t2, e2, n2) {
        return this.throwIfDisposed(), this.reshape([
            t2,
            e2,
            n2
        ]);
    }, t1.prototype.as4D = function(t2, e2, n2, r6) {
        return this.throwIfDisposed(), this.reshape([
            t2,
            e2,
            n2,
            r6
        ]);
    }, t1.prototype.as5D = function(t2, e2, n2, r6, o6) {
        return this.throwIfDisposed(), this.reshape([
            t2,
            e2,
            n2,
            r6,
            o6
        ]);
    }, t1.prototype.asType = function(t2) {
        return this.throwIfDisposed(), xt.cast(this, t2);
    }, Object.defineProperty(t1.prototype, "rank", {
        get: function() {
            return this.shape.length;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.buffer = function() {
        return n10(this, void 0, void 0, function() {
            var t2;
            return r17(this, function(e2) {
                switch(e2.label){
                    case 0:
                        return [
                            4,
                            this.data()
                        ];
                    case 1:
                        return t2 = e2.sent(), [
                            2,
                            xt.buffer(this.shape, this.dtype, t2)
                        ];
                }
            });
        });
    }, t1.prototype.bufferSync = function() {
        return xt.buffer(this.shape, this.dtype, this.dataSync());
    }, t1.prototype.array = function() {
        return n10(this, void 0, void 0, function() {
            var t2;
            return r17(this, function(e2) {
                switch(e2.label){
                    case 0:
                        return [
                            4,
                            this.data()
                        ];
                    case 1:
                        return t2 = e2.sent(), [
                            2,
                            J(this.shape, t2)
                        ];
                }
            });
        });
    }, t1.prototype.arraySync = function() {
        return J(this.shape, this.dataSync());
    }, t1.prototype.data = function() {
        return n10(this, void 0, void 0, function() {
            var t2, e2;
            return r17(this, function(n2) {
                switch(n2.label){
                    case 0:
                        return this.throwIfDisposed(), t2 = yt().read(this.dataId), "string" !== this.dtype ? [
                            3,
                            2
                        ] : [
                            4,
                            t2
                        ];
                    case 1:
                        e2 = n2.sent();
                        try {
                            return [
                                2,
                                e2.map(function(t3) {
                                    return ot(t3);
                                })
                            ];
                        } catch (t3) {
                            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                        }
                        n2.label = 2;
                    case 2:
                        return [
                            2,
                            t2
                        ];
                }
            });
        });
    }, t1.prototype.dataSync = function() {
        this.throwIfDisposed();
        var t2 = yt().readSync(this.dataId);
        if ("string" === this.dtype) try {
            return t2.map(function(t3) {
                return ot(t3);
            });
        } catch (t3) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
        return t2;
    }, t1.prototype.bytes = function() {
        return n10(this, void 0, void 0, function() {
            var t2;
            return r17(this, function(e2) {
                switch(e2.label){
                    case 0:
                        return this.throwIfDisposed(), [
                            4,
                            yt().read(this.dataId)
                        ];
                    case 1:
                        return t2 = e2.sent(), "string" === this.dtype ? [
                            2,
                            t2
                        ] : [
                            2,
                            new Uint8Array(t2.buffer)
                        ];
                }
            });
        });
    }, t1.prototype.dispose = function() {
        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);
    }, Object.defineProperty(t1.prototype, "isDisposed", {
        get: function() {
            return this.isDisposedInternal;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.throwIfDisposed = function() {
        if (this.isDisposed) throw new Error("Tensor is disposed.");
    }, t1.prototype.toFloat = function() {
        return this.asType("float32");
    }, t1.prototype.toInt = function() {
        return this.asType("int32");
    }, t1.prototype.toBool = function() {
        return this.asType("bool");
    }, t1.prototype.print = function(t2) {
        return (void 0) === t2 && (t2 = !1), xt.print(this, t2);
    }, t1.prototype.reshape = function(t2) {
        return this.throwIfDisposed(), xt.reshape(this, t2);
    }, t1.prototype.reshapeAs = function(t2) {
        return this.throwIfDisposed(), this.reshape(t2.shape);
    }, t1.prototype.expandDims = function(t2) {
        return (void 0) === t2 && (t2 = 0), xt.expandDims(this, t2);
    }, t1.prototype.cumsum = function(t2, e2, n2) {
        return (void 0) === t2 && (t2 = 0), (void 0) === e2 && (e2 = !1), (void 0) === n2 && (n2 = !1), xt.cumsum(this, t2, e2, n2);
    }, t1.prototype.squeeze = function(t2) {
        return this.throwIfDisposed(), xt.squeeze(this, t2);
    }, t1.prototype.clone = function() {
        return this.throwIfDisposed(), xt.clone(this);
    }, t1.prototype.oneHot = function(t2, e2, n2) {
        return this.throwIfDisposed(), xt.oneHot(this, t2, e2, n2);
    }, t1.prototype.toString = function(t2) {
        return (void 0) === t2 && (t2 = !1), dt(this.dataSync(), this.shape, this.dtype, t2);
    }, t1.prototype.tile = function(t2) {
        return this.throwIfDisposed(), xt.tile(this, t2);
    }, t1.prototype.gather = function(t2, e2) {
        return (void 0) === e2 && (e2 = 0), this.throwIfDisposed(), xt.gather(this, t2, e2);
    }, t1.prototype.matMul = function(t2, e2, n2) {
        return (void 0) === e2 && (e2 = !1), (void 0) === n2 && (n2 = !1), this.throwIfDisposed(), xt.matMul(this, t2, e2, n2);
    }, t1.prototype.dot = function(t2) {
        return this.throwIfDisposed(), xt.dot(this, t2);
    }, t1.prototype.norm = function(t2, e2, n2) {
        return (void 0) === t2 && (t2 = "euclidean"), (void 0) === e2 && (e2 = null), (void 0) === n2 && (n2 = !1), this.throwIfDisposed(), xt.norm(this, t2, e2, n2);
    }, t1.prototype.slice = function(t2, e2) {
        return this.throwIfDisposed(), xt.slice(this, t2, e2);
    }, t1.prototype.reverse = function(t2) {
        return this.throwIfDisposed(), xt.reverse(this, t2);
    }, t1.prototype.concat = function(e2, n2) {
        return (void 0) === n2 && (n2 = 0), this.throwIfDisposed(), e2 instanceof t1 && (e2 = [
            e2
        ]), xt.concat([
            this
        ].concat(e2), n2);
    }, t1.prototype.split = function(t2, e2) {
        return (void 0) === e2 && (e2 = 0), this.throwIfDisposed(), xt.split(this, t2, e2);
    }, t1.prototype.stack = function(t2, e2) {
        return (void 0) === e2 && (e2 = 0), xt.stack([
            this,
            t2
        ], e2);
    }, t1.prototype.unstack = function(t2) {
        return (void 0) === t2 && (t2 = 0), xt.unstack(this, t2);
    }, t1.prototype.pad = function(t2, e2) {
        return (void 0) === e2 && (e2 = 0), xt.pad(this, t2, e2);
    }, t1.prototype.batchNormalization = function(t2, e2, n2, r6, o6) {
        return (void 0) === n2 && (n2 = 0.001), bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t2, e2, o6, r6, n2);
    }, t1.prototype.batchNorm = function(t2, e2, n2, r6, o6) {
        return (void 0) === o6 && (o6 = 0.001), this.throwIfDisposed(), xt.batchNorm(this, t2, e2, n2, r6, o6);
    }, t1.prototype.all = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.all(this, t2, e2);
    }, t1.prototype.any = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.any(this, t2, e2);
    }, t1.prototype.logSumExp = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.logSumExp(this, t2, e2);
    }, t1.prototype.sum = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.sum(this, t2, e2);
    }, t1.prototype.prod = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.prod(this, t2, e2);
    }, t1.prototype.mean = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.mean(this, t2, e2);
    }, t1.prototype.min = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.min(this, t2, e2);
    }, t1.prototype.max = function(t2, e2) {
        return (void 0) === t2 && (t2 = null), (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.max(this, t2, e2);
    }, t1.prototype.argMin = function(t2) {
        return (void 0) === t2 && (t2 = null), this.throwIfDisposed(), xt.argMin(this, t2);
    }, t1.prototype.argMax = function(t2) {
        return (void 0) === t2 && (t2 = null), this.throwIfDisposed(), xt.argMax(this, t2);
    }, t1.prototype.cast = function(t2) {
        return this.throwIfDisposed(), xt.cast(this, t2);
    }, t1.prototype.add = function(t2) {
        return this.throwIfDisposed(), xt.add(this, t2);
    }, t1.prototype.addStrict = function(t2) {
        return this.throwIfDisposed(), xt.addStrict(this, t2);
    }, t1.prototype.atan2 = function(t2) {
        return this.throwIfDisposed(), xt.atan2(this, t2);
    }, t1.prototype.sub = function(t2) {
        return this.throwIfDisposed(), xt.sub(this, t2);
    }, t1.prototype.subStrict = function(t2) {
        return this.throwIfDisposed(), xt.subStrict(this, t2);
    }, t1.prototype.pow = function(t2) {
        return this.throwIfDisposed(), xt.pow(this, t2);
    }, t1.prototype.powStrict = function(t2) {
        return this.throwIfDisposed(), xt.powStrict(this, t2);
    }, t1.prototype.mul = function(t2) {
        return this.throwIfDisposed(), xt.mul(this, t2);
    }, t1.prototype.mulStrict = function(t2) {
        return this.throwIfDisposed(), xt.mulStrict(this, t2);
    }, t1.prototype.div = function(t2) {
        return this.throwIfDisposed(), xt.div(this, t2);
    }, t1.prototype.divNoNan = function(t2) {
        return this.throwIfDisposed(), xt.divNoNan(this, t2);
    }, t1.prototype.floorDiv = function(t2) {
        return this.throwIfDisposed(), xt.floorDiv(this, t2);
    }, t1.prototype.divStrict = function(t2) {
        return this.throwIfDisposed(), xt.divStrict(this, t2);
    }, t1.prototype.minimum = function(t2) {
        return this.throwIfDisposed(), xt.minimum(this, t2);
    }, t1.prototype.minimumStrict = function(t2) {
        return this.throwIfDisposed(), xt.minimumStrict(this, t2);
    }, t1.prototype.maximum = function(t2) {
        return this.throwIfDisposed(), xt.maximum(this, t2);
    }, t1.prototype.maximumStrict = function(t2) {
        return this.throwIfDisposed(), xt.maximumStrict(this, t2);
    }, t1.prototype.mod = function(t2) {
        return this.throwIfDisposed(), xt.mod(this, t2);
    }, t1.prototype.modStrict = function(t2) {
        return this.throwIfDisposed(), xt.modStrict(this, t2);
    }, t1.prototype.squaredDifferenceStrict = function(t2) {
        return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t2);
    }, t1.prototype.transpose = function(t2) {
        return this.throwIfDisposed(), xt.transpose(this, t2);
    }, t1.prototype.notEqual = function(t2) {
        return this.throwIfDisposed(), xt.notEqual(this, t2);
    }, t1.prototype.notEqualStrict = function(t2) {
        return this.throwIfDisposed(), xt.notEqualStrict(this, t2);
    }, t1.prototype.less = function(t2) {
        return this.throwIfDisposed(), xt.less(this, t2);
    }, t1.prototype.lessStrict = function(t2) {
        return this.throwIfDisposed(), xt.lessStrict(this, t2);
    }, t1.prototype.equal = function(t2) {
        return this.throwIfDisposed(), xt.equal(this, t2);
    }, t1.prototype.equalStrict = function(t2) {
        return this.throwIfDisposed(), xt.equalStrict(this, t2);
    }, t1.prototype.lessEqual = function(t2) {
        return this.throwIfDisposed(), xt.lessEqual(this, t2);
    }, t1.prototype.lessEqualStrict = function(t2) {
        return this.throwIfDisposed(), xt.lessEqualStrict(this, t2);
    }, t1.prototype.greater = function(t2) {
        return this.throwIfDisposed(), xt.greater(this, t2);
    }, t1.prototype.greaterStrict = function(t2) {
        return this.throwIfDisposed(), xt.greaterStrict(this, t2);
    }, t1.prototype.greaterEqual = function(t2) {
        return this.throwIfDisposed(), xt.greaterEqual(this, t2);
    }, t1.prototype.greaterEqualStrict = function(t2) {
        return this.throwIfDisposed(), xt.greaterEqualStrict(this, t2);
    }, t1.prototype.logicalAnd = function(t2) {
        return this.throwIfDisposed(), xt.logicalAnd(this, t2);
    }, t1.prototype.logicalOr = function(t2) {
        return this.throwIfDisposed(), xt.logicalOr(this, t2);
    }, t1.prototype.logicalNot = function() {
        return this.throwIfDisposed(), xt.logicalNot(this);
    }, t1.prototype.logicalXor = function(t2) {
        return this.throwIfDisposed(), xt.logicalXor(this, t2);
    }, t1.prototype.where = function(t2, e2) {
        return this.throwIfDisposed(), xt.where(t2, this, e2);
    }, t1.prototype.neg = function() {
        return this.throwIfDisposed(), xt.neg(this);
    }, t1.prototype.ceil = function() {
        return this.throwIfDisposed(), xt.ceil(this);
    }, t1.prototype.floor = function() {
        return this.throwIfDisposed(), xt.floor(this);
    }, t1.prototype.sign = function() {
        return this.throwIfDisposed(), xt.sign(this);
    }, t1.prototype.isNaN = function() {
        return this.throwIfDisposed(), xt.isNaN(this);
    }, t1.prototype.isInf = function() {
        return this.throwIfDisposed(), xt.isInf(this);
    }, t1.prototype.isFinite = function() {
        return this.throwIfDisposed(), xt.isFinite(this);
    }, t1.prototype.exp = function() {
        return this.throwIfDisposed(), xt.exp(this);
    }, t1.prototype.expm1 = function() {
        return this.throwIfDisposed(), xt.expm1(this);
    }, t1.prototype.log = function() {
        return this.throwIfDisposed(), xt.log(this);
    }, t1.prototype.log1p = function() {
        return this.throwIfDisposed(), xt.log1p(this);
    }, t1.prototype.sqrt = function() {
        return this.throwIfDisposed(), xt.sqrt(this);
    }, t1.prototype.rsqrt = function() {
        return this.throwIfDisposed(), xt.rsqrt(this);
    }, t1.prototype.square = function() {
        return this.throwIfDisposed(), xt.square(this);
    }, t1.prototype.reciprocal = function() {
        return this.throwIfDisposed(), xt.reciprocal(this);
    }, t1.prototype.abs = function() {
        return this.throwIfDisposed(), xt.abs(this);
    }, t1.prototype.clipByValue = function(t2, e2) {
        return this.throwIfDisposed(), xt.clipByValue(this, t2, e2);
    }, t1.prototype.relu = function() {
        return this.throwIfDisposed(), xt.relu(this);
    }, t1.prototype.relu6 = function() {
        return this.throwIfDisposed(), xt.relu6(this);
    }, t1.prototype.elu = function() {
        return this.throwIfDisposed(), xt.elu(this);
    }, t1.prototype.selu = function() {
        return this.throwIfDisposed(), xt.selu(this);
    }, t1.prototype.leakyRelu = function(t2) {
        return (void 0) === t2 && (t2 = 0.2), this.throwIfDisposed(), xt.leakyRelu(this, t2);
    }, t1.prototype.prelu = function(t2) {
        return this.throwIfDisposed(), xt.prelu(this, t2);
    }, t1.prototype.sigmoid = function() {
        return this.throwIfDisposed(), xt.sigmoid(this);
    }, t1.prototype.logSigmoid = function() {
        return this.throwIfDisposed(), xt.logSigmoid(this);
    }, t1.prototype.softplus = function() {
        return this.throwIfDisposed(), xt.softplus(this);
    }, t1.prototype.zerosLike = function() {
        return this.throwIfDisposed(), xt.zerosLike(this);
    }, t1.prototype.onesLike = function() {
        return this.throwIfDisposed(), xt.onesLike(this);
    }, t1.prototype.sin = function() {
        return this.throwIfDisposed(), xt.sin(this);
    }, t1.prototype.cos = function() {
        return this.throwIfDisposed(), xt.cos(this);
    }, t1.prototype.tan = function() {
        return this.throwIfDisposed(), xt.tan(this);
    }, t1.prototype.asin = function() {
        return this.throwIfDisposed(), xt.asin(this);
    }, t1.prototype.acos = function() {
        return this.throwIfDisposed(), xt.acos(this);
    }, t1.prototype.atan = function() {
        return this.throwIfDisposed(), xt.atan(this);
    }, t1.prototype.sinh = function() {
        return this.throwIfDisposed(), xt.sinh(this);
    }, t1.prototype.cosh = function() {
        return this.throwIfDisposed(), xt.cosh(this);
    }, t1.prototype.tanh = function() {
        return this.throwIfDisposed(), xt.tanh(this);
    }, t1.prototype.asinh = function() {
        return this.throwIfDisposed(), xt.asinh(this);
    }, t1.prototype.acosh = function() {
        return this.throwIfDisposed(), xt.acosh(this);
    }, t1.prototype.atanh = function() {
        return this.throwIfDisposed(), xt.atanh(this);
    }, t1.prototype.erf = function() {
        return this.throwIfDisposed(), xt.erf(this);
    }, t1.prototype.round = function() {
        return this.throwIfDisposed(), xt.round(this);
    }, t1.prototype.step = function(t2) {
        return (void 0) === t2 && (t2 = 0), this.throwIfDisposed(), xt.step(this, t2);
    }, t1.prototype.softmax = function(t2) {
        return (void 0) === t2 && (t2 = -1), this.throwIfDisposed(), xt.softmax(this, t2);
    }, t1.prototype.logSoftmax = function(t2) {
        return (void 0) === t2 && (t2 = -1), this.throwIfDisposed(), xt.logSoftmax(this, t2);
    }, t1.prototype.resizeBilinear = function(t2, e2) {
        return (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t2, e2);
    }, t1.prototype.resizeNearestNeighbor = function(t2, e2) {
        return (void 0) === e2 && (e2 = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t2, e2);
    }, t1.prototype.conv1d = function(t2, e2, n2, r6, o6, a3) {
        return (void 0) === r6 && (r6 = "NWC"), (void 0) === o6 && (o6 = 1), this.throwIfDisposed(), xt.conv1d(this, t2, e2, n2, r6, o6, a3);
    }, t1.prototype.conv2d = function(t2, e2, n2, r6, o6, a3) {
        return (void 0) === r6 && (r6 = "NHWC"), (void 0) === o6 && (o6 = [
            1,
            1
        ]), this.throwIfDisposed(), xt.conv2d(this, t2, e2, n2, r6, o6, a3);
    }, t1.prototype.conv2dTranspose = function(t2, e2, n2, r6, o6) {
        return this.throwIfDisposed(), xt.conv2dTranspose(this, t2, e2, n2, r6, o6);
    }, t1.prototype.depthwiseConv2D = function(t2, e2, n2, r6, o6, a3) {
        return (void 0) === r6 && (r6 = "NHWC"), (void 0) === o6 && (o6 = [
            1,
            1
        ]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t2, e2, n2, r6, o6, a3);
    }, t1.prototype.separableConv2d = function(t2, e2, n2, r6, o6, a3) {
        return (void 0) === o6 && (o6 = [
            1,
            1
        ]), (void 0) === a3 && (a3 = "NHWC"), this.throwIfDisposed(), xt.separableConv2d(this, t2, e2, n2, r6, o6, a3);
    }, t1.prototype.avgPool = function(t2, e2, n2, r6) {
        return this.throwIfDisposed(), xt.avgPool(this, t2, e2, n2, r6);
    }, t1.prototype.maxPool = function(t2, e2, n2, r6) {
        return this.throwIfDisposed(), xt.maxPool(this, t2, e2, n2, r6);
    }, t1.prototype.localResponseNormalization = function(t2, e2, n2, r6) {
        return (void 0) === t2 && (t2 = 5), (void 0) === e2 && (e2 = 1), (void 0) === n2 && (n2 = 1), (void 0) === r6 && (r6 = 0.5), xt.localResponseNormalization(this, t2, e2, n2, r6);
    }, t1.prototype.pool = function(t2, e2, n2, r6, o6) {
        return this.throwIfDisposed(), xt.pool(this, t2, e2, n2, r6, o6);
    }, t1.prototype.variable = function(t2, e2, n2) {
        return (void 0) === t2 && (t2 = !0), this.throwIfDisposed(), yt().makeVariable(this, t2, e2, n2);
    }, t1.prototype.unsortedSegmentSum = function(t2, e2) {
        return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t2, e2);
    }, t1.prototype.batchToSpaceND = function(t2, e2) {
        return this.throwIfDisposed(), xt.batchToSpaceND(this, t2, e2);
    }, t1.prototype.spaceToBatchND = function(t2, e2) {
        return this.throwIfDisposed(), xt.spaceToBatchND(this, t2, e2);
    }, t1.prototype.topk = function(t2, e2) {
        return (void 0) === t2 && (t2 = 1), (void 0) === e2 && (e2 = !0), this.throwIfDisposed(), xt.topk(this, t2, e2);
    }, t1.prototype.stridedSlice = function(t2, e2, n2, r6, o6, a3, i3, s4) {
        return (void 0) === r6 && (r6 = 0), (void 0) === o6 && (o6 = 0), (void 0) === a3 && (a3 = 0), (void 0) === i3 && (i3 = 0), (void 0) === s4 && (s4 = 0), this.throwIfDisposed(), xt.stridedSlice(this, t2, e2, n2, r6, o6, a3, i3, s4);
    }, t1.prototype.depthToSpace = function(t2, e2) {
        return this.throwIfDisposed(), xt.depthToSpace(this, t2, e2);
    }, t1.prototype.fft = function() {
        return this.throwIfDisposed(), xt.spectral.fft(this);
    }, t1.prototype.ifft = function() {
        return this.throwIfDisposed(), xt.spectral.ifft(this);
    }, t1.prototype.rfft = function() {
        return this.throwIfDisposed(), xt.spectral.rfft(this);
    }, t1.prototype.irfft = function() {
        return this.throwIfDisposed(), xt.spectral.irfft(this);
    }, t1;
}();
Object.defineProperty(wt, Symbol.hasInstance, {
    value: function(t1) {
        return !!t1 && null != t1.dataId && null != t1.shape && null != t1.dtype;
    }
});
var Ct, Et, Rt, It, kt, St = function(t1) {
    function n2(e2, n3, r6, o6) {
        var a3 = t1.call(this, e2.shape, e2.dtype, e2.dataId, o6) || this;
        return a3.trainable = n3, a3.name = r6, a3;
    }
    return e(n2, t1), n2.prototype.assign = function(t2) {
        if (t2.dtype !== this.dtype) throw new Error("dtype of the new value (" + t2.dtype + ") and previous value (" + this.dtype + ") must match");
        if (!S(t2.shape, this.shape)) throw new Error("shape of the new value (" + t2.shape + ") and previous value (" + this.shape + ") must match");
        yt().disposeTensor(this), this.dataId = t2.dataId, yt().incRef(this, null);
    }, n2.prototype.dispose = function() {
        yt().disposeVariable(this), this.isDisposedInternal = !0;
    }, n2;
}(wt);
Object.defineProperty(St, Symbol.hasInstance, {
    value: function(t1) {
        return t1 instanceof wt && null != t1.assign && t1.assign instanceof Function;
    }
}), (function(t1) {
    t1.R0 = "R0", t1.R1 = "R1", t1.R2 = "R2", t1.R3 = "R3", t1.R4 = "R4", t1.R5 = "R5", t1.R6 = "R6";
})(Ct || (Ct = {
})), (function(t1) {
    t1.float32 = "float32", t1.int32 = "int32", t1.bool = "int32", t1.complex64 = "complex64";
})(Et || (Et = {
})), (function(t1) {
    t1.float32 = "float32", t1.int32 = "int32", t1.bool = "bool", t1.complex64 = "complex64";
})(Rt || (Rt = {
})), (function(t1) {
    t1.float32 = "float32", t1.int32 = "float32", t1.bool = "float32", t1.complex64 = "complex64";
})(It || (It = {
})), (function(t1) {
    t1.float32 = "complex64", t1.int32 = "complex64", t1.bool = "complex64", t1.complex64 = "complex64";
})(kt || (kt = {
}));
var At = {
    float32: It,
    int32: Et,
    bool: Rt,
    complex64: kt
};
function Dt(t1, e2) {
    if ("string" === t1 || "string" === e2) {
        if ("string" === t1 && "string" === e2) return "string";
        throw new Error("Can not upcast " + t1 + " with " + e2);
    }
    return At[t1][e2];
}
function Tt(t1) {
    return Dt(t1, "int32");
}
function Nt(t1, e2) {
    if (t1.dtype === e2.dtype) return [
        t1,
        e2
    ];
    var n2 = Dt(t1.dtype, e2.dtype);
    return [
        t1.cast(n2),
        e2.cast(n2)
    ];
}
function Ft(t1, e2) {
    C(t1.dtype === e2.dtype, function() {
        return "The dtypes of the first(" + t1.dtype + ") and second(" + e2.dtype + ") input must match";
    });
}
function _t(t1) {
    var e2 = [];
    return (function t2(e3, n2, r6) {
        if (null == e3) return;
        if (e3 instanceof wt) return void n2.push(e3);
        if (o7 = e3, !Array.isArray(o7) && "object" != typeof o7) return;
        var o7;
        var a3 = e3;
        for(var i3 in a3){
            var s4 = a3[i3];
            r6.has(s4) || (r6.add(s4), t2(s4, n2, r6));
        }
    })(t1, e2, new Set), e2;
}
var Ot, Mt = Object.freeze({
    makeTypesMatch: Nt,
    assertTypesMatch: Ft,
    isTensorInList: function(t1, e2) {
        return e2.some(function(e3) {
            return e3.id === t1.id;
        });
    },
    getTensorsInContainer: _t
}), Bt = function() {
    function t1() {
        this.registeredVariables = {
        }, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null
        };
    }
    return t1.prototype.dispose = function() {
        for(var t2 in this.registeredVariables)this.registeredVariables[t2].dispose();
    }, t1;
}(), Pt = function() {
    function t1(t2) {
        this.ENV = t2, this.registry = {
        }, this.registryFactory = {
        }, this.pendingBackendInitId = 0, this.state = new Bt;
    }
    return t1.prototype.ready = function() {
        return n10(this, void 0, void 0, function() {
            var t2, e2, n2;
            return r17(this, function(r6) {
                switch(r6.label){
                    case 0:
                        if (null != this.pendingBackendInit) return [
                            2,
                            this.pendingBackendInit.then(function() {
                            })
                        ];
                        if (null != this.backendInstance) return [
                            2
                        ];
                        t2 = this.getSortedBackends(), e2 = 0, r6.label = 1;
                    case 1:
                        return e2 < t2.length ? (n2 = t2[e2], [
                            4,
                            this.initializeBackend(n2).success
                        ]) : [
                            3,
                            5
                        ];
                    case 2:
                        return r6.sent() ? [
                            4,
                            this.setBackend(n2)
                        ] : [
                            3,
                            4
                        ];
                    case 3:
                        return r6.sent(), [
                            2
                        ];
                    case 4:
                        return e2++, [
                            3,
                            1
                        ];
                    case 5:
                        throw new Error("Could not initialize any backends, all backend initializations failed.");
                }
            });
        });
    }, Object.defineProperty(t1.prototype, "backend", {
        get: function() {
            if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
            if (null == this.backendInstance) {
                var t2 = this.initializeBackendsAndReturnBest(), e2 = t2.name;
                if (t2.asyncInit) throw new Error("The highest priority backend '" + e2 + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                this.setBackend(e2);
            }
            return this.backendInstance;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.backendNames = function() {
        return Object.keys(this.registryFactory);
    }, t1.prototype.findBackend = function(t3) {
        if (!(t3 in this.registry)) {
            if (!(t3 in this.registryFactory)) return null;
            if (this.initializeBackend(t3).asyncInit) return null;
        }
        return this.registry[t3];
    }, t1.prototype.findBackendFactory = function(t3) {
        return t3 in this.registryFactory ? this.registryFactory[t3].factory : null;
    }, t1.prototype.registerBackend = function(t3, e3, n2) {
        return (void 0) === n2 && (n2 = 1), t3 in this.registryFactory ? (console.warn(t3 + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t3] = {
            factory: e3,
            priority: n2
        }, !0);
    }, t1.prototype.setBackend = function(t3) {
        return n10(this, void 0, void 0, function() {
            var e3, n2, o7;
            return r17(this, function(r6) {
                switch(r6.label){
                    case 0:
                        if (null == this.registryFactory[t3]) throw new Error("Backend name '" + t3 + "' not found in registry");
                        return this.backendName = t3, null != this.registry[t3] ? [
                            3,
                            4
                        ] : (this.backendInstance = null, e3 = this.initializeBackend(t3), n2 = e3.success, e3.asyncInit ? [
                            4,
                            n2
                        ] : [
                            3,
                            2
                        ]);
                    case 1:
                        return o7 = r6.sent(), [
                            3,
                            3
                        ];
                    case 2:
                        o7 = n2, r6.label = 3;
                    case 3:
                        if (!o7) return [
                            2,
                            !1
                        ];
                        r6.label = 4;
                    case 4:
                        return this.backendInstance = this.registry[t3], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [
                            2,
                            !0
                        ];
                }
            });
        });
    }, t1.prototype.setupRegisteredKernels = function() {
        var t3 = this;
        f(this.backendName).forEach(function(e3) {
            null != e3.setupFunc && e3.setupFunc(t3.backendInstance);
        });
    }, t1.prototype.disposeRegisteredKernels = function(t3) {
        var e3 = this;
        f(t3).forEach(function(n2) {
            null != n2.disposeFunc && n2.disposeFunc(e3.registry[t3]);
        });
    }, t1.prototype.initializeBackend = function(t3) {
        var e3 = this, n2 = this.registryFactory[t3];
        if (null == n2) throw new Error("Cannot initialize backend " + t3 + ", no registration found.");
        try {
            var r6 = n2.factory();
            if (Promise.resolve(r6) === r6) {
                var o7 = ++this.pendingBackendInitId, a3 = r6.then(function(n3) {
                    return !(o7 < e3.pendingBackendInitId) && (e3.registry[t3] = n3, e3.pendingBackendInit = null, !0);
                }).catch(function(n3) {
                    return !(o7 < e3.pendingBackendInitId) && (e3.pendingBackendInit = null, console.warn("Initialization of backend " + t3 + " failed"), console.warn(n3.stack || n3.message), !1);
                });
                return this.pendingBackendInit = a3, {
                    success: a3,
                    asyncInit: !0
                };
            }
            return this.registry[t3] = r6, {
                success: !0,
                asyncInit: !1
            };
        } catch (e4) {
            return console.warn("Initialization of backend " + t3 + " failed"), console.warn(e4.stack || e4.message), {
                success: !1,
                asyncInit: !1
            };
        }
    }, t1.prototype.removeBackend = function(t3) {
        if (!(t3 in this.registryFactory)) throw new Error(t3 + " backend not found in registry");
        this.backendName === t3 && null != this.pendingBackendInit && this.pendingBackendInitId++, t3 in this.registry && (this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3]), delete this.registryFactory[t3], this.backendName === t3 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }, t1.prototype.getSortedBackends = function() {
        var t3 = this;
        if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort(function(e3, n2) {
            return t3.registryFactory[n2].priority - t3.registryFactory[e3].priority;
        });
    }, t1.prototype.initializeBackendsAndReturnBest = function() {
        for(var t3 = this.getSortedBackends(), e3 = 0; e3 < t3.length; e3++){
            var n2 = t3[e3], r6 = this.initializeBackend(n2), o8 = r6.success, a4 = r6.asyncInit;
            if (a4 || o8) return {
                name: n2,
                asyncInit: a4
            };
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
    }, t1.prototype.moveData = function(t3, e3) {
        var n3 = this.state.tensorInfo.get(e3), r7 = n3.backend, o9 = this.readSync(e3);
        r7.disposeData(e3), n3.backend = t3, t3.move(e3, o9, n3.shape, n3.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }, t1.prototype.tidy = function(t3, e3) {
        var n3, r7 = this, o9 = null;
        if (null == e3) {
            if ("function" != typeof t3) throw new Error("Please provide a function to tidy()");
            e3 = t3;
        } else {
            if ("string" != typeof t3 && !(t3 instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
            if ("function" != typeof e3) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
            o9 = t3;
        }
        return this.scopedRun(function() {
            return r7.startScope(o9);
        }, function() {
            return r7.endScope(n3);
        }, function() {
            return (n3 = e3()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n3;
        });
    }, t1.prototype.scopedRun = function(t3, e3, n3) {
        t3();
        try {
            var r7 = n3();
            return e3(), r7;
        } catch (t4) {
            throw e3(), t4;
        }
    }, t1.prototype.nextTensorId = function() {
        return t1.nextTensorId++;
    }, t1.prototype.nextVariableId = function() {
        return t1.nextVariableId++;
    }, t1.prototype.clone = function(t3) {
        var e3 = this.makeTensorFromDataId(t3.dataId, t3.shape, t3.dtype), n3 = {
            x: t3
        };
        return this.addTapeNode(this.state.activeScope.name, n3, [
            e3
        ], function(t4) {
            return {
                x: function() {
                    return t4.toFloat();
                }
            };
        }, []), e3;
    }, t1.prototype.runKernel = function(t3, e3, n3, r7, o9) {
        return this.runKernelFunc(null, e3, null, t3, n3, r7, o9);
    }, t1.prototype.shouldCheckForMemLeaks = function() {
        return this.ENV.getBool("IS_TEST");
    }, t1.prototype.checkKernelForMemLeak = function(t3, e3, n3) {
        var r7 = this.backend.numDataIds(), o9 = 0;
        n3.forEach(function(t4) {
            o9 += "complex64" === t4.dtype ? 3 : 1;
        });
        var a5 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i3 = r7 - e3 - o9 - a5;
        if (i3 > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i3 + " data ids) after running '" + t3 + "'");
    }, t1.prototype.runKernelFunc = function(t3, e3, n3, r7, o9, a5, i3) {
        var s5, u2 = this;
        (void 0) === a5 && (a5 = []), (void 0) === i3 && (i3 = []);
        var c1 = [], h2 = this.isTapeOn();
        null == r7 && (r7 = null != this.state.activeScope ? this.state.activeScope.name : "");
        var f2, d2 = function(t4) {
            h2 && (c1 = t4.map(function(t5) {
                return u2.keep(u2.clone(t5));
            }));
        }, p2 = this.state.numBytes, v1 = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
        var m1, g2 = l(r7, this.backendName);
        return f2 = null != g2 ? function() {
            var t4 = u2.backend.numDataIds();
            m1 = g2.kernelFunc({
                inputs: e3,
                attrs: o9,
                backend: u2.backend
            });
            var n4 = Array.isArray(m1) ? m1 : [
                m1
            ];
            u2.shouldCheckForMemLeaks() && u2.checkKernelForMemLeak(r7, t4, n4);
            var s6 = n4.map(function(t5) {
                var e4 = t5.dataId, n5 = t5.shape, r8 = t5.dtype;
                return u2.makeTensorFromDataId(e4, n5, r8);
            }), c2 = s6.filter(function(t5, e4) {
                return i3[e4];
            });
            return d2((a5 || []).slice().concat(c2)), s6;
        } : function() {
            var e4 = u2.backend.numDataIds();
            m1 = u2.tidy(function() {
                return t3(u2.backend, d2);
            });
            var n4 = Array.isArray(m1) ? m1 : [
                m1
            ];
            return u2.shouldCheckForMemLeaks() && u2.checkKernelForMemLeak(r7, e4, n4), n4;
        }, this.scopedRun(function() {
            return u2.state.kernelDepth++;
        }, function() {
            return u2.state.kernelDepth--;
        }, function() {
            s5 = u2.ENV.getBool("DEBUG") ? u2.profiler.profileKernel(r7, e3, function() {
                return f2();
            }) : f2();
        }), h2 && this.addTapeNode(r7, e3, s5, n3, c1), this.state.profiling && this.state.activeProfile.kernels.push({
            name: r7,
            bytesAdded: this.state.numBytes - p2,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - v1,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(e3).map(function(t4) {
                return e3[t4].shape;
            }),
            outputShapes: s5.map(function(t4) {
                return t4.shape;
            })
        }), Array.isArray(m1) ? s5 : s5[0];
    }, t1.prototype.makeTensor = function(t3, e3, n3, r7) {
        if (null == t3) throw new Error("Values passed to engine.makeTensor() are null");
        n3 = n3 || "float32", r7 = r7 || this.backend;
        var o9 = t3;
        "string" === n3 && H(t3[0]) && (o9 = t3.map(function(t4) {
            return rt(t4);
        }));
        var a5 = r7.write(o9, e3, n3), i3 = new wt(e3, n3, a5, this.nextTensorId());
        if (this.incRef(i3, r7), "string" === n3) {
            var s5 = this.state.tensorInfo.get(a5), u2 = G(o9);
            this.state.numBytes += u2 - s5.bytes, s5.bytes = u2;
        }
        return i3;
    }, t1.prototype.makeTensorFromDataId = function(t3, e3, n3, r7) {
        var o9 = new wt(e3, n3 = n3 || "float32", t3, this.nextTensorId());
        return this.incRef(o9, r7), o9;
    }, t1.prototype.makeVariable = function(t3, e3, n3, r7) {
        (void 0) === e3 && (e3 = !0), n3 = n3 || this.nextVariableId().toString(), null != r7 && r7 !== t3.dtype && (t3 = t3.asType(r7));
        var o9 = new St(t3, e3, n3, this.nextTensorId());
        if (null != this.state.registeredVariables[o9.name]) throw new Error("Variable with name " + o9.name + " was already registered");
        return this.state.registeredVariables[o9.name] = o9, this.incRef(o9, this.backend), o9;
    }, t1.prototype.incRef = function(t3, e3) {
        var n3 = this.state.tensorInfo.has(t3.dataId) ? this.state.tensorInfo.get(t3.dataId).refCount : 0;
        if (this.state.numTensors++, "string" === t3.dtype && this.state.numStringTensors++, 0 === n3) {
            this.state.numDataBuffers++;
            var r7 = 0;
            "complex64" !== t3.dtype && "string" !== t3.dtype && (r7 = t3.size * z(t3.dtype)), this.state.tensorInfo.set(t3.dataId, {
                backend: e3 || this.backend,
                dtype: t3.dtype,
                shape: t3.shape,
                bytes: r7,
                refCount: 0
            }), this.state.numBytes += r7;
        }
        this.state.tensorInfo.get(t3.dataId).refCount++, t3 instanceof St || this.track(t3);
    }, t1.prototype.disposeTensor = function(t3) {
        if (this.state.tensorInfo.has(t3.dataId)) {
            this.state.numTensors--, "string" === t3.dtype && this.state.numStringTensors--;
            var e3 = this.state.tensorInfo.get(t3.dataId);
            e3.refCount <= 1 ? ("complex64" !== t3.dtype && (this.state.numBytes -= e3.bytes), this.state.numDataBuffers--, e3.backend.disposeData(t3.dataId), this.state.tensorInfo.delete(t3.dataId)) : this.state.tensorInfo.get(t3.dataId).refCount--;
        }
    }, t1.prototype.disposeVariables = function() {
        for(var t3 in this.state.registeredVariables){
            var e4 = this.state.registeredVariables[t3];
            this.disposeVariable(e4);
        }
    }, t1.prototype.disposeVariable = function(t3) {
        this.disposeTensor(t3), null != this.state.registeredVariables[t3.name] && delete this.state.registeredVariables[t3.name];
    }, t1.prototype.memory = function() {
        var t3 = this.backend.memory();
        return t3.numTensors = this.state.numTensors, t3.numDataBuffers = this.state.numDataBuffers, t3.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t3.unreliable = !0, null == t3.reasons && (t3.reasons = []), t3.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t3;
    }, t1.prototype.profile = function(t3) {
        return n10(this, void 0, void 0, function() {
            var e5, n3;
            return r17(this, function(r8) {
                return this.state.profiling = !0, e5 = this.state.numBytes, n3 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t3(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t4) {
                    return t4.totalBytesSnapshot;
                })), this.state.activeProfile.newBytes = this.state.numBytes - e5, this.state.activeProfile.newTensors = this.state.numTensors - n3, [
                    2,
                    this.state.activeProfile
                ];
            });
        });
    }, t1.prototype.isTapeOn = function() {
        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
    }, t1.prototype.addTapeNode = function(t3, e5, n3, r8, o9) {
        var a5 = this, i3 = {
            id: this.state.nextTapeNodeId++,
            kernelName: t3,
            inputs: e5,
            outputs: n3,
            saved: o9
        }, s6 = h(t3);
        null != s6 && (r8 = s6.gradFunc), null != r8 && (i3.gradient = function(t4) {
            return t4 = t4.map(function(t5, e6) {
                if (null == t5) {
                    var r9 = n3[e6], o10 = tt(r9.size, r9.dtype);
                    return a5.makeTensor(o10, r9.shape, r9.dtype);
                }
                return t5;
            }), r8(t4.length > 1 ? t4 : t4[0], o9);
        }), this.state.activeTape.push(i3);
    }, t1.prototype.keep = function(t3) {
        return t3.kept = !0, t3;
    }, t1.prototype.startTape = function() {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
    }, t1.prototype.endTape = function() {
        this.state.gradientDepth--;
    }, t1.prototype.startScope = function(t3) {
        var e5 = {
            track: [],
            name: "unnamed scope",
            id: this.state.nextScopeId++
        };
        t3 && (e5.name = t3), this.state.scopeStack.push(e5), this.state.activeScope = e5;
    }, t1.prototype.endScope = function(t3) {
        for(var e5 = this, n3 = _t(t3), r8 = new Set(n3.map(function(t4) {
            return t4.id;
        })), o9 = 0; o9 < this.state.activeScope.track.length; o9++){
            var a5 = this.state.activeScope.track[o9];
            a5.kept || r8.has(a5.id) || a5.dispose();
        }
        var i3 = this.state.scopeStack.pop();
        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n3.forEach(function(t4) {
            t4.kept || t4.scopeId !== i3.id || e5.track(t4);
        });
    }, t1.prototype.gradients = function(t3, e5, n3, r8) {
        var o9 = this;
        if ((void 0) === r8 && (r8 = !1), C(e5.length > 0, function() {
            return "gradients() received an empty list of xs.";
        }), null != n3 && "float32" !== n3.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n3.dtype + "'");
        var a6 = this.scopedRun(function() {
            return o9.startTape();
        }, function() {
            return o9.endTape();
        }, function() {
            return o9.tidy("forward", t3);
        });
        C(a6 instanceof wt, function() {
            return "The result y returned by f() must be a tensor.";
        });
        var i3 = function(t4, e6, n4) {
            for(var r10 = {
            }, o11 = {
            }, a7 = 0; a7 < e6.length; a7++)r10[e6[a7].id] = !0;
            for(a7 = 0; a7 < t4.length; a7++){
                var i4 = (p3 = t4[a7]).inputs;
                for(var s6 in i4){
                    for(var u3 = i4[s6], c1 = !1, l2 = 0; l2 < e6.length; l2++)if (r10[u3.id]) {
                        p3.outputs.forEach(function(t5) {
                            return r10[t5.id] = !0;
                        }), c1 = !0, o11[p3.id] = !0;
                        break;
                    }
                    if (c1) break;
                }
            }
            var h2 = {
            };
            h2[n4.id] = !0;
            var f2 = {
            };
            for(a7 = t4.length - 1; a7 >= 0; a7--)for(i4 = (p3 = t4[a7]).inputs, l2 = 0; l2 < p3.outputs.length; l2++)if (h2[p3.outputs[l2].id]) {
                for(var s6 in i4)h2[i4[s6].id] = !0, f2[p3.id] = !0;
                break;
            }
            var d2 = [];
            for(a7 = 0; a7 < t4.length; a7++){
                var p3;
                if (o11[(p3 = t4[a7]).id] && f2[p3.id]) {
                    var v1 = {
                    };
                    for(var s6 in p3.inputs){
                        var m1 = p3.inputs[s6];
                        r10[m1.id] && (v1[s6] = m1);
                    }
                    var g2 = Object.assign({
                    }, p3);
                    g2.inputs = v1, g2.outputs = p3.outputs, d2.push(g2);
                }
            }
            return d2;
        }(this.state.activeTape, e5, a6);
        if (!r8 && 0 === i3.length && e5.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", function() {
            var t4, r10, s7 = {
            };
            s7[a6.id] = null == n3 ? (t4 = a6.shape, r10 = Z(k(t4), "float32"), Lt.makeTensor(r10, t4, "float32")) : n3, (function(t5, e6, n4) {
                for(var r11 = function(r12) {
                    var o11 = e6[r12], a7 = [];
                    if (o11.outputs.forEach(function(e7) {
                        var n5 = t5[e7.id];
                        null != n5 ? a7.push(n5) : a7.push(null);
                    }), null == o11.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o11.kernelName + ".");
                    var i5 = o11.gradient(a7), s8 = function(e7) {
                        if (!(e7 in i5)) throw new Error("Cannot backprop through input " + e7 + ". Available gradients found: " + Object.keys(i5) + ".");
                        var r13 = n4(function() {
                            return i5[e7]();
                        });
                        if ("float32" !== r13.dtype) throw new Error("Error in gradient for op " + o11.kernelName + ". The gradient of input " + e7 + " must have 'float32' dtype, but has '" + r13.dtype + "'");
                        var a8 = o11.inputs[e7];
                        if (!S(r13.shape, a8.shape)) throw new Error("Error in gradient for op " + o11.kernelName + ". The gradient of input '" + e7 + "' has shape '" + r13.shape + "', which does not match the shape of the input '" + a8.shape + "'");
                        if (null == t5[a8.id]) t5[a8.id] = r13;
                        else {
                            var s9 = t5[a8.id];
                            t5[a8.id] = s9.add(r13), s9.dispose();
                        }
                    };
                    for(var u4 in o11.inputs)s8(u4);
                }, o11 = e6.length - 1; o11 >= 0; o11--)r11(o11);
            })(s7, i3, function(t5) {
                return o9.tidy(t5);
            });
            var u4 = e5.map(function(t5) {
                return s7[t5.id];
            });
            return 0 === o9.state.gradientDepth && (o9.state.activeTape.forEach(function(t5) {
                for(var e6 = 0, n4 = t5.saved; e6 < n4.length; e6++)n4[e6].dispose();
            }), o9.state.activeTape = null), {
                value: a6,
                grads: u4
            };
        });
    }, t1.prototype.customGrad = function(t3) {
        var e5 = this;
        return C(X(t3), function() {
            return "The f passed in customGrad(f) must be a function.";
        }), function() {
            for(var n3, r8 = [], o9 = 0; o9 < arguments.length; o9++)r8[o9] = arguments[o9];
            C(r8.every(function(t4) {
                return t4 instanceof wt;
            }), function() {
                return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
            });
            var a6 = {
            };
            return r8.forEach(function(t4, e6) {
                a6[e6] = t4;
            }), e5.runKernelFunc(function(e6, o11) {
                return C((n3 = t3.apply(void 0, r8.concat([
                    o11
                ]))).value instanceof wt, function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
                }), C(X(n3.gradFunc), function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
                }), n3.value;
            }, a6, function(t4, e6) {
                var o11 = n3.gradFunc(t4, e6), a7 = Array.isArray(o11) ? o11 : [
                    o11
                ];
                C(a7.length === r8.length, function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
                }), C(a7.every(function(t5) {
                    return t5 instanceof wt;
                }), function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
                });
                var i3 = {
                };
                return a7.forEach(function(t5, e7) {
                    i3[e7] = function() {
                        return t5;
                    };
                }), i3;
            });
        };
    }, t1.prototype.readSync = function(t3) {
        return this.state.tensorInfo.get(t3).backend.readSync(t3);
    }, t1.prototype.read = function(t3) {
        return this.state.tensorInfo.get(t3).backend.read(t3);
    }, t1.prototype.time = function(t3) {
        return n10(this, void 0, void 0, function() {
            var e5, n3;
            return r17(this, function(r8) {
                switch(r8.label){
                    case 0:
                        return e5 = et(), [
                            4,
                            this.backend.time(t3)
                        ];
                    case 1:
                        return (n3 = r8.sent()).wallMs = et() - e5, [
                            2,
                            n3
                        ];
                }
            });
        });
    }, t1.prototype.track = function(t3) {
        return null != this.state.activeScope && (t3.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t3)), t3;
    }, Object.defineProperty(t1.prototype, "registeredVariables", {
        get: function() {
            return this.state.registeredVariables;
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.reset = function() {
        for(var t3 in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt, this.registry)this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }, t1.nextTensorId = 0, t1.nextVariableId = 0, t1;
}();
var Lt = function() {
    var t1 = function() {
        if (null == Ot) {
            var t3 = void 0;
            if ("undefined" != typeof window) t3 = window;
            else if ("undefined" != typeof global) t3 = global;
            else if ("undefined" != typeof process) t3 = process;
            else {
                if ("undefined" == typeof self) throw new Error("Could not find a global object");
                t3 = self;
            }
            Ot = t3;
        }
        return Ot;
    }();
    if (null == t1._tfengine) {
        var e5 = new o6(t1);
        t1._tfengine = new Pt(e5);
    }
    return (function(t4) {
        s = t4;
    })(t1._tfengine.ENV), yt = function() {
        return t1._tfengine;
    }, t1._tfengine;
}();
function Wt() {
    return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
var Ut = i15();
Ut.registerFlag("DEBUG", function() {
    return !1;
}, function(t1) {
    t1 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ut.registerFlag("IS_BROWSER", function() {
    return Wt();
}), Ut.registerFlag("IS_NODE", function() {
    return "undefined" != typeof process && (void 0) !== process.versions && (void 0) !== process.versions.node;
}), Ut.registerFlag("IS_CHROME", function() {
    return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ut.registerFlag("PROD", function() {
    return !1;
}), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
    return Ut.getBool("DEBUG");
}), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
    return !0;
}), Ut.registerFlag("IS_TEST", function() {
    return !1;
});
var Vt, zt, Gt, Ht = {
}, qt = {
    alpha: !1,
    antialias: !1,
    premultipliedAlpha: !1,
    preserveDrawingBuffer: !1,
    depth: !1,
    stencil: !1,
    failIfMajorPerformanceCaveat: !0
};
function Kt(t1, e6) {
    Ht[t1] = e6;
}
function jt(t1) {
    t1 in Ht || (Ht[t1] = (function(t4) {
        if (1 !== t4 && 2 !== t4) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
        var e6 = function(t5) {
            if ("undefined" != typeof OffscreenCanvas && 2 === t5) return new OffscreenCanvas(300, 150);
            if ("undefined" != typeof document) return document.createElement("canvas");
            throw new Error("Cannot create a canvas in this context");
        }(t4);
        if (e6.addEventListener("webglcontextlost", function(e7) {
            e7.preventDefault(), delete Ht[t4];
        }, !1), 1 === t4) return e6.getContext("webgl", qt) || e6.getContext("experimental-webgl", qt);
        return e6.getContext("webgl2", qt);
    })(t1));
    var e6 = Ht[t1];
    return e6.isContextLost() ? (delete Ht[t1], jt(t1)) : (e6.disable(e6.DEPTH_TEST), e6.disable(e6.STENCIL_TEST), e6.disable(e6.BLEND), e6.disable(e6.DITHER), e6.disable(e6.POLYGON_OFFSET_FILL), e6.disable(e6.SAMPLE_COVERAGE), e6.enable(e6.SCISSOR_TEST), e6.enable(e6.CULL_FACE), e6.cullFace(e6.BACK), Ht[t1]);
}
function Xt(t1, e6) {
    return [
        e6,
        t1
    ];
}
function Yt(t1) {
    var e6 = k(t1);
    return T(Math.ceil(e6 / 4));
}
function $t(t1, e6) {
    return [
        Math.max(1, Math.ceil(e6 / 2)),
        Math.max(1, Math.ceil(t1 / 2))
    ];
}
function Qt(t1, e6) {
    var n3, r8, o9, a6, s7, u4, c2, l3, h2, f2 = t1;
    return 2 === i15().getNumber("WEBGL_VERSION") ? (n3 = f2.R32F, r8 = f2.R16F, o9 = f2.RGBA16F, a6 = f2.RGBA32F, s7 = f2.RED, u4 = 4, c2 = 1, l3 = f2.HALF_FLOAT, h2 = f2.FLOAT) : (n3 = t1.RGBA, r8 = t1.RGBA, o9 = t1.RGBA, a6 = f2.RGBA, s7 = t1.RGBA, u4 = 4, c2 = 4, l3 = null != e6 ? e6.HALF_FLOAT_OES : null, h2 = t1.FLOAT), {
        internalFormatFloat: n3,
        internalFormatHalfFloat: r8,
        internalFormatPackedHalfFloat: o9,
        internalFormatPackedFloat: a6,
        textureFormatFloat: s7,
        downloadTextureFormat: t1.RGBA,
        downloadUnpackNumChannels: u4,
        defaultNumChannels: c2,
        textureTypeHalfFloat: l3,
        textureTypeFloat: h2
    };
}
function Jt(t1, e6, n3) {
    var r8 = n3();
    return e6 && (function(t4) {
        var e7 = t4.getError();
        if (e7 !== t4.NO_ERROR) throw new Error("WebGL Error: " + ne(t4, e7));
    })(t1), r8;
}
!function(t1) {
    t1[t1.DENSE = 0] = "DENSE", t1[t1.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Vt || (Vt = {
})), (function(t1) {
    t1[t1.RENDER = 0] = "RENDER", t1[t1.UPLOAD = 1] = "UPLOAD", t1[t1.PIXELS = 2] = "PIXELS", t1[t1.DOWNLOAD = 3] = "DOWNLOAD";
})(zt || (zt = {
})), (function(t1) {
    t1[t1.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t1[t1.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t1[t1.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t1[t1.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t1[t1.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
})(Gt || (Gt = {
}));
var Zt = 0.0000000596, te = 65504;
function ee(t1) {
    return !!(i15().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t1 || Zt < Math.abs(t1) && Math.abs(t1) < te);
}
function ne(t1, e6) {
    switch(e6){
        case t1.NO_ERROR:
            return "NO_ERROR";
        case t1.INVALID_ENUM:
            return "INVALID_ENUM";
        case t1.INVALID_VALUE:
            return "INVALID_VALUE";
        case t1.INVALID_OPERATION:
            return "INVALID_OPERATION";
        case t1.INVALID_FRAMEBUFFER_OPERATION:
            return "INVALID_FRAMEBUFFER_OPERATION";
        case t1.OUT_OF_MEMORY:
            return "OUT_OF_MEMORY";
        case t1.CONTEXT_LOST_WEBGL:
            return "CONTEXT_LOST_WEBGL";
        default:
            return "Unknown error code " + e6;
    }
}
function re(t1, e6, n3) {
    return ke(t1, e6, function() {
        return t1.getExtension(n3);
    }, 'Extension "' + n3 + '" not supported on this browser.');
}
function oe(t1, e6, n3) {
    var r8 = ke(t1, e6, function() {
        return t1.createShader(t1.VERTEX_SHADER);
    }, "Unable to create vertex WebGLShader.");
    if (Jt(t1, e6, function() {
        return t1.shaderSource(r8, n3);
    }), Jt(t1, e6, function() {
        return t1.compileShader(r8);
    }), !1 === t1.getShaderParameter(r8, t1.COMPILE_STATUS)) throw console.log(t1.getShaderInfoLog(r8)), new Error("Failed to compile vertex shader.");
    return r8;
}
function ae(t1, e6, n3) {
    var r8 = ke(t1, e6, function() {
        return t1.createShader(t1.FRAGMENT_SHADER);
    }, "Unable to create fragment WebGLShader.");
    if (Jt(t1, e6, function() {
        return t1.shaderSource(r8, n3);
    }), Jt(t1, e6, function() {
        return t1.compileShader(r8);
    }), !1 === t1.getShaderParameter(r8, t1.COMPILE_STATUS)) throw (function(t4, e7) {
        var n4 = ue.exec(e7);
        if (null == n4) return console.log("Couldn't parse line number in error: " + e7), void console.log(t4);
        for(var r10 = +n4[1], o9 = t4.split("\n"), a6 = o9.length.toString().length + 2, i3 = o9.map(function(t5, e8) {
            return N((e8 + 1).toString(), a6) + t5;
        }), s7 = 0, u4 = 0; u4 < i3.length; u4++)s7 = Math.max(i3[u4].length, s7);
        var c2 = i3.slice(0, r10 - 1), l3 = i3.slice(r10 - 1, r10), h2 = i3.slice(r10);
        console.log(c2.join("\n")), console.log(e7.split("\n")[0]), console.log("%c " + N(l3[0], s7), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h2.join("\n"));
    })(n3, t1.getShaderInfoLog(r8)), new Error("Failed to compile fragment shader.");
    return r8;
}
var ie, se, ue = /ERROR: [0-9]+:([0-9]+):/g;
function ce(t1, e6) {
    return ke(t1, e6, function() {
        return t1.createProgram();
    }, "Unable to create WebGLProgram.");
}
function le(t1, e6, n3) {
    if (Jt(t1, e6, function() {
        return t1.linkProgram(n3);
    }), !1 === t1.getProgramParameter(n3, t1.LINK_STATUS)) throw console.log(t1.getProgramInfoLog(n3)), new Error("Failed to link vertex and fragment shaders.");
}
function he(t1, e6, n3) {
    if (Jt(t1, e6, function() {
        return t1.validateProgram(n3);
    }), !1 === t1.getProgramParameter(n3, t1.VALIDATE_STATUS)) throw console.log(t1.getProgramInfoLog(n3)), new Error("Shader program validation failed.");
}
function fe(t1, e6, n3) {
    var r8 = ke(t1, e6, function() {
        return t1.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Jt(t1, e6, function() {
        return t1.bindBuffer(t1.ARRAY_BUFFER, r8);
    }), Jt(t1, e6, function() {
        return t1.bufferData(t1.ARRAY_BUFFER, n3, t1.STATIC_DRAW);
    }), r8;
}
function de(t1, e6, n3) {
    var r8 = ke(t1, e6, function() {
        return t1.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Jt(t1, e6, function() {
        return t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, r8);
    }), Jt(t1, e6, function() {
        return t1.bufferData(t1.ELEMENT_ARRAY_BUFFER, n3, t1.STATIC_DRAW);
    }), r8;
}
function pe(t1, e6) {
    return ke(t1, e6, function() {
        return t1.createTexture();
    }, "Unable to create WebGLTexture.");
}
function ve(t1, e6) {
    var n3 = i15().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (t1 <= 0 || e6 <= 0) {
        var r8 = "[" + t1 + "x" + e6 + "]";
        throw new Error("Requested texture size " + r8 + " is invalid.");
    }
    if (t1 > n3 || e6 > n3) {
        r8 = "[" + t1 + "x" + e6 + "]";
        throw new Error("Requested texture size " + r8 + " greater than WebGL maximum on this browser / GPU " + ("[" + n3 + "x" + n3 + "]") + ".");
    }
}
function me(t1, e6) {
    return ke(t1, e6, function() {
        return t1.createFramebuffer();
    }, "Unable to create WebGLFramebuffer.");
}
function ge(t1, e6, n3, r10, o9, a6, i3, s7) {
    var u4 = t1.getAttribLocation(n3, r10);
    return -1 !== u4 && (Jt(t1, e6, function() {
        return t1.bindBuffer(t1.ARRAY_BUFFER, o9);
    }), Jt(t1, e6, function() {
        return t1.vertexAttribPointer(u4, a6, t1.FLOAT, !1, i3, s7);
    }), Jt(t1, e6, function() {
        return t1.enableVertexAttribArray(u4);
    }), !0);
}
function ye(t1, e6, n3, r10) {
    Se(t1, r10), Jt(t1, e6, function() {
        return t1.activeTexture(t1.TEXTURE0 + r10);
    }), Jt(t1, e6, function() {
        return t1.bindTexture(t1.TEXTURE_2D, n3);
    });
}
function xe(t1, e6, n3, r10) {
    return ke(t1, e6, function() {
        return t1.getUniformLocation(n3, r10);
    }, 'uniform "' + r10 + '" not present in program.');
}
function be(t1, e6, n3) {
    return t1.getUniformLocation(e6, n3);
}
function we(t1, e6, n3, r10, o9, a6) {
    Jt(t1, e6, function() {
        return ye(t1, e6, r10, a6);
    }), Jt(t1, e6, function() {
        return t1.uniform1i(o9, a6);
    });
}
function Ce(t1, e6, n3, r10) {
    Jt(t1, e6, function() {
        return t1.bindFramebuffer(t1.FRAMEBUFFER, r10);
    }), Jt(t1, e6, function() {
        return t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, n3, 0);
    });
}
function Ee(t1, e6, n3) {
    Jt(t1, e6, function() {
        return t1.bindFramebuffer(t1.FRAMEBUFFER, n3);
    }), Jt(t1, e6, function() {
        return t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, null, 0);
    });
}
function Re(t1) {
    var e6 = t1.checkFramebufferStatus(t1.FRAMEBUFFER);
    if (e6 !== t1.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ie(t1, e6));
}
function Ie(t1, e6) {
    switch(e6){
        case t1.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        case t1.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        case t1.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        case t1.FRAMEBUFFER_UNSUPPORTED:
            return "FRAMEBUFFER_UNSUPPORTED";
        default:
            return "unknown error " + e6;
    }
}
function ke(t1, e6, n3, r10) {
    var o9 = Jt(t1, e6, function() {
        return n3();
    });
    if (null == o9) throw new Error(r10);
    return o9;
}
function Se(t1, e6) {
    var n3 = t1.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r10 = e6 + t1.TEXTURE0;
    if (r10 < t1.TEXTURE0 || r10 > n3) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n3 + "]") + ".");
}
function Ae(t1, e6) {
    return (void 0) === e6 && (e6 = 2), k(t1.slice(0, t1.length - e6));
}
function De(t1) {
    if (0 === t1.length) throw Error("Cannot get rows and columns of an empty shape array.");
    return [
        t1.length > 1 ? t1[t1.length - 2] : 1,
        t1[t1.length - 1]
    ];
}
function Te(t1) {
    var e6 = [
        1,
        1,
        1
    ];
    return 0 === t1.length || 1 === t1.length && 1 === t1[0] || (e6 = [
        Ae(t1)
    ].concat(De(t1))), e6;
}
function Ne(t1, e6) {
    var n3;
    (void 0) === e6 && (e6 = !1);
    var r10 = i15().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e6 && (r10 *= 2, 1 === (t1 = t1.map(function(e7, n4) {
        return n4 >= t1.length - 2 ? b(t1[n4]) : t1[n4];
    })).length && (t1 = [
        2,
        t1[0]
    ])), 2 !== t1.length) {
        var o9 = M(t1);
        t1 = o9.newShape;
    }
    var a6 = k(t1);
    if (t1.length <= 1 && a6 <= r10) return [
        1,
        a6
    ];
    if (2 === t1.length && t1[0] <= r10 && t1[1] <= r10) return t1;
    if (3 === t1.length && t1[0] * t1[1] <= r10 && t1[2] <= r10) return [
        t1[0] * t1[1],
        t1[2]
    ];
    if (3 === t1.length && t1[0] <= r10 && t1[1] * t1[2] <= r10) return [
        t1[0],
        t1[1] * t1[2]
    ];
    if (4 === t1.length && t1[0] * t1[1] * t1[2] <= r10 && t1[3] <= r10) return [
        t1[0] * t1[1] * t1[2],
        t1[3]
    ];
    if (4 === t1.length && t1[0] <= r10 && t1[1] * t1[2] * t1[3] <= r10) return [
        t1[0],
        t1[1] * t1[2] * t1[3]
    ];
    if (e6) {
        var s7 = Ae(t1), u4 = 2, c2 = 2;
        return t1.length && (u4 = (n3 = De(t1))[0], c2 = n3[1]), T(a6 = s7 * (u4 / 2) * (c2 / 2)).map(function(t4) {
            return 2 * t4;
        });
    }
    return T(a6);
}
function Fe(t1) {
    return t1 % 2 == 0;
}
function _e(t1, e6) {
    if (S(t1 = t1.slice(-2), e6 = e6.slice(-2))) return !0;
    if (!t1.length || !e6.length) return !0;
    if (0 === t1[0] || 0 === t1[1] || 0 === e6[0] || 0 === e6[1]) return !0;
    if (t1.length !== e6.length) {
        var n3 = t1.slice(-1)[0], r10 = e6.slice(-1)[0];
        if (n3 === r10) return !0;
        if (Fe(n3) && Fe(r10) && (1 === t1[0] || 1 === e6[0])) return !0;
    }
    return t1[1] === e6[1] && Fe(t1[0]) && Fe(e6[0]);
}
function Oe(t1) {
    if (null == ie) {
        var e6 = jt(t1);
        ie = e6.getParameter(e6.MAX_TEXTURE_SIZE);
    }
    return ie;
}
function Me(t1) {
    if (null == se) {
        var e7 = jt(t1);
        se = e7.getParameter(e7.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, se);
}
function Be(t1) {
    if (0 === t1) return 0;
    var e8 = jt(t1);
    return Pe(e8, "EXT_disjoint_timer_query_webgl2") && 2 === t1 ? 2 : Pe(e8, "EXT_disjoint_timer_query") ? 1 : 0;
}
function Pe(t1, e8) {
    return null != t1.getExtension(e8);
}
function Le(t1) {
    try {
        if (null != jt(t1)) return !0;
    } catch (t4) {
        return !1;
    }
    return !1;
}
function We(t1) {
    if (0 === t1) return !1;
    var e8 = jt(t1);
    if (1 === t1) {
        if (!Pe(e8, "OES_texture_float")) return !1;
    } else if (!Pe(e8, "EXT_color_buffer_float")) return !1;
    return Ve(e8);
}
function Ue(t1) {
    if (0 === t1) return !1;
    var e8 = jt(t1);
    if (1 !== t1) {
        if (Pe(e8, "EXT_color_buffer_float")) return Ve(e8);
        if (Pe(e8, "EXT_color_buffer_half_float")) {
            var n4 = e8.getExtension("EXT_color_buffer_half_float");
            return (function(t4, e9) {
                var n5 = Qt(t4, e9), r11 = t4.createTexture();
                t4.bindTexture(t4.TEXTURE_2D, r11);
                t4.texImage2D(t4.TEXTURE_2D, 0, n5.internalFormatHalfFloat, 1, 1, 0, n5.textureFormatFloat, n5.textureTypeHalfFloat, null);
                var o11 = t4.createFramebuffer();
                t4.bindFramebuffer(t4.FRAMEBUFFER, o11), t4.framebufferTexture2D(t4.FRAMEBUFFER, t4.COLOR_ATTACHMENT0, t4.TEXTURE_2D, r11, 0);
                var a6 = t4.checkFramebufferStatus(t4.FRAMEBUFFER) === t4.FRAMEBUFFER_COMPLETE;
                return t4.bindTexture(t4.TEXTURE_2D, null), t4.bindFramebuffer(t4.FRAMEBUFFER, null), t4.deleteTexture(r11), t4.deleteFramebuffer(o11), a6;
            })(e8, n4);
        }
        return !1;
    }
    return !!Pe(e8, "OES_texture_float") && !!Pe(e8, "WEBGL_color_buffer_float") && Ve(e8);
}
function Ve(t1) {
    var e8 = Qt(t1), n5 = t1.createTexture();
    t1.bindTexture(t1.TEXTURE_2D, n5);
    t1.texImage2D(t1.TEXTURE_2D, 0, e8.internalFormatFloat, 1, 1, 0, e8.textureFormatFloat, e8.textureTypeFloat, null);
    var r11 = t1.createFramebuffer();
    t1.bindFramebuffer(t1.FRAMEBUFFER, r11), t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, n5, 0);
    var o11 = t1.checkFramebufferStatus(t1.FRAMEBUFFER) === t1.FRAMEBUFFER_COMPLETE;
    return t1.bindTexture(t1.TEXTURE_2D, null), t1.bindFramebuffer(t1.FRAMEBUFFER, null), t1.deleteTexture(n5), t1.deleteFramebuffer(r11), o11;
}
function ze(t1) {
    return 2 === t1 && null != jt(t1).fenceSync;
}
var Ge = Object.freeze({
    callAndCheck: Jt,
    canBeRepresented: ee,
    getWebGLErrorMessage: ne,
    getExtensionOrThrow: re,
    createVertexShader: oe,
    createFragmentShader: ae,
    createProgram: ce,
    linkProgram: le,
    validateProgram: he,
    createStaticVertexBuffer: fe,
    createStaticIndexBuffer: de,
    getNumChannels: function() {
        return 2 === i15().getNumber("WEBGL_VERSION") ? 1 : 4;
    },
    createTexture: pe,
    validateTextureSize: ve,
    createFramebuffer: me,
    bindVertexBufferToProgramAttribute: ge,
    bindTextureUnit: ye,
    unbindTextureUnit: function(t1, e8, n5) {
        Se(t1, n5), Jt(t1, e8, function() {
            return t1.activeTexture(t1.TEXTURE0 + n5);
        }), Jt(t1, e8, function() {
            return t1.bindTexture(t1.TEXTURE_2D, null);
        });
    },
    getProgramUniformLocationOrThrow: xe,
    getProgramUniformLocation: be,
    bindTextureToProgramUniformSampler: we,
    bindCanvasToFramebuffer: function(t1, e8) {
        Jt(t1, e8, function() {
            return t1.bindFramebuffer(t1.FRAMEBUFFER, null);
        }), Jt(t1, e8, function() {
            return t1.viewport(0, 0, t1.canvas.width, t1.canvas.height);
        }), Jt(t1, e8, function() {
            return t1.scissor(0, 0, t1.canvas.width, t1.canvas.height);
        });
    },
    bindColorTextureToFramebuffer: Ce,
    unbindColorTextureFromFramebuffer: Ee,
    validateFramebuffer: Re,
    getFramebufferErrorMessage: Ie,
    getBatchDim: Ae,
    getRowsCols: De,
    getShapeAs3D: Te,
    getTextureShapeFromLogicalShape: Ne,
    isReshapeFree: _e,
    getWebGLMaxTextureSize: Oe,
    resetMaxTextureSize: function() {
        ie = null;
    },
    resetMaxTexturesInShader: function() {
        se = null;
    },
    getMaxTexturesInShader: Me,
    getWebGLDisjointQueryTimerVersion: Be,
    hasExtension: Pe,
    isWebGLVersionEnabled: Le,
    isCapableOfRenderingToFloatTexture: We,
    isDownloadFloatTextureEnabled: Ue,
    isWebGLFenceEnabled: ze
}), He = i15();
function qe() {
    i15().set("PROD", !0);
}
function Ke() {
    i15().set("DEBUG", !0);
}
function je() {
    i15().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function Xe(t1) {
    i15().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t1 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ye() {
    Lt.disposeVariables();
}
function $e() {
    return Lt;
}
function Qe() {
    return Lt.memory();
}
function Je(t1) {
    return Lt.profile(t1);
}
function Ze(t1, e8) {
    return Lt.tidy(t1, e8);
}
function tn(t1) {
    _t(t1).forEach(function(t4) {
        return t4.dispose();
    });
}
function en(t1) {
    return Lt.keep(t1);
}
function nn(t1) {
    return Lt.time(t1);
}
function rn(t1) {
    return Lt.setBackend(t1);
}
function on() {
    return Lt.ready();
}
function an() {
    return Lt.backendName;
}
function sn(t1) {
    Lt.removeBackend(t1);
}
function un(t1) {
    return Lt.findBackend(t1);
}
function cn(t1) {
    return Lt.findBackendFactory(t1);
}
function ln(t1, e8, n5) {
    return (void 0) === n5 && (n5 = 1), Lt.registerBackend(t1, e8, n5);
}
function hn() {
    return Lt.backend;
}
function fn(t1, e8) {
    i15().setPlatform(t1, e8);
}
function dn() {
    for(var t1 = [], e8 = 0; e8 < arguments.length; e8++)t1[e8] = arguments[e8];
    i15().getBool("IS_TEST") || console.warn.apply(console, t1);
}
function pn(t1, e8) {
    var n5 = t1;
    if (V(t1)) return "string" === e8 ? [] : [
        t1.length
    ];
    if (!Array.isArray(t1)) return [];
    for(var r11 = []; Array.isArray(n5) || V(n5) && "string" !== e8;)r11.push(n5.length), n5 = n5[0];
    return Array.isArray(t1) && i15().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && (function t4(e9, n6, r12) {
        if (r12 = r12 || [], !Array.isArray(e9) && !V(e9)) return void C(0 === n6.length, function() {
            return "Element arr[" + r12.join("][") + "] is a primitive, but should be an array/TypedArray of " + n6[0] + " elements";
        });
        C(n6.length > 0, function() {
            return "Element arr[" + r12.join("][") + "] should be a primitive, but is an array of " + e9.length + " elements";
        }), C(e9.length === n6[0], function() {
            return "Element arr[" + r12.join("][") + "] should have " + n6[0] + " elements, but has " + e9.length + " elements";
        });
        for(var o11 = n6.slice(1), a6 = 0; a6 < e9.length; ++a6)t4(e9[a6], o11, r12.concat(a6));
    })(t1, r11, []), r11;
}
function vn(t1, e8, n5, r11) {
    if (null != t1 && ("numeric" !== t1 && t1 !== e8 || "numeric" === t1 && "string" === e8)) throw new Error("Argument '" + n5 + "' passed to '" + r11 + "' must be " + t1 + " tensor, but got " + e8 + " tensor");
}
function mn(t1, e8, n5, r11) {
    if ((void 0) === r11 && (r11 = "numeric"), t1 instanceof wt) return vn(r11, t1.dtype, e8, n5), t1;
    var o11 = j(t1);
    if ("string" !== o11 && [
        "bool",
        "int32",
        "float32"
    ].indexOf(r11) >= 0 && (o11 = r11), vn(r11, o11, e8, n5), null == t1 || !V(t1) && !Array.isArray(t1) && "number" != typeof t1 && "boolean" != typeof t1 && "string" != typeof t1) {
        var a6 = null == t1 ? "null" : t1.constructor.name;
        throw new Error("Argument '" + e8 + "' passed to '" + n5 + "' must be a Tensor or TensorLike, but got '" + a6 + "'");
    }
    var s8 = pn(t1, o11);
    V(t1) || Array.isArray(t1) || (t1 = [
        t1
    ]);
    var u5 = "string" !== o11 ? Q(t1, o11, i15().getBool("DEBUG")) : I(t1, [], !0);
    return Lt.makeTensor(u5, s8, o11);
}
function gn(t1, e8, n5, r11) {
    if ((void 0) === r11 && (r11 = "numeric"), !Array.isArray(t1)) throw new Error("Argument " + e8 + " passed to " + n5 + " must be a `Tensor[]` or `TensorLike[]`");
    return t1.map(function(t4, r12) {
        return mn(t4, e8 + "[" + r12 + "]", n5);
    }, r11);
}
function yn(t1, e8) {
    for(var n5 = 0; n5 < t1.length; ++n5)if (t1[t1.length - n5 - 1] !== e8 - 1 - n5) return !1;
    return !0;
}
function xn(t1, e8, n5) {
    for(var r11 = t1.length + e8.length, o11 = [], a7 = 0, i3 = 0, s8 = 0; s8 < r11; s8++)-1 === n5.indexOf(s8) ? o11.push(t1[a7++]) : o11.push(e8[i3++]);
    return o11;
}
function bn(t1, e8) {
    for(var n5 = [], r11 = t1.length, o11 = 0; o11 < r11; o11++)-1 === e8.indexOf(o11) && n5.push(t1[o11]);
    return [
        n5,
        e8.map(function(e9) {
            return t1[e9];
        })
    ];
}
function wn(t1, e8) {
    return xn(t1, e8.map(function(t4) {
        return 1;
    }), e8);
}
function Cn(t1, e8, n5) {
    C(yn(e8, n5), function() {
        return t1 + " supports only inner-most axes for now. Got axes " + e8 + " and rank-" + n5 + " input.";
    });
}
function En(t1, e8) {
    if (yn(t1, e8)) return null;
    for(var n5 = [], r11 = 0; r11 < e8; ++r11)-1 === t1.indexOf(r11) && n5.push(r11);
    return t1.forEach(function(t4) {
        return n5.push(t4);
    }), n5;
}
function Rn(t1) {
    return t1.map(function(t4, e8) {
        return [
            e8,
            t4
        ];
    }).sort(function(t4, e8) {
        return t4[1] - e8[1];
    }).map(function(t4) {
        return t4[0];
    });
}
function In(t1, e8) {
    for(var n5 = [], r11 = e8 - t1; r11 < e8; ++r11)n5.push(r11);
    return n5;
}
function kn(t1, e8) {
    var n5 = t1[0].length;
    t1.forEach(function(t4, e9) {
        C(t4.length === n5, function() {
            return "Error in concat" + n5 + "D: rank of tensors[" + e9 + "] must be the same as the rank of the rest (" + n5 + ")";
        });
    }), C(e8 >= 0 && e8 < n5, function() {
        return "Error in concat" + n5 + "D: axis must be between 0 and " + (n5 - 1) + ".";
    });
    var r11 = t1[0];
    t1.forEach(function(t4, o11) {
        for(var a7 = 0; a7 < n5; a7++)C(a7 === e8 || t4[a7] === r11[a7], function() {
            return "Error in concat" + n5 + "D: Shape of tensors[" + o11 + "] (" + t4 + ") does not match the shape of the rest (" + r11 + ") along the non-concatenated axis " + o11 + ".";
        });
    });
}
function Sn(t1, e8) {
    for(var n5 = t1[0].slice(), r11 = 1; r11 < t1.length; r11++)n5[e8] += t1[r11][e8];
    return n5;
}
function An(t1) {
    var e8 = Object.keys(t1);
    if (1 !== e8.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e8.length + " keys.");
    var n5 = e8[0], r11 = t1[n5];
    n5.endsWith("_") && (n5 = n5.substring(0, n5.length - 1));
    var o11 = function() {
        for(var t4 = [], e9 = 0; e9 < arguments.length; e9++)t4[e9] = arguments[e9];
        Lt.startScope(n5);
        try {
            var o12 = r11.apply(void 0, t4);
            return o12 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Lt.endScope(o12), o12;
        } catch (t5) {
            throw Lt.endScope(null), t5;
        }
    };
    return Object.defineProperty(o11, "name", {
        value: n5,
        configurable: !0
    }), o11;
}
He.registerFlag("HAS_WEBGL", function() {
    return He.getNumber("WEBGL_VERSION") > 0;
}), He.registerFlag("WEBGL_VERSION", function() {
    return Le(2) ? 2 : Le(1) ? 1 : 0;
}), He.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
    return 2 === He.get("WEBGL_VERSION");
}), He.registerFlag("WEBGL_CPU_FORWARD", function() {
    return !0;
}), He.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
    return !1;
}), He.registerFlag("WEBGL_PACK", function() {
    return He.getBool("HAS_WEBGL");
}), He.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_CLIP", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
    return !1;
}), He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_REDUCE", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_LAZILY_UNPACK", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_CONV_IM2COL", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
    return Oe(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
    return Me(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
    var t1 = He.getNumber("WEBGL_VERSION");
    return 0 === t1 ? 0 : Be(t1);
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
    var t1;
    return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t1 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t1) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t1.substr(0, 4))));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
    return We(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
    return !He.getBool("WEBGL_FORCE_F16_TEXTURES") && He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
    return Ue(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
    return ze(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
    return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), bt = Xe;
var Dn = An({
    complex_: function(t1, e8) {
        var n5 = mn(t1, "real", "complex"), r11 = mn(e8, "imag", "complex");
        return E(n5.shape, r11.shape, "real and imag shapes, " + n5.shape + " and " + r11.shape + ", must match in call to tf.complex()."), Lt.runKernelFunc(function(t4) {
            return t4.complex(n5, r11);
        }, {
            $real: n5,
            $imag: r11
        });
    }
}), Tn = An({
    real_: function(t1) {
        var e8 = mn(t1, "input", "real");
        return Lt.runKernelFunc(function(t4) {
            return t4.real(e8);
        }, {
            $input: e8
        });
    }
}), Nn = An({
    imag_: function(t1) {
        var e8 = mn(t1, "input", "imag");
        return Lt.runKernelFunc(function(t4) {
            return t4.imag(e8);
        }, {
            $input: e8
        });
    }
});
function Fn(t1, e8, n5) {
    return _n(t1, e8, pn(t1, n5), n5);
}
function _n(t1, e8, n5, r11) {
    if (null == r11 && (r11 = j(t1)), "complex64" === r11) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (!V(t1) && !Array.isArray(t1) && "number" != typeof t1 && "boolean" != typeof t1 && "string" != typeof t1) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (null != e8) {
        nt(e8);
        var o11 = k(e8), a7 = k(n5);
        C(o11 === a7, function() {
            return "Based on the provided shape, [" + e8 + "], the tensor should have " + o11 + " values but has " + a7;
        });
        for(var s8 = 0; s8 < n5.length; ++s8){
            var u5 = n5[s8], c3 = s8 !== n5.length - 1 || u5 !== k(e8.slice(s8));
            C(n5[s8] === e8[s8] || !c3, function() {
                return "Error creating a new Tensor. Inferred shape (" + n5 + ") does not match the provided shape (" + e8 + "). ";
            });
        }
    }
    return V(t1) || Array.isArray(t1) || (t1 = [
        t1
    ]), e8 = e8 || n5, t1 = "string" !== r11 ? Q(t1, r11, i15().getBool("DEBUG")) : I(t1, [], !0), Lt.makeTensor(t1, e8, r11);
}
function On(t1, e8) {
    if ((V(t1) && "string" !== e8 || Array.isArray(t1)) && "complex64" !== e8) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if ("string" === e8 && V(t1) && !(t1 instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return _n(t1, [], [], e8);
}
function Mn(t1, e8) {
    R(t1);
    var n5 = pn(t1, e8);
    if (1 !== n5.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return _n(t1, null, n5, e8);
}
function Bn(t1, e8, n5) {
    if (R(t1), null != e8 && 2 !== e8.length) throw new Error("tensor2d() requires shape to have two numbers");
    var r11 = pn(t1, n5);
    if (2 !== r11.length && 1 !== r11.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (1 === r11.length && null == e8) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return _n(t1, e8, r11, n5);
}
function Pn(t1, e8, n5) {
    if (R(t1), null != e8 && 3 !== e8.length) throw new Error("tensor3d() requires shape to have three numbers");
    var r11 = pn(t1, n5);
    if (3 !== r11.length && 1 !== r11.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (1 === r11.length && null == e8) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return _n(t1, e8, r11, n5);
}
function Ln(t1, e8, n5) {
    if (R(t1), null != e8 && 4 !== e8.length) throw new Error("tensor4d() requires shape to have four numbers");
    var r11 = pn(t1, n5);
    if (4 !== r11.length && 1 !== r11.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (1 === r11.length && null == e8) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return _n(t1, e8, r11, n5);
}
function Wn(t1, e8, n5) {
    if (R(t1), null != e8 && 5 !== e8.length) throw new Error("tensor5d() requires shape to have five numbers");
    var r11 = pn(t1, n5);
    if (5 !== r11.length && 1 !== r11.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (1 === r11.length && null == e8) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return _n(t1, e8, r11, n5);
}
function Un(t1, e8, n5) {
    if (R(t1), null != e8 && 6 !== e8.length) throw new Error("tensor6d() requires shape to have six numbers");
    var r11 = pn(t1, n5);
    if (6 !== r11.length && 1 !== r11.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (1 === r11.length && null == e8) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return _n(t1, e8 = e8 || r11, r11, n5);
}
function Vn(t1, e8, n5, r11) {
    return (void 0) === e8 && (e8 = !0), Lt.makeVariable(t1, e8, n5, r11);
}
function zn(t1, e8) {
    if ((void 0) === e8 && (e8 = "float32"), "complex64" === e8) {
        var n5 = zn(t1, "float32"), r11 = Gn(t1, "float32");
        return Dn(n5, r11);
    }
    var o12 = Z(k(t1), e8);
    return Lt.makeTensor(o12, t1, e8);
}
function Gn(t1, e8) {
    if ((void 0) === e8 && (e8 = "float32"), "complex64" === e8) {
        var n6 = Gn(t1, "float32"), r12 = Gn(t1, "float32");
        return Dn(n6, r12);
    }
    var o12 = tt(k(t1), e8);
    return Lt.makeTensor(o12, t1, e8);
}
function Hn(t1, e8, n7) {
    return Lt.runKernelFunc(function(r13) {
        return r13.fill(t1, e8, n7);
    }, {
    });
}
function qn(t1, e8, n7) {
    if (n7 <= 0) throw new Error("The number of values should be positive.");
    return Lt.runKernelFunc(function(r13) {
        return r13.linspace(t1, e8, n7);
    }, {
    });
}
function Kn(t1, e8, n7, r13) {
    if ((void 0) === n7 && (n7 = 1), (void 0) === r13 && (r13 = "float32"), 0 === n7) throw new Error("Cannot have a step of zero");
    if (t1 === e8 || t1 < e8 && n7 < 0 || e8 < t1 && n7 > 1) return Gn([
        0
    ], r13);
    var o12 = tt(Math.abs(Math.ceil((e8 - t1) / n7)), r13);
    e8 < t1 && 1 === n7 && (n7 = -1), o12[0] = t1;
    for(var a8 = 1; a8 < o12.length; a8++)o12[a8] = o12[a8 - 1] + n7;
    return Mn(o12, r13);
}
var jn = An({
    onesLike_: function(t1) {
        var e8 = mn(t1, "x", "onesLike");
        if ("complex64" === e8.dtype) {
            var n7 = jn(Tn(e8)), r13 = Xn(Nn(e8));
            return Dn(n7, r13);
        }
        return Lt.runKernelFunc(function(t4) {
            return t4.onesLike(e8);
        }, {
            $x: e8
        }, function(t4, e9) {
            return {
                $x: function() {
                    return Xn(t4);
                }
            };
        });
    }
}), Xn = An({
    zerosLike_: function(t1) {
        var e8 = mn(t1, "x", "zerosLike");
        return Lt.runKernelFunc(function(t4) {
            return t4.zerosLike(e8);
        }, {
            $x: e8
        }, function(t4, e9) {
            return {
                $x: function() {
                    return Xn(t4);
                }
            };
        });
    }
});
var Yn = An({
    concat_: function(t1, e8) {
        (void 0) === e8 && (e8 = 0), C(t1.length >= 1, function() {
            return "Pass at least one tensor to concat";
        });
        var n8 = gn(t1, "tensors", "concat");
        "complex64" === n8[0].dtype && n8.forEach(function(t4) {
            if ("complex64" !== t4.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t4.dtype + ". ");
        }), e8 = O(e8, n8[0].shape)[0];
        var r14 = Sn(n8.map(function(t4) {
            return t4.shape;
        }), e8);
        if (0 === k(r14)) return Fn([], r14);
        if (1 === (n8 = n8.filter(function(t4) {
            return t4.size > 0;
        })).length) return n8[0];
        var o12 = n8.map(function(t4) {
            return t4.shape;
        });
        kn(o12, e8);
        var a8 = n8, i3 = {
            axis: e8
        };
        return Lt.runKernelFunc(function(t4) {
            return t4.concat(n8, e8);
        }, a8, function(t4) {
            var n9 = o12.map(function(t5) {
                return t5[e8];
            });
            return tr(t4, n9, e8).map(function(t5) {
                return function() {
                    return t5;
                };
            });
        }, "Concat", i3);
    }
}), $n = An({
    concat1d_: function(t1) {
        return Yn(t1, 0);
    }
}), Qn = An({
    concat2d_: function(t1, e8) {
        return Yn(t1, e8);
    }
}), Jn = An({
    concat3d_: function(t1, e8) {
        return Yn(t1, e8);
    }
}), Zn = An({
    concat4d_: function(t1, e8) {
        return Yn(t1, e8);
    }
}), tr = An({
    split_: function(t1, e8, n8) {
        (void 0) === n8 && (n8 = 0);
        var r14, o12 = mn(t1, "x", "split");
        return n8 = O(n8, o12.shape)[0], "number" == typeof e8 ? (C(o12.shape[n8] % e8 == 0, function() {
            return "Number of splits must evenly divide the axis.";
        }), r14 = new Array(e8).fill(o12.shape[n8] / e8)) : (C(o12.shape[n8] === e8.reduce(function(t4, e9) {
            return t4 + e9;
        }), function() {
            return "The sum of sizes must match the size of the axis dimension.";
        }), r14 = e8), Lt.runKernelFunc(function(t4) {
            return t4.split(o12, r14, n8);
        }, {
            $x: o12
        }, function(t4) {
            return {
                $x: function() {
                    return Yn(t4, n8);
                }
            };
        });
    }
});
"undefined" != typeof globalThis || "undefined" != typeof window || "undefined" != typeof global || "undefined";
function er(t1, e8) {
    return t1(e8 = {
        exports: {
        }
    }, e8.exports), e8.exports;
}
var nr = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9, n9 = this, r15 = (e9 = 4022871197, function(t6) {
                t6 = t6.toString();
                for(var n10 = 0; n10 < t6.length; n10++){
                    var r16 = 0.02519603282416938 * (e9 += t6.charCodeAt(n10));
                    r16 -= e9 = r16 >>> 0, e9 = (r16 *= e9) >>> 0, e9 += 4294967296 * (r16 -= e9);
                }
                return 0.00000000023283064365386963 * (e9 >>> 0);
            });
            n9.next = function() {
                var t6 = 2091639 * n9.s0 + 0.00000000023283064365386963 * n9.c;
                return n9.s0 = n9.s1, n9.s1 = n9.s2, n9.s2 = t6 - (n9.c = 0 | t6);
            }, n9.c = 1, n9.s0 = r15(" "), n9.s1 = r15(" "), n9.s2 = r15(" "), n9.s0 -= r15(t5), n9.s0 < 0 && (n9.s0 += 1), n9.s1 -= r15(t5), n9.s1 < 0 && (n9.s1 += 1), n9.s2 -= r15(t5), n9.s2 < 0 && (n9.s2 += 1), r15 = null;
        }
        function o12(t5, e9) {
            return e9.c = t5.c, e9.s0 = t5.s0, e9.s1 = t5.s1, e9.s2 = t5.s2, e9;
        }
        function a8(t5, e9) {
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = n9.next;
            return i3.int32 = function() {
                return 4294967296 * n9.next() | 0;
            }, i3.double = function() {
                return i3() + 0.00000000000000011102230246251565 * (2097152 * i3() | 0);
            }, i3.quick = i3, a9 && ("object" == typeof a9 && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.alea = a8;
    }(0, t1, !1);
}), rr = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9 = this, n9 = "";
            e9.x = 0, e9.y = 0, e9.z = 0, e9.w = 0, e9.next = function() {
                var t6 = e9.x ^ e9.x << 11;
                return e9.x = e9.y, e9.y = e9.z, e9.z = e9.w, e9.w ^= e9.w >>> 19 ^ t6 ^ t6 >>> 8;
            }, t5 === (0 | t5) ? e9.x = t5 : n9 += t5;
            for(var r15 = 0; r15 < n9.length + 64; r15++)e9.x ^= 0 | n9.charCodeAt(r15), e9.next();
        }
        function o12(t5, e9) {
            return e9.x = t5.x, e9.y = t5.y, e9.z = t5.z, e9.w = t5.w, e9;
        }
        function a8(t5, e9) {
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = function() {
                return (n9.next() >>> 0) / 4294967296;
            };
            return i3.double = function() {
                do var t7 = ((n9.next() >>> 11) + (n9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t7)
                return t7;
            }, i3.int32 = n9.next, i3.quick = i3, a9 && ("object" == typeof a9 && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.xor128 = a8;
    }(0, t1, !1);
}), or = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9 = this, n9 = "";
            e9.next = function() {
                var t7 = e9.x ^ e9.x >>> 2;
                return e9.x = e9.y, e9.y = e9.z, e9.z = e9.w, e9.w = e9.v, (e9.d = e9.d + 362437 | 0) + (e9.v = e9.v ^ e9.v << 4 ^ t7 ^ t7 << 1) | 0;
            }, e9.x = 0, e9.y = 0, e9.z = 0, e9.w = 0, e9.v = 0, t5 === (0 | t5) ? e9.x = t5 : n9 += t5;
            for(var r15 = 0; r15 < n9.length + 64; r15++)e9.x ^= 0 | n9.charCodeAt(r15), r15 == n9.length && (e9.d = e9.x << 10 ^ e9.x >>> 4), e9.next();
        }
        function o12(t5, e9) {
            return e9.x = t5.x, e9.y = t5.y, e9.z = t5.z, e9.w = t5.w, e9.v = t5.v, e9.d = t5.d, e9;
        }
        function a8(t5, e9) {
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = function() {
                return (n9.next() >>> 0) / 4294967296;
            };
            return i3.double = function() {
                do var t7 = ((n9.next() >>> 11) + (n9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t7)
                return t7;
            }, i3.int32 = n9.next, i3.quick = i3, a9 && ("object" == typeof a9 && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.xorwow = a8;
    }(0, t1, !1);
}), ar = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9 = this;
            e9.next = function() {
                var t7, n9, r15 = e9.x, o12 = e9.i;
                return t7 = r15[o12], n9 = (t7 ^= t7 >>> 7) ^ t7 << 24, n9 ^= (t7 = r15[o12 + 1 & 7]) ^ t7 >>> 10, n9 ^= (t7 = r15[o12 + 3 & 7]) ^ t7 >>> 3, n9 ^= (t7 = r15[o12 + 4 & 7]) ^ t7 << 7, t7 = r15[o12 + 7 & 7], n9 ^= (t7 ^= t7 << 13) ^ t7 << 9, r15[o12] = n9, e9.i = o12 + 1 & 7, n9;
            }, (function(t7, e10) {
                var n9, r15 = [];
                if (e10 === (0 | e10)) r15[0] = e10;
                else for(e10 = "" + e10, n9 = 0; n9 < e10.length; ++n9)r15[7 & n9] = r15[7 & n9] << 15 ^ e10.charCodeAt(n9) + r15[n9 + 1 & 7] << 13;
                for(; r15.length < 8;)r15.push(0);
                for(n9 = 0; n9 < 8 && 0 === r15[n9]; ++n9);
                for(8 == n9 ? r15[7] = -1 : r15[n9], t7.x = r15, t7.i = 0, n9 = 256; n9 > 0; --n9)t7.next();
            })(e9, t5);
        }
        function o12(t5, e9) {
            return e9.x = t5.x.slice(), e9.i = t5.i, e9;
        }
        function a8(t5, e9) {
            null == t5 && (t5 = +new Date);
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = function() {
                return (n9.next() >>> 0) / 4294967296;
            };
            return i3.double = function() {
                do var t7 = ((n9.next() >>> 11) + (n9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t7)
                return t7;
            }, i3.int32 = n9.next, i3.quick = i3, a9 && (a9.x && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.xorshift7 = a8;
    }(0, t1, !1);
}), ir = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9 = this;
            e9.next = function() {
                var t7, n9, r15 = e9.w, o12 = e9.X, a8 = e9.i;
                return e9.w = r15 = r15 + 1640531527 | 0, n9 = o12[a8 + 34 & 127], t7 = o12[a8 = a8 + 1 & 127], n9 ^= n9 << 13, t7 ^= t7 << 17, n9 ^= n9 >>> 15, t7 ^= t7 >>> 12, n9 = o12[a8] = n9 ^ t7, e9.i = a8, n9 + (r15 ^ r15 >>> 16) | 0;
            }, (function(t7, e10) {
                var n9, r15, o12, a8, i3, s10 = [], u6 = 128;
                for(e10 === (0 | e10) ? (r15 = e10, e10 = null) : (e10 += "\0", r15 = 0, u6 = Math.max(u6, e10.length)), o12 = 0, a8 = -32; a8 < u6; ++a8)e10 && (r15 ^= e10.charCodeAt((a8 + 32) % e10.length)), 0 === a8 && (i3 = r15), r15 ^= r15 << 10, r15 ^= r15 >>> 15, r15 ^= r15 << 4, r15 ^= r15 >>> 13, a8 >= 0 && (i3 = i3 + 1640531527 | 0, o12 = 0 == (n9 = s10[127 & a8] ^= r15 + i3) ? o12 + 1 : 0);
                for(o12 >= 128 && (s10[127 & (e10 && e10.length || 0)] = -1), o12 = 127, a8 = 512; a8 > 0; --a8)r15 = s10[o12 + 34 & 127], n9 = s10[o12 = o12 + 1 & 127], r15 ^= r15 << 13, n9 ^= n9 << 17, r15 ^= r15 >>> 15, n9 ^= n9 >>> 12, s10[o12] = r15 ^ n9;
                t7.w = i3, t7.X = s10, t7.i = o12;
            })(e9, t5);
        }
        function o12(t5, e9) {
            return e9.i = t5.i, e9.w = t5.w, e9.X = t5.X.slice(), e9;
        }
        function a8(t5, e9) {
            null == t5 && (t5 = +new Date);
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = function() {
                return (n9.next() >>> 0) / 4294967296;
            };
            return i3.double = function() {
                do var t7 = ((n9.next() >>> 11) + (n9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t7)
                return t7;
            }, i3.int32 = n9.next, i3.quick = i3, a9 && (a9.X && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.xor4096 = a8;
    }(0, t1, !1);
}), sr = er(function(t1) {
    !function(t4, e8, n8) {
        function r14(t5) {
            var e9 = this, n9 = "";
            e9.next = function() {
                var t7 = e9.b, n10 = e9.c, r15 = e9.d, o12 = e9.a;
                return t7 = t7 << 25 ^ t7 >>> 7 ^ n10, n10 = n10 - r15 | 0, r15 = r15 << 24 ^ r15 >>> 8 ^ o12, o12 = o12 - t7 | 0, e9.b = t7 = t7 << 20 ^ t7 >>> 12 ^ n10, e9.c = n10 = n10 - r15 | 0, e9.d = r15 << 16 ^ n10 >>> 16 ^ o12, e9.a = o12 - t7 | 0;
            }, e9.a = 0, e9.b = 0, e9.c = -1640531527, e9.d = 1367130551, t5 === Math.floor(t5) ? (e9.a = t5 / 4294967296 | 0, e9.b = 0 | t5) : n9 += t5;
            for(var r15 = 0; r15 < n9.length + 20; r15++)e9.b ^= 0 | n9.charCodeAt(r15), e9.next();
        }
        function o12(t5, e9) {
            return e9.a = t5.a, e9.b = t5.b, e9.c = t5.c, e9.d = t5.d, e9;
        }
        function a8(t5, e9) {
            var n9 = new r14(t5), a9 = e9 && e9.state, i3 = function() {
                return (n9.next() >>> 0) / 4294967296;
            };
            return i3.double = function() {
                do var t7 = ((n9.next() >>> 11) + (n9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t7)
                return t7;
            }, i3.int32 = n9.next, i3.quick = i3, a9 && ("object" == typeof a9 && o12(a9, n9), i3.state = function() {
                return o12(n9, {
                });
            }), i3;
        }
        e8 && e8.exports ? e8.exports = a8 : n8 && n8.amd ? n8(function() {
            return a8;
        }) : this.tychei = a8;
    }(0, t1, !1);
}), ur = er(function(t1) {
    !function(e8, n8) {
        var r14, o12 = this, a8 = 256, i3 = 6, s10 = "random", u6 = n8.pow(a8, i3), c4 = n8.pow(2, 52), l3 = 2 * c4, h2 = a8 - 1;
        function f2(t4, h3, f3) {
            var g3 = [], y2 = v3(function t5(e9, n9) {
                var r15, o13 = [], a9 = typeof e9;
                if (n9 && "object" == a9) for(r15 in e9)try {
                    o13.push(t5(e9[r15], n9 - 1));
                } catch (t7) {
                }
                return o13.length ? o13 : "string" == a9 ? e9 : e9 + "\0";
            }((h3 = 1 == h3 ? {
                entropy: !0
            } : h3 || {
            }).entropy ? [
                t4,
                m3(e8)
            ] : null == t4 ? function() {
                try {
                    var t7;
                    return r14 && (t7 = r14.randomBytes) ? t7 = t7(a8) : (t7 = new Uint8Array(a8), (o12.crypto || o12.msCrypto).getRandomValues(t7)), m3(t7);
                } catch (t8) {
                    var n9 = o12.navigator, i5 = n9 && n9.plugins;
                    return [
                        +new Date,
                        o12,
                        i5,
                        o12.screen,
                        m3(e8)
                    ];
                }
            }() : t4, 3), g3), x3 = new d3(g3), b1 = function() {
                for(var t7 = x3.g(i3), e9 = u6, n10 = 0; t7 < c4;)t7 = (t7 + n10) * a8, e9 *= a8, n10 = x3.g(1);
                for(; t7 >= l3;)t7 /= 2, e9 /= 2, n10 >>>= 1;
                return (t7 + n10) / e9;
            };
            return b1.int32 = function() {
                return 0 | x3.g(4);
            }, b1.quick = function() {
                return x3.g(4) / 4294967296;
            }, b1.double = b1, v3(m3(x3.S), e8), (h3.pass || f3 || function(t7, e9, r15, o13) {
                return o13 && (o13.S && p4(o13, x3), t7.state = function() {
                    return p4(x3, {
                    });
                }), r15 ? (n8[s10] = t7, e9) : t7;
            })(b1, y2, "global" in h3 ? h3.global : this == n8, h3.state);
        }
        function d3(t4) {
            var e9, n10 = t4.length, r15 = this, o13 = 0, i6 = r15.i = r15.j = 0, s11 = r15.S = [];
            for(n10 || (t4 = [
                n10++
            ]); o13 < a8;)s11[o13] = o13++;
            for(o13 = 0; o13 < a8; o13++)s11[o13] = s11[i6 = h2 & i6 + t4[o13 % n10] + (e9 = s11[o13])], s11[i6] = e9;
            (r15.g = function(t5) {
                for(var e10, n11 = 0, o14 = r15.i, i7 = r15.j, s12 = r15.S; t5--;)e10 = s12[o14 = h2 & o14 + 1], n11 = n11 * a8 + s12[h2 & (s12[o14] = s12[i7 = h2 & i7 + e10]) + (s12[i7] = e10)];
                return r15.i = o14, r15.j = i7, n11;
            })(a8);
        }
        function p4(t4, e9) {
            return e9.i = t4.i, e9.j = t4.j, e9.S = t4.S.slice(), e9;
        }
        function v3(t4, e9) {
            for(var n10, r15 = t4 + "", o13 = 0; o13 < r15.length;)e9[h2 & o13] = h2 & (n10 ^= 19 * e9[h2 & o13]) + r15.charCodeAt(o13++);
            return m3(e9);
        }
        function m3(t4) {
            return String.fromCharCode.apply(0, t4);
        }
        if (n8["seed" + s10] = f2, v3(n8.random(), e8), t1.exports) {
            t1.exports = f2;
            try {
                r14 = require("crypto");
            } catch (t4) {
            }
        }
    }([], Math);
});
ur.alea = nr, ur.xor128 = rr, ur.xorwow = or, ur.xorshift7 = ar, ur.xor4096 = ir, ur.tychei = sr;
var cr = ur.alea, lr = function() {
    function t1(t4, e8, n8, r14, o12) {
        this.mean = t4, this.stdDev = e8, this.dtype = n8, this.nextVal = NaN, this.truncated = r14, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        var a8 = o12 || Math.random();
        this.random = cr(a8.toString());
    }
    return t1.prototype.nextValue = function() {
        if (!isNaN(this.nextVal)) {
            var t4 = this.nextVal;
            return this.nextVal = NaN, t4;
        }
        for(var e8, n8, r14 = !1; !r14;){
            var o12 = void 0, a8 = void 0, i3 = void 0;
            do i3 = (o12 = 2 * this.random() - 1) * o12 + (a8 = 2 * this.random() - 1) * a8;
            while (i3 >= 1 || 0 === i3)
            var s10 = Math.sqrt(-2 * Math.log(i3) / i3);
            e8 = this.mean + this.stdDev * o12 * s10, n8 = this.mean + this.stdDev * a8 * s10, this.truncated && !this.isValidTruncated(e8) || (r14 = !0);
        }
        return this.truncated && !this.isValidTruncated(n8) || (this.nextVal = this.convertValue(n8)), this.convertValue(e8);
    }, t1.prototype.convertValue = function(t5) {
        return null == this.dtype || "float32" === this.dtype ? t5 : Math.round(t5);
    }, t1.prototype.isValidTruncated = function(t5) {
        return t5 <= this.upper && t5 >= this.lower;
    }, t1;
}(), hr = function() {
    function t1(t5, e8, n8, r14) {
        this.alpha = t5, this.beta = 1 / e8, this.dtype = n8;
        var o13 = r14 || Math.random();
        this.randu = cr(o13.toString()), this.randn = new lr(0, 1, n8, !1, this.randu()), this.d = t5 < 1 ? t5 + 2 / 3 : t5 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
    }
    return t1.prototype.nextValue = function() {
        for(var t5, e8, n8, r14, o13, a9;;){
            do r14 = this.randn.nextValue(), a9 = 1 + this.c * r14;
            while (a9 <= 0)
            if (a9 *= a9 * a9, e8 = 1 - 0.331 * (t5 = r14 * r14) * t5, n8 = 0.5 * t5 + this.d * (1 - a9 + Math.log(a9)), (o13 = this.randu()) < e8 || Math.log(o13) < n8) break;
        }
        return a9 = 1 / this.beta * this.d * a9, this.alpha < 1 && (a9 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a9);
    }, t1.prototype.convertValue = function(t5) {
        return "float32" === this.dtype ? t5 : Math.round(t5);
    }, t1;
}(), fr = function() {
    function t1(t5, e8, n8, r14) {
        var o13 = this;
        if ((void 0) === t5 && (t5 = 0), (void 0) === e8 && (e8 = 1), this.canReturnFloat = function() {
            return null == o13.dtype || "float32" === o13.dtype;
        }, this.min = t5, this.range = e8 - t5, this.dtype = n8, null == r14 && (r14 = Math.random()), "number" == typeof r14 && (r14 = r14.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t5 + " - " + e8 + " <= 1 and dtype is not float");
        this.random = cr(r14);
    }
    return t1.prototype.convertValue = function(t5) {
        return this.canReturnFloat() ? t5 : Math.round(t5);
    }, t1.prototype.nextValue = function() {
        return this.convertValue(this.min + this.range * this.random());
    }, t1;
}();
function dr(t1, e8, n8) {
    return (void 0) === e8 && (e8 = "float32"), e8 = e8 || "float32", nt(t1), new gt(t1, e8, n8);
}
function pr(t1, e8) {
    (void 0) === e8 && (e8 = !1), console.log(t1.toString(e8));
}
var vr = An({
    batchToSpaceND_: function(t1, e8, n8) {
        var r14 = mn(t1, "x", "batchToSpaceND"), o13 = e8.reduce(function(t5, e9) {
            return t5 * e9;
        });
        return C(r14.rank >= 1 + e8.length, function() {
            return "input rank is " + r14.rank + " but should be > than blockShape.length " + e8.length;
        }), C(n8.length === e8.length, function() {
            return "crops.length is " + n8.length + " but should be equal to blockShape.length  " + e8.length;
        }), C(r14.shape[0] % o13 == 0, function() {
            return "input tensor batch is " + r14.shape[0] + " but is not divisible by the product of the elements of blockShape " + e8.join(" * ") + " === " + o13;
        }), Lt.runKernelFunc(function(t5) {
            return t5.batchToSpaceND(r14, e8, n8);
        }, {
            $x: r14
        }, function(t5) {
            return {
                $x: function() {
                    return t5.spaceToBatchND(e8, n8);
                }
            };
        });
    }
}), mr = An({
    broadcastTo_: function(t1, e8) {
        var n8 = mn(t1, "broadcastTo", "x"), r14 = n8.shape;
        if (e8.some(function(t5) {
            return !(t5 > 0) || t5 % 1 != 0;
        })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e8 + "].");
        if (e8.length < n8.rank) throw new Error("broadcastTo(): shape.length=" + e8.length + " < input.rank=" + n8.rank + ".");
        if (e8.length > n8.rank) {
            for(var o13 = n8.shape.slice(); o13.length < e8.length;)o13.unshift(1);
            n8 = n8.reshape(o13);
        }
        for(var a9 = Array.from(e8), i6 = e8.length - 1; i6 >= 0; i6--)if (n8.shape[i6] === e8[i6]) a9[i6] = 1;
        else if (1 !== n8.shape[i6]) throw new Error("broadcastTo(): [" + r14 + "] cannot be broadcast to [" + e8 + "].");
        var s11 = a9.map(function(t5, e9) {
            return t5 > 1 ? e9 : -1;
        }).filter(function(t5) {
            return t5 >= 0;
        });
        return 0 === s11.length ? n8.clone() : Lt.runKernelFunc(function(t5) {
            return t5.tile(n8, a9);
        }, {
            input: n8
        }, function(t5) {
            return {
                input: function() {
                    return t5.sum(s11, !0);
                }
            };
        });
    }
}), gr = An({
    cast_: function(t1, e8) {
        var n8 = mn(t1, "x", "cast");
        if (!W(e8)) throw new Error("Failed to cast to unknown dtype " + e8);
        if ("string" === e8 && "string" !== n8.dtype || "string" !== e8 && "string" === n8.dtype) throw new Error("Only strings can be casted to strings");
        var r14 = {
            dtype: e8
        };
        return Lt.runKernelFunc(function(t5) {
            return t5.cast(n8, e8);
        }, {
            x: n8
        }, function(t5) {
            return {
                x: function() {
                    return t5.clone();
                }
            };
        }, "Cast", r14);
    }
}), yr = An({
    clone_: function(t1) {
        var e8 = mn(t1, "x", "clone", null);
        return Lt.runKernelFunc(function() {
            return Lt.makeTensorFromDataId(e8.dataId, e8.shape, e8.dtype);
        }, {
            $x: e8
        }, function(t5) {
            return {
                $x: function() {
                    return t5.toFloat();
                }
            };
        });
    }
}), xr = An({
    cumsum_: function(t1, e8, n8, r14) {
        (void 0) === e8 && (e8 = 0), (void 0) === n8 && (n8 = !1), (void 0) === r14 && (r14 = !1);
        var o14 = mn(t1, "x", "cumsum"), a9 = En([
            e8 |= 0
        ], o14.rank), i6 = o14;
        null != a9 && (i6 = o14.transpose(a9));
        var s11 = In(1, o14.rank)[0], u6 = Lt.runKernelFunc(function(t5) {
            return t5.cumsum(i6, s11, n8, r14);
        }, {
            permutedX: i6
        }, function(t5) {
            return {
                permutedX: function() {
                    return t5.cumsum(e8, n8, !r14);
                }
            };
        });
        return null != a9 && (u6 = u6.transpose(a9)), u6;
    }
}), br = An({
    depthToSpace_: function(t1, e8, n8) {
        (void 0) === n8 && (n8 = "NHWC");
        var r14 = mn(t1, "x", "depthToSpace"), o14 = "NHWC" === n8 ? r14.shape[1] : r14.shape[2], a9 = "NHWC" === n8 ? r14.shape[2] : r14.shape[3], i6 = "NHWC" === n8 ? r14.shape[3] : r14.shape[1];
        return C(o14 * e8 >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n      " + o14 + " and " + e8 + "  for depthToSpace with input shape\n      " + r14.shape;
        }), C(a9 * e8 >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n      " + a9 + " and " + e8 + " for depthToSpace with input shape\n          " + r14.shape;
        }), C(i6 % (e8 * e8) == 0, function() {
            return "Dimension size must be evenly divisible by " + e8 * e8 + " but is " + i6 + " for depthToSpace with input shape " + r14.shape;
        }), Lt.runKernelFunc(function(t5) {
            return t5.depthToSpace(r14, e8, n8);
        }, {
            $x: r14
        });
    }
}), wr = An({
    expandDims_: function(t1, e8) {
        (void 0) === e8 && (e8 = 0);
        var n8 = mn(t1, "x", "expandDims", null);
        C(e8 <= n8.rank, function() {
            return "Axis must be <= rank of the tensor";
        });
        var r14 = n8.shape.slice();
        return e8 < 0 && (C(-(n8.rank + 1) <= e8, function() {
            return "Axis must be in the interval [" + -(n8.rank + 1) + ", " + n8.rank + "]";
        }), e8 = n8.rank + e8 + 1), r14.splice(e8, 0, 1), Or(n8, r14);
    }
}), Cr = An({
    eye_: function(t1, e8, n8, r14) {
        (void 0) === r14 && (r14 = "float32"), null == e8 && (e8 = t1);
        for(var o14 = dr([
            t1,
            e8
        ], r14), a9 = t1 <= e8 ? t1 : e8, i6 = 0; i6 < a9; ++i6)o14.set(1, i6, i6);
        var s11 = o14.toTensor().as2D(t1, e8);
        if (null == n8) return s11;
        if (1 === n8.length) return Lr(wr(s11, 0), [
            n8[0],
            1,
            1
        ]);
        if (2 === n8.length) return Lr(wr(wr(s11, 0), 0), [
            n8[0],
            n8[1],
            1,
            1
        ]);
        if (3 === n8.length) return Lr(wr(wr(wr(s11, 0), 0), 0), [
            n8[0],
            n8[1],
            n8[2],
            1,
            1
        ]);
        throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n8.length + "D.");
    }
}), Er = An({
    multinomial_: function(t1, e8, n8, r14) {
        (void 0) === r14 && (r14 = !1);
        var o14 = mn(t1, "logits", "multinomial"), a9 = o14.size, i6 = o14.rank;
        if (a9 < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a9 + ".");
        if (i6 > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i6);
        n8 = n8 || Math.random();
        var s11 = 1 === i6 ? o14.as2D(1, -1) : o14, u6 = Lt.runKernelFunc(function(t5) {
            return t5.multinomial(s11, r14, e8, n8);
        }, {
            logits2D: s11
        });
        return 1 === i6 ? u6.as1D() : u6;
    }
}), Rr = An({
    oneHot_: function(t1, e8, n8, r14) {
        if ((void 0) === n8 && (n8 = 1), (void 0) === r14 && (r14 = 0), e8 < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e8);
        var o14 = mn(t1, "indices", "oneHot", "int32"), a9 = o14.shape.concat([
            e8
        ]);
        return o14 = o14.flatten(), Lt.runKernelFunc(function(t5) {
            return t5.oneHot(o14, e8, n8, r14);
        }, {
            $indices: o14
        }, function(t5) {
            return {
                $indices: function() {
                    return Gn(o14.shape, "float32");
                }
            };
        }).reshape(a9);
    }
}), Ir = An({
    pad_: function(t1, e8, n8) {
        (void 0) === n8 && (n8 = 0);
        var r14 = mn(t1, "x", "pad");
        if (0 === r14.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        var o14 = {
            paddings: e8,
            constantValue: n8
        };
        return Lt.runKernelFunc(function(t5) {
            return t5.pad(r14, e8, n8);
        }, {
            x: r14
        }, function(t5) {
            var n10 = e8.map(function(t7) {
                return t7[0];
            });
            return {
                x: function() {
                    return t5.slice(n10, r14.shape);
                }
            };
        }, "PadV2", o14);
    }
}), kr = An({
    pad1d_: function(t1, e8, n8) {
        return (void 0) === n8 && (n8 = 0), C(2 === e8.length, function() {
            return "Invalid number of paddings. Must be length of 2.";
        }), Ir(t1, [
            e8
        ], n8);
    }
}), Sr = An({
    pad2d_: function(t1, e8, n8) {
        return (void 0) === n8 && (n8 = 0), C(2 === e8.length && 2 === e8[0].length && 2 === e8[1].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ir(t1, e8, n8);
    }
}), Ar = An({
    pad3d_: function(t1, e8, n8) {
        return (void 0) === n8 && (n8 = 0), C(3 === e8.length && 2 === e8[0].length && 2 === e8[1].length && 2 === e8[2].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ir(t1, e8, n8);
    }
}), Dr = An({
    pad4d_: function(t1, e8, n8) {
        return (void 0) === n8 && (n8 = 0), C(4 === e8.length && 2 === e8[0].length && 2 === e8[1].length && 2 === e8[2].length && 2 === e8[3].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ir(t1, e8, n8);
    }
}), Tr = An({
    rand_: function(t1, e8, n8) {
        var r14 = k(t1), o14 = null;
        if (null == n8 || "float32" === n8) o14 = new Float32Array(r14);
        else if ("int32" === n8) o14 = new Int32Array(r14);
        else {
            if ("bool" !== n8) throw new Error("Unknown data type " + n8);
            o14 = new Uint8Array(r14);
        }
        for(var a9 = 0; a9 < r14; a9++)o14[a9] = e8();
        return Lt.makeTensor(o14, t1, n8);
    }
}), Nr = An({
    randomNormal_: function(t1, e8, n8, r14, o14) {
        if ((void 0) === e8 && (e8 = 0), (void 0) === n8 && (n8 = 1), null != r14 && "bool" === r14) throw new Error("Unsupported data type " + r14);
        for(var a9 = new lr(e8, n8, r14, !1, o14), i6 = dr(t1, r14), s11 = 0; s11 < i6.values.length; s11++)i6.values[s11] = a9.nextValue();
        return i6.toTensor();
    }
}), Fr = An({
    randomGamma_: function(t1, e8, n8, r14, o14) {
        if ((void 0) === n8 && (n8 = 1), (void 0) === r14 && (r14 = "float32"), null == n8 && (n8 = 1), null == r14 && (r14 = "float32"), "float32" !== r14 && "int32" !== r14) throw new Error("Unsupported data type " + r14);
        for(var a9 = new hr(e8, n8, r14, o14), i6 = dr(t1, r14), s11 = 0; s11 < i6.values.length; s11++)i6.values[s11] = a9.nextValue();
        return i6.toTensor();
    }
}), _r = An({
    randomUniform_: function(t1, e8, n8, r14, o14) {
        (void 0) === e8 && (e8 = 0), (void 0) === n8 && (n8 = 1), (void 0) === r14 && (r14 = "float32");
        for(var a9 = dr(t1, r14), i6 = new fr(e8, n8, null, o14), s11 = 0; s11 < a9.values.length; s11++)a9.values[s11] = i6.nextValue();
        return a9.toTensor();
    }
}), Or = An({
    reshape_: function(t1, e8) {
        var n8 = mn(t1, "x", "reshape", null);
        e8 = _(e8, n8.size), C(n8.size === k(e8), function() {
            return "new shape and old shape must have the same number of elements.";
        });
        var r14 = {
            shape: e8
        };
        return Lt.runKernelFunc(function(t5) {
            return t5.reshape(n8, e8);
        }, {
            x: n8
        }, function(t5) {
            return {
                x: function() {
                    return t5.reshape(n8.shape);
                }
            };
        }, "Reshape", r14);
    }
}), Mr = An({
    spaceToBatchND_: function(t1, e8, n8) {
        var r14 = mn(t1, "x", "spaceToBatchND");
        return C(r14.rank >= 1 + e8.length, function() {
            return "input rank " + r14.rank + " should be > than [blockShape] " + e8.length;
        }), C(n8.length === e8.length, function() {
            return "paddings.shape[0] " + n8.length + " must be equal to [blockShape] " + e8.length;
        }), C(r14.shape.reduce(function(t5, r15, o14) {
            return o14 > 0 && o14 <= e8.length ? t5 && (r15 + n8[o14 - 1][0] + n8[o14 - 1][1]) % e8[o14 - 1] == 0 : t5;
        }, !0), function() {
            return "input spatial dimensions " + r14.shape.slice(1) + " with paddings " + n8.toString() + " must be divisible by blockShapes " + e8.toString();
        }), Lt.runKernelFunc(function(t5) {
            return t5.spaceToBatchND(r14, e8, n8);
        }, {
            $x: r14
        }, function(t5) {
            return {
                $x: function() {
                    return t5.batchToSpaceND(e8, n8);
                }
            };
        });
    }
}), Br = An({
    squeeze_: function(t1, e8) {
        var n8 = mn(t1, "x", "squeeze");
        return Or(n8, M(n8.shape, e8).newShape);
    }
}), Pr = An({
    stack_: function(t1, e8) {
        (void 0) === e8 && (e8 = 0);
        var n8 = gn(t1, "tensors", "stack");
        if (C(n8.length >= 1, function() {
            return "Pass at least one tensor to tf.stack";
        }), 1 === n8.length) return n8[0].expandDims(e8);
        var r14 = n8[0].rank, o14 = n8[0].shape, a9 = n8[0].dtype;
        C(e8 <= r14, function() {
            return "Axis must be <= rank of the tensor";
        }), n8.forEach(function(t5) {
            E(o14, t5.shape, "All tensors passed to stack must have matching shapes");
        }), n8.forEach(function(t5) {
            C(a9 === t5.dtype, function() {
                return "All tensors passed to stack must have matching dtypes";
            });
        });
        var i6 = n8.map(function(t5) {
            return t5.expandDims(e8);
        });
        return Yn(i6, e8);
    }
}), Lr = An({
    tile_: function(t1, e8) {
        var n8 = mn(t1, "x", "tile", null);
        C(n8.rank === e8.length, function() {
            return "Error in transpose: rank of input " + n8.rank + " must match length of reps " + e8 + ".";
        });
        var r14 = [
            n8
        ], o14 = {
            reps: e8
        };
        return Lt.runKernelFunc(function(t5, r15) {
            var o15 = t5.tile(n8, e8);
            return r15([
                n8
            ]), o15;
        }, {
            x: n8
        }, function(t5, n10) {
            var r15 = n10[0];
            return {
                x: function() {
                    var n11 = Xn(r15);
                    if (1 === r15.rank) for(var o15 = 0; o15 < e8[0]; ++o15)n11 = n11.add(t5.slice([
                        o15 * r15.shape[0]
                    ], [
                        r15.shape[0]
                    ]));
                    else if (2 === r15.rank) for(o15 = 0; o15 < e8[0]; ++o15)for(var a9 = 0; a9 < e8[1]; ++a9)n11 = n11.add(t5.slice([
                        o15 * r15.shape[0],
                        a9 * r15.shape[1]
                    ], [
                        r15.shape[0],
                        r15.shape[1]
                    ]));
                    else if (3 === r15.rank) for(o15 = 0; o15 < e8[0]; ++o15)for(a9 = 0; a9 < e8[1]; ++a9)for(var i6 = 0; i6 < e8[2]; ++i6)n11 = n11.add(t5.slice([
                        o15 * r15.shape[0],
                        a9 * r15.shape[1],
                        i6 * r15.shape[2]
                    ], [
                        r15.shape[0],
                        r15.shape[1],
                        r15.shape[2]
                    ]));
                    else {
                        if (4 !== r15.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r15.rank + " tensors yet.");
                        for(o15 = 0; o15 < e8[0]; ++o15)for(a9 = 0; a9 < e8[1]; ++a9)for(i6 = 0; i6 < e8[2]; ++i6)for(var s11 = 0; s11 < e8[3]; ++s11)n11 = n11.add(t5.slice([
                            o15 * r15.shape[0],
                            a9 * r15.shape[1],
                            i6 * r15.shape[2],
                            s11 * r15.shape[3]
                        ], [
                            r15.shape[0],
                            r15.shape[1],
                            r15.shape[2],
                            r15.shape[3]
                        ]));
                    }
                    return n11;
                }
            };
        }, "Tile", o14, r14);
    }
}), Wr = An({
    truncatedNormal_: function(t1, e8, n8, r14, o14) {
        if ((void 0) === e8 && (e8 = 0), (void 0) === n8 && (n8 = 1), null != r14 && "bool" === r14) throw new Error("Unsupported data type " + r14);
        for(var a9 = new lr(e8, n8, r14, !0, o14), i6 = dr(t1, r14), s12 = 0; s12 < i6.values.length; s12++)i6.values[s12] = a9.nextValue();
        return i6.toTensor();
    }
}), Ur = An({
    unstack_: function(t1, e8) {
        (void 0) === e8 && (e8 = 0), e8 = e8 || 0;
        var n8 = mn(t1, "x", "unstack");
        C(e8 >= -n8.shape.length && e8 < n8.shape.length, function() {
            return "Axis = " + e8 + " is not in [-" + n8.shape.length + ", " + n8.shape.length + ")";
        }), e8 < 0 && (e8 += n8.shape.length);
        var r14 = {
            axis: e8
        };
        return Lt.runKernelFunc(function(t5) {
            return t5.unstack(n8, e8);
        }, {
            x: n8
        }, function(t5) {
            return {
                x: function() {
                    return Pr(t5, e8);
                }
            };
        }, "Unpack", r14);
    }
}), Vr = function(t1, e8) {
    return n10(this, void 0, void 0, function() {
        var n8, o14, a9, i6, s12, u6, c4, l3, h2, f2;
        return r17(this, function(r14) {
            switch(r14.label){
                case 0:
                    return n8 = mn(t1, "x", "setdiff1d"), o14 = mn(e8, "y", "setdiff1d"), C(n8.dtype === o14.dtype, function() {
                        return "x and y should have the same dtype, but got x (" + n8.dtype + ") and y (" + o14.dtype + ").";
                    }), C(1 === n8.rank, function() {
                        return "x should be 1D tensor, but got x (" + n8.shape + ").";
                    }), C(1 === o14.rank, function() {
                        return "y should be 1D tensor, but got y (" + o14.shape + ").";
                    }), [
                        4,
                        n8.data()
                    ];
                case 1:
                    return a9 = r14.sent(), [
                        4,
                        o14.data()
                    ];
                case 2:
                    for(i6 = r14.sent(), s12 = new Set(i6), u6 = 0, h2 = 0; h2 < a9.length; h2++)s12.has(a9[h2]) || u6++;
                    for(c4 = new gt([
                        u6
                    ], n8.dtype), l3 = new gt([
                        u6
                    ], "int32"), h2 = 0, f2 = 0; h2 < a9.length; h2++)s12.has(a9[h2]) || (c4.values[f2] = a9[h2], l3.values[f2] = h2, f2++);
                    return [
                        2,
                        [
                            c4.toTensor(),
                            l3.toTensor()
                        ]
                    ];
            }
        });
    });
};
function zr(t1, e8, n8, r14) {
    (void 0) === r14 && (r14 = !0);
    var o14 = [];
    if (r14) (o14 = o14.concat(e8.slice(0))).push(t1[0] / n8), o14 = o14.concat(t1.slice(1));
    else {
        o14 = o14.concat(t1[0]);
        for(var a9 = e8.length, i6 = 0; i6 < a9; ++i6)o14 = o14.concat([
            t1[i6 + 1] / e8[i6],
            e8[i6]
        ]);
        o14 = o14.concat(t1.slice(a9 + 1));
    }
    return o14;
}
function Gr(t1, e8, n8) {
    (void 0) === n8 && (n8 = !0);
    var r14 = [];
    if (n8) {
        r14.push(e8);
        for(var o14 = e8 + 1; o14 < t1; ++o14)o14 <= 2 * e8 ? (r14.push(o14), r14.push(o14 - (e8 + 1))) : r14.push(o14);
    } else {
        var a10 = [], i7 = [];
        for(o14 = 1; o14 < t1; ++o14)o14 >= 2 * e8 + 1 || o14 % 2 == 1 ? i7.push(o14) : a10.push(o14);
        r14.push.apply(r14, a10), r14.push(0), r14.push.apply(r14, i7);
    }
    return r14;
}
function Hr(t1, e8, n8, r14) {
    (void 0) === r14 && (r14 = !0);
    var o15 = [];
    r14 ? o15.push(t1[0] / n8) : o15.push(t1[0] * n8);
    for(var a11 = 1; a11 < t1.length; ++a11)a11 <= e8.length ? r14 ? o15.push(e8[a11 - 1] * t1[a11]) : o15.push(t1[a11] / e8[a11 - 1]) : o15.push(t1[a11]);
    return o15;
}
function qr(t1, e8) {
    for(var n8 = [
        0
    ], r14 = 0; r14 < e8; ++r14)n8.push(t1[r14][0]);
    return n8;
}
function Kr(t1, e8, n8) {
    for(var r14 = t1.slice(0, 1), o15 = 0; o15 < n8; ++o15)r14.push(t1[o15 + 1] - e8[o15][0] - e8[o15][1]);
    return r14;
}
function jr(t1, e8) {
    if (t1.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t1.rank + ".");
    if (e8.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e8.rank + ".");
    if ("int32" !== e8.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e8.dtype + ".");
    if (e8.shape[e8.rank - 1] > t1.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e8.shape[e8.rank - 1] + " vs. " + t1.rank);
    if (0 === t1.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t1.shape + ".");
    for(var n8 = e8.shape, r14 = n8[n8.length - 1], o15 = 1, a11 = 0; a11 < n8.length - 1; ++a11)o15 *= n8[a11];
    var i8 = t1.shape, s12 = n8.slice();
    s12.pop();
    var u6 = 1;
    for(a11 = r14; a11 < t1.rank; ++a11)u6 *= i8[a11], s12.push(i8[a11]);
    var c4 = $(t1.shape).map(function(t5) {
        return t5 / u6;
    }).concat([
        1
    ]).slice(0, r14);
    return [
        s12,
        o15,
        u6,
        c4
    ];
}
var Xr = Object.freeze({
    prepareAndValidate: jr
}), Yr = 30;
function $r(t1) {
    return t1 <= Yr ? t1 : Y(t1, Math.floor(Math.sqrt(t1)));
}
function Qr(t1, e8, n8) {
    var r14 = e8.rank > 1 ? e8.shape[e8.rank - 1] : 1, o15 = e8.rank > 1 ? e8.rank - 1 : 1, a11 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n8.shape + ", indices.shape: " + e8.shape + ", shape: " + t1 + ", sliceDim: " + r14 + ", and batchDim: " + o15 + ".";
    if (n8.rank < o15) throw new Error(a11 + " update.rank < " + o15 + ". ");
    if (t1.length < r14 + (n8.rank - o15)) throw new Error(a11 + " Output shape length < " + (r14 + (n8.rank - o15)));
    if (n8.rank !== o15 + t1.length - r14) throw new Error(a11 + " update.rank != " + (o15 + t1.length - r14));
    for(var i8 = 0; i8 < o15; ++i8)if (n8.shape[i8] !== e8.shape[i8]) throw new Error(a11 + " updates.shape[" + i8 + "] (" + n8.shape[i8] + ") != indices.shape[" + i8 + "] (" + e8.shape[i8] + ").");
    for(i8 = 0; i8 < n8.rank - o15; ++i8)if (n8.shape[i8 + o15] !== t1[i8 + r14]) throw new Error(a11 + " updates.shape[" + (i8 + o15) + "] (" + n8.shape[i8 + o15] + ") != shape[" + (i8 + o15) + "] (" + t1[i8 + o15] + ")");
}
function Jr(t1, e8, n8) {
    if (e8.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e8.rank + ".");
    if (t1.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t1.rank + ".");
    if ("int32" !== e8.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e8.dtype);
    if (n8.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n8);
    if (0 === n8.length) {
        if (0 === e8.size) throw new Error("Indices specified for empty output. indices shape: " + e8.shape);
        if (0 === t1.size) throw new Error("Updates specified for empty output. updates shape: " + t1.shape);
    }
    Qr(n8, e8, t1);
}
function Zr(t1, e8, n8) {
    for(var r14 = e8.shape.length, o15 = r14 > 1 ? e8.shape[r14 - 1] : 1, a11 = n8.length, i8 = 1, s12 = o15; s12 < a11; ++s12)i8 *= n8[s12];
    var u6 = o15 < 1 ? 1 : o15;
    return {
        sliceRank: o15,
        numUpdates: k(e8.shape) / u6,
        sliceSize: i8,
        strides: $(n8.slice(0, o15)).concat([
            1
        ]),
        outputSize: k(n8)
    };
}
var to = Object.freeze({
    validateUpdateShape: Qr,
    validateInput: Jr,
    calculateShapes: Zr
});
function eo(t1, e8, n8) {
    C(t1.rank === e8.length, function() {
        return "Error in slice" + t1.rank + "D: Length of begin " + e8 + " must match the rank of the array (" + t1.rank + ").";
    }), C(t1.rank === n8.length, function() {
        return "Error in slice" + t1.rank + "D: Length of size " + n8 + " must match the rank of the array (" + t1.rank + ").";
    });
    for(var r14 = function(r15) {
        C(e8[r15] + n8[r15] <= t1.shape[r15], function() {
            return "Error in slice" + t1.rank + "D: begin[" + r15 + "] + size[" + r15 + "] (" + (e8[r15] + n8[r15]) + ") would overflow input.shape[" + r15 + "] (" + t1.shape[r15] + ")";
        });
    }, o15 = 0; o15 < t1.rank; ++o15)r14(o15);
}
function no(t1) {
    for(var e8 = [], n8 = 0; t1 > 0;)1 & t1 && e8.push(n8), t1 /= 2, n8++;
    return e8;
}
function ro(t1, e8, n8) {
    for(var r14 = [], o15 = 0; o15 < t1.length; o15++)r14[o15] = Math.ceil((e8[o15] - t1[o15]) / n8[o15]);
    return r14;
}
function oo(t1, e8, n8, r14, o15) {
    var a11 = e8[o15], i8 = n8[o15] || 1;
    (t1 & 1 << o15 || null == a11) && (a11 = i8 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
    var s12 = r14[o15];
    return a11 < 0 && (a11 += s12), a11 = x1(0, a11, s12 - 1);
}
function ao(t1, e8, n8, r14, o15) {
    var a11 = e8[o15], i8 = n8[o15] || 1;
    (t1 & 1 << o15 || null == a11) && (a11 = i8 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
    var s12 = r14[o15];
    return a11 < 0 && (a11 += s12), a11 = i8 > 0 ? x1(0, a11, s12) : x1(-1, a11, s12 - 1);
}
function io(t1, e8, n8) {
    for(var r14 = n8.length, o15 = 0; o15 < n8.length; o15++)if (n8[o15] > 1) {
        r14 = o15;
        break;
    }
    for(o15 = r14 + 1; o15 < n8.length; o15++)if (e8[o15] > 0 || n8[o15] !== t1[o15]) return !1;
    return !0;
}
function so(t1, e8) {
    for(var n8 = t1.length > 0 ? t1[t1.length - 1] : 1, r14 = 0; r14 < t1.length - 1; r14++)n8 += t1[r14] * e8[r14];
    return n8;
}
var uo = Object.freeze({
    assertParamsValid: eo,
    maskToAxes: no,
    computeOutShape: ro,
    startForAxis: oo,
    stopForAxis: ao,
    isSliceContinous: io,
    computeFlatOffset: so
});
function co(t1) {
    return C(X(t1), function() {
        return "The f passed in grad(f) must be a function";
    }), function(e8, n8) {
        var r14 = mn(e8, "x", "tf.grad", null), o15 = null != n8 ? mn(n8, "dy", "tf.grad") : null;
        return Lt.tidy(function() {
            var e9 = Lt.gradients(function() {
                return t1(r14);
            }, [
                r14
            ], o15), n10 = e9.value, a11 = e9.grads;
            return null != o15 && E(n10.shape, o15.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), mo(a11), a11[0];
        });
    };
}
function lo(t1) {
    return C(X(t1), function() {
        return "The f passed in grads(f) must be a function";
    }), function(e8, n8) {
        C(Array.isArray(e8), function() {
            return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
        });
        var r14 = gn(e8, "args", "tf.grads", null), o15 = null != n8 ? mn(n8, "dy", "tf.grads") : null;
        return Lt.tidy(function() {
            var e9 = Lt.gradients(function() {
                return t1.apply(void 0, r14);
            }, r14, o15), n10 = e9.value, a11 = e9.grads;
            return null != o15 && E(n10.shape, o15.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mo(a11), a11;
        });
    };
}
function ho(t1) {
    return C(X(t1), function() {
        return "The f passed in valueAndGrad(f) must be a function";
    }), function(e8, n8) {
        C(e8 instanceof wt, function() {
            return "The x passed in valueAndGrad(f)(x) must be a tensor";
        }), C(null == n8 || n8 instanceof wt, function() {
            return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
        });
        var r14 = Lt.gradients(function() {
            return t1(e8);
        }, [
            e8
        ], n8), o15 = r14.grads, a11 = r14.value;
        return mo(o15), {
            grad: o15[0],
            value: a11
        };
    };
}
function fo(t1) {
    return C(X(t1), function() {
        return "The f passed in valueAndGrads(f) must be a function";
    }), function(e8, n8) {
        C(Array.isArray(e8) && e8.every(function(t5) {
            return t5 instanceof wt;
        }), function() {
            return "The args passed in valueAndGrads(f)(args) must be array of tensors";
        }), C(null == n8 || n8 instanceof wt, function() {
            return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
        });
        var r14 = Lt.gradients(function() {
            return t1.apply(void 0, e8);
        }, e8, n8);
        return null != n8 && E(r14.value.shape, n8.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mo(r14.grads), r14;
    };
}
function po(t1, e8) {
    C(X(t1), function() {
        return "The f passed in variableGrads(f) must be a function";
    }), C(null == e8 || Array.isArray(e8) && e8.every(function(t5) {
        return t5 instanceof St;
    }), function() {
        return "The varList passed in variableGrads(f, varList) must be an array of variables";
    });
    var n8 = null != e8;
    if (!n8) for(var r14 in e8 = [], Lt.registeredVariables)e8.push(Lt.registeredVariables[r14]);
    var o15 = n8 ? e8.filter(function(t5) {
        return !t5.trainable;
    }) : null, a11 = e8.length;
    C((e8 = e8.filter(function(t5) {
        return t5.trainable;
    })).length > 0, function() {
        return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a11 + " variables is trainable.";
    });
    var i8 = Lt.gradients(t1, e8, null, !0), s12 = i8.value, u6 = i8.grads;
    C(u6.some(function(t5) {
        return null != t5;
    }), function() {
        return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
    }), C(0 === s12.rank, function() {
        return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s12.rank + " tensor";
    });
    var c4 = {
    };
    return e8.forEach(function(t5, e9) {
        null != u6[e9] && (c4[t5.name] = u6[e9]);
    }), null != o15 && o15.forEach(function(t5) {
        return c4[t5.name] = null;
    }), {
        value: s12,
        grads: c4
    };
}
function vo(t1) {
    return Lt.customGrad(t1);
}
function mo(t1) {
    if (t1.filter(function(t5) {
        return null == t5;
    }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}
var go = An({
    softmax_: function(t1, e8) {
        (void 0) === e8 && (e8 = -1);
        var n8 = mn(t1, "logits", "softmax", "float32");
        if (-1 === e8 && (e8 = n8.rank - 1), e8 !== n8.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n8.rank + " and dim was " + e8);
        return Lt.runKernelFunc(function(t5, r14) {
            var o15 = t5.softmax(n8, e8);
            return r14([
                o15
            ]), o15;
        }, {
            logits: n8
        }, function(t5, n10) {
            var r14 = n10[0], o15 = t5.mul(r14);
            return {
                logits: function() {
                    return o15.sub(o15.sum([
                        e8
                    ], !0).mul(r14));
                }
            };
        }, "Softmax", {
            dim: e8
        }, [], [
            !0
        ]);
    }
}), yo = An({
    logSoftmax_: function(t1, e8) {
        (void 0) === e8 && (e8 = -1);
        var n8 = mn(t1, "logits", "logSoftmax");
        if (-1 === e8 && (e8 = n8.rank - 1), e8 !== n8.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n8.rank + " and axis was " + e8);
        return vo(function(t5, n10) {
            var r14 = t5.max(e8, !0), o15 = t5.sub(r14), a11 = o15.toFloat().sub(o15.exp().sum(e8, !0).log());
            n10([
                a11
            ]);
            return {
                value: a11,
                gradFunc: function(t7, n11) {
                    var r15 = n11[0].exp();
                    return t7.sub(t7.sum(e8, !0).mul(r15));
                }
            };
        })(n8);
    }
}), xo = function() {
    function t1(t5, e8) {
        this.backend = t5, this.dataMover = e8, this.data = new WeakMap, this.dataIdsCount = 0;
    }
    return t1.prototype.get = function(t5) {
        return this.data.has(t5) || this.dataMover.moveData(this.backend, t5), this.data.get(t5);
    }, t1.prototype.set = function(t5, e8) {
        this.dataIdsCount++, this.data.set(t5, e8);
    }, t1.prototype.has = function(t5) {
        return this.data.has(t5);
    }, t1.prototype.delete = function(t5) {
        return this.dataIdsCount--, this.data.delete(t5);
    }, t1.prototype.numDataIds = function() {
        return this.dataIdsCount;
    }, t1;
}(), bo = function() {
    function t1() {
    }
    return t1.prototype.time = function(t5) {
        return wo("time");
    }, t1.prototype.read = function(t5) {
        return wo("read");
    }, t1.prototype.readSync = function(t5) {
        return wo("readSync");
    }, t1.prototype.numDataIds = function() {
        return wo("numDataIds");
    }, t1.prototype.disposeData = function(t5) {
        return wo("disposeData");
    }, t1.prototype.write = function(t5, e8, n8) {
        return wo("write");
    }, t1.prototype.move = function(t5, e8, n8, r14) {
        return wo("move");
    }, t1.prototype.memory = function() {
        return wo("memory");
    }, t1.prototype.floatPrecision = function() {
        return wo("floatPrecision");
    }, t1.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 0.0000001 : 0.0001;
    }, t1.prototype.batchMatMul = function(t5, e8, n8, r14) {
        return wo("batchMatMul");
    }, t1.prototype.fusedBatchMatMul = function(t5) {
        t5.a, t5.b, t5.transposeA, t5.transposeB, t5.bias, t5.activation, t5.preluActivationWeights;
        return wo("fusedBatchMatMul");
    }, t1.prototype.slice = function(t5, e8, n8) {
        return wo("slice");
    }, t1.prototype.stridedSlice = function(t5, e8, n8, r14) {
        return wo("stridedSlice");
    }, t1.prototype.unstack = function(t5, e8) {
        return wo("unstack");
    }, t1.prototype.reverse = function(t5, e8) {
        return wo("reverse");
    }, t1.prototype.concat = function(t5, e8) {
        return wo("concat");
    }, t1.prototype.neg = function(t5) {
        return wo("neg");
    }, t1.prototype.add = function(t5, e8) {
        return wo("add");
    }, t1.prototype.addN = function(t5) {
        return wo("addN");
    }, t1.prototype.subtract = function(t5, e8) {
        return wo("subtract");
    }, t1.prototype.multiply = function(t5, e8) {
        return wo("multiply");
    }, t1.prototype.realDivide = function(t5, e8) {
        return wo("realDivide");
    }, t1.prototype.floorDiv = function(t5, e8) {
        return wo("floorDiv");
    }, t1.prototype.sum = function(t5, e8) {
        return wo("sum");
    }, t1.prototype.prod = function(t5, e8) {
        return wo("prod");
    }, t1.prototype.unsortedSegmentSum = function(t5, e8, n8) {
        return wo("unsortedSegmentSum");
    }, t1.prototype.argMin = function(t5, e8) {
        return wo("argMin");
    }, t1.prototype.argMax = function(t5, e8) {
        return wo("argMax");
    }, t1.prototype.equal = function(t5, e8) {
        return wo("equal");
    }, t1.prototype.notEqual = function(t5, e8) {
        return wo("notEqual");
    }, t1.prototype.less = function(t5, e8) {
        return wo("less");
    }, t1.prototype.lessEqual = function(t5, e8) {
        return wo("lessEqual");
    }, t1.prototype.greater = function(t5, e8) {
        return wo("greater");
    }, t1.prototype.greaterEqual = function(t5, e8) {
        return wo("greaterEqual");
    }, t1.prototype.logicalNot = function(t5) {
        return wo("logicalNot");
    }, t1.prototype.logicalAnd = function(t5, e8) {
        return wo("logicalAnd");
    }, t1.prototype.logicalOr = function(t5, e8) {
        return wo("logicalOr");
    }, t1.prototype.where = function(t5) {
        return wo("where");
    }, t1.prototype.select = function(t5, e8, n8) {
        return wo("select");
    }, t1.prototype.topk = function(t5, e8, n8) {
        return wo("topk");
    }, t1.prototype.min = function(t5, e8) {
        return wo("min");
    }, t1.prototype.minimum = function(t5, e8) {
        return wo("minimum");
    }, t1.prototype.mod = function(t5, e8) {
        return wo("mod");
    }, t1.prototype.max = function(t5, e8) {
        return wo("max");
    }, t1.prototype.maximum = function(t5, e8) {
        return wo("maximum");
    }, t1.prototype.all = function(t5, e8) {
        return wo("all");
    }, t1.prototype.any = function(t5, e8) {
        return wo("any");
    }, t1.prototype.squaredDifference = function(t5, e8) {
        return wo("squaredDifference");
    }, t1.prototype.ceil = function(t5) {
        return wo("ceil");
    }, t1.prototype.floor = function(t5) {
        return wo("floor");
    }, t1.prototype.round = function(t5) {
        return wo("round");
    }, t1.prototype.sign = function(t5) {
        return wo("sign");
    }, t1.prototype.isNaN = function(t5) {
        return wo("isNaN");
    }, t1.prototype.isInf = function(t5) {
        return wo("isInf");
    }, t1.prototype.isFinite = function(t5) {
        return wo("isFinite");
    }, t1.prototype.pow = function(t5, e8) {
        return wo("pow");
    }, t1.prototype.exp = function(t5) {
        return wo("exp");
    }, t1.prototype.expm1 = function(t5) {
        return wo("expm1");
    }, t1.prototype.softmax = function(t5, e8) {
        return wo("softmax");
    }, t1.prototype.log = function(t5) {
        return wo("log");
    }, t1.prototype.log1p = function(t5) {
        return wo("log1p");
    }, t1.prototype.sqrt = function(t5) {
        return wo("sqrt");
    }, t1.prototype.rsqrt = function(t5) {
        return wo("rsqrt");
    }, t1.prototype.square = function(t5) {
        return wo("square");
    }, t1.prototype.reciprocal = function(t5) {
        return wo("reciprocal");
    }, t1.prototype.relu = function(t5) {
        return wo("relu");
    }, t1.prototype.relu6 = function(t5) {
        return wo("relu6");
    }, t1.prototype.prelu = function(t5, e8) {
        return wo("prelu");
    }, t1.prototype.elu = function(t5) {
        return wo("elu");
    }, t1.prototype.eluDer = function(t5, e8) {
        return wo("eluDer");
    }, t1.prototype.selu = function(t5) {
        return wo("selu");
    }, t1.prototype.int = function(t5) {
        return wo("int");
    }, t1.prototype.clip = function(t5, e8, n8) {
        return wo("clip");
    }, t1.prototype.abs = function(t5) {
        return wo("abs");
    }, t1.prototype.complexAbs = function(t5) {
        return wo("complexAbs");
    }, t1.prototype.sigmoid = function(t5) {
        return wo("sigmoid");
    }, t1.prototype.softplus = function(t5) {
        return wo("softplus");
    }, t1.prototype.sin = function(t5) {
        return wo("sin");
    }, t1.prototype.cos = function(t5) {
        return wo("cos");
    }, t1.prototype.tan = function(t5) {
        return wo("tan");
    }, t1.prototype.asin = function(t5) {
        return wo("asin");
    }, t1.prototype.acos = function(t5) {
        return wo("acos");
    }, t1.prototype.atan = function(t5) {
        return wo("atan");
    }, t1.prototype.atan2 = function(t5, e8) {
        return wo("atan2");
    }, t1.prototype.sinh = function(t5) {
        return wo("sinh");
    }, t1.prototype.cosh = function(t5) {
        return wo("cosh");
    }, t1.prototype.tanh = function(t5) {
        return wo("tanh");
    }, t1.prototype.asinh = function(t5) {
        return wo("asinh");
    }, t1.prototype.acosh = function(t5) {
        return wo("acosh");
    }, t1.prototype.atanh = function(t5) {
        return wo("atanh");
    }, t1.prototype.erf = function(t5) {
        return wo("erf");
    }, t1.prototype.step = function(t5, e8) {
        return wo("step");
    }, t1.prototype.fusedConv2d = function(t5) {
        t5.input, t5.filter, t5.convInfo, t5.bias, t5.activation, t5.preluActivationWeights;
        return wo("fusedConv2d");
    }, t1.prototype.conv2d = function(t5, e8, n8) {
        return wo("conv2d");
    }, t1.prototype.conv2dDerInput = function(t5, e8, n8) {
        return wo("conv2dDerInput");
    }, t1.prototype.conv2dDerFilter = function(t5, e8, n8) {
        return wo("conv2dDerFilter");
    }, t1.prototype.fusedDepthwiseConv2D = function(t5) {
        t5.input, t5.filter, t5.convInfo, t5.bias, t5.activation, t5.preluActivationWeights;
        return wo("fusedDepthwiseConv2D");
    }, t1.prototype.depthwiseConv2D = function(t5, e8, n8) {
        return wo("depthwiseConv2D");
    }, t1.prototype.depthwiseConv2DDerInput = function(t5, e8, n8) {
        return wo("depthwiseConv2DDerInput");
    }, t1.prototype.depthwiseConv2DDerFilter = function(t5, e8, n8) {
        return wo("depthwiseConv2DDerFilter");
    }, t1.prototype.conv3d = function(t5, e8, n8) {
        return wo("conv3d");
    }, t1.prototype.conv3dDerInput = function(t5, e8, n8) {
        return wo("conv3dDerInput");
    }, t1.prototype.conv3dDerFilter = function(t5, e8, n8) {
        return wo("conv3dDerFilter");
    }, t1.prototype.maxPool = function(t5, e8) {
        return wo("maxPool");
    }, t1.prototype.maxPoolBackprop = function(t5, e8, n8, r14) {
        return wo("maxPoolBackprop");
    }, t1.prototype.avgPool = function(t5, e8) {
        return wo("avgPool");
    }, t1.prototype.avgPoolBackprop = function(t5, e8, n8) {
        return wo("avgPoolBackprop");
    }, t1.prototype.avgPool3d = function(t5, e8) {
        return wo("avgPool3d");
    }, t1.prototype.avgPool3dBackprop = function(t5, e8, n8) {
        return wo("avgPool3dBackprop");
    }, t1.prototype.maxPool3d = function(t5, e8) {
        return wo("maxPool3d");
    }, t1.prototype.maxPool3dBackprop = function(t5, e8, n8, r14) {
        return wo("maxPool3dBackprop");
    }, t1.prototype.reshape = function(t5, e8) {
        return wo("reshape");
    }, t1.prototype.cast = function(t5, e8) {
        return wo("cast");
    }, t1.prototype.tile = function(t5, e8) {
        return wo("tile");
    }, t1.prototype.pad = function(t5, e8, n8) {
        return wo("pad");
    }, t1.prototype.transpose = function(t5, e8) {
        return wo("transpose");
    }, t1.prototype.gather = function(t5, e8, n8) {
        return wo("gather");
    }, t1.prototype.gatherND = function(t5, e8) {
        return wo("gatherND");
    }, t1.prototype.scatterND = function(t5, e8, n8) {
        return wo("scatterND");
    }, t1.prototype.batchToSpaceND = function(t5, e8, n8) {
        return wo("batchToSpaceND");
    }, t1.prototype.spaceToBatchND = function(t5, e8, n8) {
        return wo("spaceToBatchND");
    }, t1.prototype.resizeBilinear = function(t5, e8, n8, r14) {
        return wo("resizeBilinear");
    }, t1.prototype.resizeBilinearBackprop = function(t5, e8, n8) {
        return wo("resizeBilinearBackprop");
    }, t1.prototype.resizeNearestNeighbor = function(t5, e8, n8, r14) {
        return wo("resizeNearestNeighbor");
    }, t1.prototype.resizeNearestNeighborBackprop = function(t5, e8, n8) {
        return wo("resizeNearestNeighborBackprop");
    }, t1.prototype.batchNormalization = function(t5, e8, n8, r14, o15, a11) {
        return wo("batchNormalization");
    }, t1.prototype.localResponseNormalization4D = function(t5, e8, n8, r14, o15) {
        return wo("localResponseNormalization4D");
    }, t1.prototype.LRNGrad = function(t5, e8, n8, r14, o15, a11, i8) {
        return wo("LRNGrad");
    }, t1.prototype.multinomial = function(t5, e8, n8, r14) {
        return wo("multinomial");
    }, t1.prototype.oneHot = function(t5, e8, n8, r14) {
        return wo("oneHot");
    }, t1.prototype.cumsum = function(t5, e8, n8, r14) {
        return wo("cumsum");
    }, t1.prototype.nonMaxSuppression = function(t5, e8, n8, r14, o15) {
        return wo("nonMaxSuppression");
    }, t1.prototype.fft = function(t5) {
        return wo("fft");
    }, t1.prototype.ifft = function(t5) {
        return wo("ifft");
    }, t1.prototype.complex = function(t5, e8) {
        return wo("complex");
    }, t1.prototype.real = function(t5) {
        return wo("real");
    }, t1.prototype.imag = function(t5) {
        return wo("imag");
    }, t1.prototype.cropAndResize = function(t5, e8, n8, r14, o15, a11) {
        return wo("cropAndResize");
    }, t1.prototype.depthToSpace = function(t5, e8, n8) {
        return wo("depthToSpace");
    }, t1.prototype.split = function(t5, e8, n8) {
        return wo("split");
    }, t1.prototype.sparseToDense = function(t5, e8, n8, r14) {
        return wo("sparseToDense");
    }, t1.prototype.diag = function(t5) {
        return wo("diag");
    }, t1.prototype.fill = function(t5, e8, n8) {
        return wo("fill");
    }, t1.prototype.onesLike = function(t5) {
        return wo("onesLike");
    }, t1.prototype.zerosLike = function(t5) {
        return wo("zerosLike");
    }, t1.prototype.linspace = function(t5, e8, n8) {
        return wo("linspace");
    }, t1.prototype.dispose = function() {
        return wo("dispose");
    }, t1;
}();
function wo(t1) {
    throw new Error("'" + t1 + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function Co(t1, e8) {
    for(var n8 = t1.length, r14 = [], o15 = 0; o15 < n8; o15++){
        var a11 = n8 - 1 - o15, i8 = t1[a11] || 1;
        (e8[e8.length - 1 - o15] || 1) > 1 && 1 === i8 && r14.unshift(a11);
    }
    return r14;
}
function Eo(t1, e8) {
    for(var n8 = [], r14 = 0; r14 < e8.length; r14++){
        var o15 = t1[t1.length - r14 - 1], a12 = e8.length - r14 - 1, i9 = e8[a12];
        (null == o15 || 1 === o15 && i9 > 1) && n8.unshift(a12);
    }
    return n8;
}
function Ro(t1, e8) {
    for(var n8 = [], r14 = Math.max(t1.length, e8.length), o16 = 0; o16 < r14; o16++){
        var a13 = t1[t1.length - o16 - 1];
        null == a13 && (a13 = 1);
        var i10 = e8[e8.length - o16 - 1];
        if (null == i10 && (i10 = 1), 1 === a13) n8.unshift(i10);
        else if (1 === i10) n8.unshift(a13);
        else {
            if (a13 !== i10) throw Error("Operands could not be broadcast together with shapes " + t1 + " and " + e8 + ".");
            n8.unshift(a13);
        }
    }
    return n8;
}
function Io(t1, e8, n8, r14, o16, a14, i11) {
    (void 0) === i11 && (i11 = "channelsLast");
    var s12, u6 = To(e8), c4 = u6[0], l3 = u6[1];
    if ("channelsLast" === i11) s12 = [
        c4,
        l3,
        t1[3],
        t1[3]
    ];
    else {
        if ("channelsFirst" !== i11) throw new Error("Unknown dataFormat " + i11);
        s12 = [
            c4,
            l3,
            t1[1],
            t1[1]
        ];
    }
    return So(t1, s12, n8, r14, o16, a14, !1, i11);
}
function ko(t1, e8, n8, r14, o16, a14, i11) {
    (void 0) === i11 && (i11 = "NDHWC");
    var s12, u6, c4 = No(e8), l3 = c4[0], h2 = c4[1], f2 = c4[2];
    if ("NDHWC" === i11) u6 = "channelsLast", s12 = [
        l3,
        h2,
        f2,
        t1[4],
        t1[4]
    ];
    else {
        if ("NCDHW" !== i11) throw new Error("Unknown dataFormat " + i11);
        u6 = "channelsFirst", s12 = [
            l3,
            h2,
            f2,
            t1[1],
            t1[1]
        ];
    }
    return Ao(t1, s12, n8, r14, o16, !1, u6, a14);
}
function So(t1, e8, n8, r14, o16, a14, i11, s12) {
    (void 0) === i11 && (i11 = !1), (void 0) === s12 && (s12 = "channelsLast");
    var u6 = [
        -1,
        -1,
        -1,
        -1
    ], c4 = u6[0], l3 = u6[1], h2 = u6[2], f2 = u6[3];
    if ("channelsLast" === s12) c4 = t1[0], l3 = t1[1], h2 = t1[2], f2 = t1[3];
    else {
        if ("channelsFirst" !== s12) throw new Error("Unknown dataFormat " + s12);
        c4 = t1[0], f2 = t1[1], l3 = t1[2], h2 = t1[3];
    }
    var d3, p4 = e8[0], v3 = e8[1], m3 = e8[3], g3 = To(n8), y2 = g3[0], x3 = g3[1], b1 = To(r14), w1 = b1[0], E1 = b1[1], R1 = Fo(p4, w1), I1 = Fo(v3, E1), k1 = function(t5, e9, n10, r15, o17, a15, i12, s13) {
        var u7, c5, l4;
        if ("number" == typeof t5) {
            u7 = {
                top: t5,
                bottom: t5,
                left: t5,
                right: t5,
                type: 0 === t5 ? "VALID" : "NUMBER"
            };
            var h3 = function(t7, e10, n11, r17, o18) {
                null == r17 && (r17 = Do(t7, e10, n11));
                var a16 = t7[0], i13 = t7[1], s14 = _o((a16 - e10 + 2 * r17) / n11 + 1, o18);
                C(A(s14), function() {
                    return "The output # of rows (" + s14 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var u8 = _o((i13 - e10 + 2 * r17) / n11 + 1, o18);
                return C(A(u8), function() {
                    return "The output # of columns (" + u8 + ") must be an integer. Change the stride and/or zero pad parameters";
                }), [
                    s14,
                    u8
                ];
            }([
                e9,
                n10
            ], a15, r15, t5, s13);
            c5 = h3[0], l4 = h3[1];
        } else if ("same" === t5) {
            c5 = Math.ceil(e9 / r15), l4 = Math.ceil(n10 / o17);
            var f3 = Math.max(0, (c5 - 1) * r15 + a15 - e9), d4 = Math.max(0, (l4 - 1) * o17 + i12 - n10), p5 = Math.floor(f3 / 2), v4 = f3 - p5, m4 = Math.floor(d4 / 2);
            u7 = {
                top: p5,
                bottom: v4,
                left: m4,
                right: d4 - m4,
                type: "SAME"
            };
        } else {
            if ("valid" !== t5) throw Error("Unknown padding parameter: " + t5);
            u7 = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                type: "VALID"
            }, c5 = Math.ceil((e9 - a15 + 1) / r15), l4 = Math.ceil((n10 - i12 + 1) / o17);
        }
        return {
            padInfo: u7,
            outHeight: c5,
            outWidth: l4
        };
    }(o16, l3, h2, y2, x3, R1, I1, a14), S1 = k1.padInfo, D1 = k1.outHeight, T1 = k1.outWidth, N1 = i11 ? m3 * f2 : m3;
    return "channelsFirst" === s12 ? d3 = [
        c4,
        N1,
        D1,
        T1
    ] : "channelsLast" === s12 && (d3 = [
        c4,
        D1,
        T1,
        N1
    ]), {
        batchSize: c4,
        dataFormat: s12,
        inHeight: l3,
        inWidth: h2,
        inChannels: f2,
        outHeight: D1,
        outWidth: T1,
        outChannels: N1,
        padInfo: S1,
        strideHeight: y2,
        strideWidth: x3,
        filterHeight: p4,
        filterWidth: v3,
        effectiveFilterHeight: R1,
        effectiveFilterWidth: I1,
        dilationHeight: w1,
        dilationWidth: E1,
        inShape: t1,
        outShape: d3,
        filterShape: e8
    };
}
function Ao(t1, e8, n8, r14, o16, a14, i11, s12) {
    (void 0) === a14 && (a14 = !1), (void 0) === i11 && (i11 = "channelsLast");
    var u6 = [
        -1,
        -1,
        -1,
        -1,
        -1
    ], c4 = u6[0], l3 = u6[1], h2 = u6[2], f2 = u6[3], d3 = u6[4];
    if ("channelsLast" === i11) c4 = t1[0], l3 = t1[1], h2 = t1[2], f2 = t1[3], d3 = t1[4];
    else {
        if ("channelsFirst" !== i11) throw new Error("Unknown dataFormat " + i11);
        c4 = t1[0], d3 = t1[1], l3 = t1[2], h2 = t1[3], f2 = t1[4];
    }
    var p4, v3 = e8[0], m3 = e8[1], g3 = e8[2], y2 = e8[4], x3 = No(n8), b1 = x3[0], w1 = x3[1], E1 = x3[2], R1 = No(r14), I1 = R1[0], k1 = R1[1], S1 = R1[2], D1 = Fo(v3, I1), T1 = Fo(m3, k1), N1 = Fo(g3, S1), F1 = function(t5, e9, n10, r15, o17, a15, i12, s13, u7, c5, l4) {
        var h4, f4, d5, p6;
        if ("number" == typeof t5) {
            h4 = {
                top: t5,
                bottom: t5,
                left: t5,
                right: t5,
                front: t5,
                back: t5,
                type: 0 === t5 ? "VALID" : "NUMBER"
            };
            var v5 = function(t7, e10, n11, r17, o18, a16) {
                null == o18 && (o18 = Do(t7, e10, r17));
                var i13 = t7[0], s14 = t7[1], u8 = t7[2], c6 = _o((i13 - e10 + 2 * o18) / r17 + 1, a16);
                C(A(c6), function() {
                    return "The output # of depths (" + c6 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var l5 = _o((s14 - e10 + 2 * o18) / r17 + 1, a16);
                C(A(l5), function() {
                    return "The output # of rows (" + l5 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var h5 = _o((u8 - e10 + 2 * o18) / r17 + 1, a16);
                return C(A(h5), function() {
                    return "The output # of columns (" + h5 + ") must be an integer. Change the stride and/or zero pad parameters";
                }), [
                    c6,
                    l5,
                    h5,
                    n11
                ];
            }([
                e9,
                n10,
                r15,
                1
            ], s13, 1, o17, t5, l4);
            f4 = v5[0], d5 = v5[1], p6 = v5[2];
        } else if ("same" === t5) {
            f4 = Math.ceil(e9 / o17), d5 = Math.ceil(n10 / a15), p6 = Math.ceil(r15 / i12);
            var m5 = (f4 - 1) * o17 + s13 - e9, g4 = (d5 - 1) * a15 + u7 - n10, y3 = (p6 - 1) * i12 + c5 - r15, x4 = Math.floor(m5 / 2), b2 = m5 - x4, w2 = Math.floor(g4 / 2), E2 = g4 - w2, R2 = Math.floor(y3 / 2);
            h4 = {
                top: w2,
                bottom: E2,
                left: R2,
                right: y3 - R2,
                front: x4,
                back: b2,
                type: "SAME"
            };
        } else {
            if ("valid" !== t5) throw Error("Unknown padding parameter: " + t5);
            h4 = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                front: 0,
                back: 0,
                type: "VALID"
            }, f4 = Math.ceil((e9 - s13 + 1) / o17), d5 = Math.ceil((n10 - u7 + 1) / a15), p6 = Math.ceil((r15 - c5 + 1) / i12);
        }
        return {
            padInfo: h4,
            outDepth: f4,
            outHeight: d5,
            outWidth: p6
        };
    }(o16, l3, h2, f2, b1, w1, E1, D1, T1, N1, s12), _1 = F1.padInfo, O1 = F1.outDepth, M1 = F1.outHeight, B1 = F1.outWidth, P1 = a14 ? y2 * d3 : y2;
    return "channelsFirst" === i11 ? p4 = [
        c4,
        P1,
        O1,
        M1,
        B1
    ] : "channelsLast" === i11 && (p4 = [
        c4,
        O1,
        M1,
        B1,
        P1
    ]), {
        batchSize: c4,
        dataFormat: i11,
        inDepth: l3,
        inHeight: h2,
        inWidth: f2,
        inChannels: d3,
        outDepth: O1,
        outHeight: M1,
        outWidth: B1,
        outChannels: P1,
        padInfo: _1,
        strideDepth: b1,
        strideHeight: w1,
        strideWidth: E1,
        filterDepth: v3,
        filterHeight: m3,
        filterWidth: g3,
        effectiveFilterDepth: D1,
        effectiveFilterHeight: T1,
        effectiveFilterWidth: N1,
        dilationDepth: I1,
        dilationHeight: k1,
        dilationWidth: S1,
        inShape: t1,
        outShape: p4,
        filterShape: e8
    };
}
function Do(t1, e8, n8, r14) {
    (void 0) === r14 && (r14 = 1);
    var o16 = Fo(e8, r14);
    return Math.floor((t1[0] * (n8 - 1) - n8 + o16) / 2);
}
function To(t1) {
    return "number" == typeof t1 ? [
        t1,
        t1,
        t1
    ] : 2 === t1.length ? [
        t1[0],
        t1[1],
        1
    ] : t1;
}
function No(t1) {
    return "number" == typeof t1 ? [
        t1,
        t1,
        t1
    ] : t1;
}
function Fo(t1, e8) {
    return e8 <= 1 ? t1 : t1 + (t1 - 1) * (e8 - 1);
}
function _o(t1, e8) {
    if (!e8) return t1;
    switch(e8){
        case "round":
            return Math.round(t1);
        case "ceil":
            return Math.ceil(t1);
        case "floor":
            return Math.floor(t1);
        default:
            throw new Error("Unknown roundingMode " + e8);
    }
}
function Oo(t1) {
    var e8 = To(t1), n8 = e8[0], r14 = e8[1], o16 = e8[2];
    return 1 === n8 && 1 === r14 && 1 === o16;
}
function Mo(t1, e8) {
    return Oo(t1) || Oo(e8);
}
function Bo(t1) {
    if ("NHWC" === t1) return "channelsLast";
    if ("NCHW" === t1) return "channelsFirst";
    throw new Error("Unknown dataFormat " + t1);
}
function Po(t1, e8, n8) {
    if ("complex64" === e8) {
        if ("complex64" === t1.dtype) return t1.clone();
        var r14 = Gn(t1.shape), o16 = t1.toFloat(), a14 = n8.complex(o16, r14);
        return r14.dispose(), o16.dispose(), a14;
    }
    if (!U(t1.dtype, e8)) return Lt.makeTensorFromDataId(t1.dataId, t1.shape, e8);
    if ("complex64" === t1.dtype) {
        var i11 = n8.real(t1);
        a14 = i11.cast(e8);
        return i11.dispose(), a14;
    }
    if ("int32" === e8) return n8.int(t1);
    if ("bool" === e8) {
        var s12 = On(0, t1.dtype);
        a14 = n8.notEqual(t1, s12);
        return s12.dispose(), a14;
    }
    throw new Error("Error in Cast: failed to cast " + t1.dtype + " to " + e8);
}
function Lo(t1, e8) {
    return Lt.makeTensorFromDataId(t1.dataId, e8, t1.dtype);
}
function Wo(t1, e8, n8) {
    var r15 = (e8 - t1) / (n8 - 1), o17 = tt(n8, "float32");
    o17[0] = t1;
    for(var a15 = 1; a15 < o17.length; a15++)o17[a15] = o17[a15 - 1] + r15;
    return Mn(o17, "float32");
}
var Uo = Object.freeze({
    castTensor: Po,
    reshapeTensor: Lo,
    linspaceImpl: Wo,
    upcastType: Dt,
    axesAreInnerMostDims: yn,
    combineLocations: xn,
    computeOutAndReduceShapes: bn,
    expandShapeToKeepDim: wn,
    assertAxesAreInnerMostDims: Cn,
    getAxesPermutation: En,
    getUndoAxesPermutation: Rn,
    getInnerMostAxes: In,
    getBroadcastDims: Co,
    getReductionAxes: Eo,
    assertAndGetBroadcastShape: Ro,
    assertParamsConsistent: kn,
    computeOutShape: Sn,
    computePool2DInfo: Io,
    computePool3DInfo: ko,
    computeConv2DInfo: So,
    computeConv3DInfo: Ao,
    computeDefaultPad: Do,
    tupleValuesAreOne: Oo,
    eitherStridesOrDilationsAreOne: Mo,
    convertConv2DDataFormat: Bo,
    PARALLELIZE_THRESHOLD: Yr,
    computeOptimalWindowSize: $r
});
function Vo(t1, e8) {
    if (t1.length !== e8.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t1.length + ", imag: " + e8.length + ".");
    for(var n8 = new Float32Array(2 * t1.length), r15 = 0; r15 < n8.length; r15 += 2)n8[r15] = t1[r15 / 2], n8[r15 + 1] = e8[r15 / 2];
    return n8;
}
function zo(t1, e8) {
    return {
        real: t1[2 * e8],
        imag: t1[2 * e8 + 1]
    };
}
function Go(t1, e8, n8, r15) {
    t1[2 * r15] = e8, t1[2 * r15 + 1] = n8;
}
function Ho(t1, e8, n8) {
    var r15 = (n8 ? 2 : -2) * Math.PI * (t1 / e8);
    return {
        real: Math.cos(r15),
        imag: Math.sin(r15)
    };
}
function qo(t1, e8, n8) {
    var r15 = function(t5, e9, n10) {
        return (function(t7, e10, n11) {
            var r17 = 0, o17 = t7.length, a15 = 0, i12 = !1;
            for(; r17 < o17;){
                var s13 = n11(e10, t7[a15 = r17 + (o17 - r17 >>> 1)]);
                s13 > 0 ? r17 = a15 + 1 : (o17 = a15, i12 = !s13);
            }
            return i12 ? r17 : -r17 - 1;
        })(t5, e9, n10 || Ko);
    }(t1, e8, n8), o17 = r15 < 0 ? -(r15 + 1) : r15;
    t1.splice(o17, 0, e8);
}
function Ko(t1, e8) {
    return t1 > e8 ? 1 : t1 < e8 ? -1 : 0;
}
function jo(t1, e8, n8, r15, o17) {
    return Yo(t1, e8, n8, r15, o17, 0).selectedIndices;
}
function Xo(t1, e8, n8, r15, o17, a15) {
    var i12 = Yo(t1, e8, n8, r15, o17, a15, !0);
    return i12.numValidOutputs.dispose(), {
        selectedIndices: i12.selectedIndices,
        selectedScores: i12.selectedScores
    };
}
function Yo(t1, e8, n8, r15, o17, a15, i12, s14) {
    (void 0) === i12 && (i12 = !1), (void 0) === s14 && (s14 = !1);
    for(var u6 = Array.from(e8).map(function(t5, e9) {
        return {
            score: t5,
            boxIndex: e9,
            suppressBeginIndex: 0
        };
    }).filter(function(t5) {
        return t5.score > o17;
    }).sort(Jo), c4 = a15 > 0 ? -0.5 / a15 : 0, l3 = [], h2 = []; l3.length < n8 && u6.length > 0;){
        var f2 = u6.pop(), d3 = f2.score, p4 = f2.boxIndex, v3 = f2.suppressBeginIndex;
        if (d3 < o17) break;
        for(var m3 = !1, g3 = l3.length - 1; g3 >= v3; --g3){
            var y2 = $o(t1, p4, l3[g3]);
            if (y2 >= r15) {
                m3 = !0;
                break;
            }
            if (f2.score = f2.score * Qo(r15, c4, y2), f2.score <= o17) break;
        }
        f2.suppressBeginIndex = l3.length, m3 || (f2.score === d3 ? (l3.push(p4), h2.push(f2.score)) : f2.score > o17 && qo(u6, f2, Jo));
    }
    var x3 = l3.length;
    return s14 && (l3.fill(0, x3), h2.fill(0, x3)), {
        selectedIndices: Mn(l3, "int32"),
        selectedScores: Mn(h2, "float32"),
        numValidOutputs: On(x3, "int32")
    };
}
function $o(t1, e8, n8) {
    var r15 = t1.subarray(4 * e8, 4 * e8 + 4), o17 = t1.subarray(4 * n8, 4 * n8 + 4), a15 = Math.min(r15[0], r15[2]), i12 = Math.min(r15[1], r15[3]), s14 = Math.max(r15[0], r15[2]), u6 = Math.max(r15[1], r15[3]), c4 = Math.min(o17[0], o17[2]), l3 = Math.min(o17[1], o17[3]), h2 = Math.max(o17[0], o17[2]), f4 = Math.max(o17[1], o17[3]), d5 = (s14 - a15) * (u6 - i12), p6 = (h2 - c4) * (f4 - l3);
    if (d5 <= 0 || p6 <= 0) return 0;
    var v6 = Math.max(a15, c4), m6 = Math.max(i12, l3), g5 = Math.min(s14, h2), y4 = Math.min(u6, f4), x3 = Math.max(g5 - v6, 0) * Math.max(y4 - m6, 0);
    return x3 / (d5 + p6 - x3);
}
function Qo(t1, e8, n8) {
    var r15 = Math.exp(e8 * n8 * n8);
    return n8 <= t1 ? r15 : 0;
}
function Jo(t1, e8) {
    return t1.score - e8.score || t1.score === e8.score && e8.boxIndex - t1.boxIndex;
}
function Zo(t1, e8, n8) {
    var r15 = new Array(t1.rank).fill(0), o17 = t1.shape.slice();
    return e8.map(function(e9) {
        o17[n8] = e9;
        var a15 = t1.slice(r15, o17);
        return r15[n8] += e9, a15;
    });
}
function ta(t1, e8) {
    for(var n8 = new Array(t1.rank), r15 = 0; r15 < n8.length; r15++)n8[r15] = t1.shape[r15] * e8[r15];
    var o17 = dr(n8, t1.dtype);
    for(r15 = 0; r15 < o17.values.length; ++r15){
        for(var a15 = o17.indexToLoc(r15), i12 = new Array(t1.rank), s14 = 0; s14 < i12.length; s14++)i12[s14] = a15[s14] % t1.shape[s14];
        var u6 = t1.locToIndex(i12);
        o17.values[r15] = t1.values[u6];
    }
    return o17.toTensor();
}
function ea(t1, e8, n8, r15, o17) {
    for(var a16 = e8[e8.length - 1], i13 = [
        t1.length / a16,
        a16
    ], s15 = i13[0], u7 = i13[1], c4 = B(n8, s15 * r15), l3 = B("int32", s15 * r15), h2 = 0; h2 < s15; h2++){
        for(var f4 = h2 * u7, d5 = t1.subarray(f4, f4 + u7), p6 = [], v6 = 0; v6 < d5.length; v6++)p6.push({
            value: d5[v6],
            index: v6
        });
        p6.sort(function(t5, e9) {
            return e9.value - t5.value;
        });
        var m6 = h2 * r15, g5 = c4.subarray(m6, m6 + r15), y4 = l3.subarray(m6, m6 + r15);
        for(v6 = 0; v6 < r15; v6++)g5[v6] = p6[v6].value, y4[v6] = p6[v6].index;
    }
    var x3 = e8.slice();
    return x3[x3.length - 1] = r15, [
        Fn(c4, x3, n8),
        Fn(l3, x3, "int32")
    ];
}
function na(t1, e8) {
    for(var n8 = [], r15 = 0; r15 < e8.length; r15++)e8[r15] && n8.push(r15);
    var o17 = dr(t1, "int32"), a16 = dr([
        n8.length,
        t1.length
    ], "int32");
    for(r15 = 0; r15 < n8.length; r15++){
        var i13 = o17.indexToLoc(n8[r15]), s15 = r15 * t1.length;
        a16.values.set(i13, s15);
    }
    return a16.toTensor();
}
var ra = function(t1, e8) {
    this.outputShape = [], this.outputShape = t1, this.variableNames = e8.map(function(t5, e9) {
        return "T" + e9;
    });
    var n8 = [];
    this.variableNames.forEach(function(t5) {
        n8.push("float v" + t5 + " = get" + t5 + "AtOutCoords();");
    });
    var r15 = this.variableNames.map(function(t5) {
        return "v" + t5;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n8.join("\n        ") + "\n\n        float result = " + r15 + ";\n        setOutput(result);\n      }\n    ";
}, oa = function(t1, e8) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t1, this.variableNames = e8.map(function(t5, e9) {
        return "T" + e9;
    });
    var n8 = [];
    this.variableNames.forEach(function(t5) {
        n8.push("vec4 v" + t5 + " = get" + t5 + "AtOutCoords();");
    });
    var r15 = this.variableNames.map(function(t5) {
        return "v" + t5;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n8.join("\n        ") + "\n\n        vec4 result = " + r15 + ";\n        setOutput(result);\n      }\n    ";
}, aa = function(t1, e8, n8) {
    this.variableNames = [
        "A"
    ];
    var r15 = t1.windowSize, o17 = t1.batchSize, a16 = t1.inSize, i14 = Math.ceil(a16 / r15);
    n8 || this.variableNames.push("bestIndicesA"), this.outputShape = [
        o17,
        i14
    ];
    var s16 = "max" === e8 ? ">" : "<", u7 = n8 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r15 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r15 + "; i++) {\n          int inIdx = " + u7 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s16 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
};
function ia(t1, e8) {
    return [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, e8).map(function(e9) {
        return t1 + "." + e9;
    });
}
function sa(t1, e8) {
    return 1 === e8 ? [
        t1
    ] : ia(t1, e8);
}
function ua() {
    var t1, e8, n8, r15, o17, a16, s16, u7, c4, l3;
    return 2 === i15().getNumber("WEBGL_VERSION") ? (t1 = "#version 300 es", e8 = "in", n8 = "out", r15 = "in", o17 = "texture", a16 = "outputColor", s16 = "out vec4 outputColor;", u7 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c4 = "", l3 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t1 = "", e8 = "attribute", n8 = "varying", r15 = "varying", o17 = "texture2D", a16 = "gl_FragColor", s16 = "", u7 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c4 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l3 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
        version: t1,
        attribute: e8,
        varyingVs: n8,
        varyingFs: r15,
        texture2D: o17,
        output: a16,
        defineOutput: s16,
        defineSpecialNaN: u7,
        defineSpecialInf: c4,
        defineRound: l3
    };
}
function ca(t1, e8, n8) {
    (void 0) === n8 && (n8 = "index");
    var r15 = $(e8);
    return r15.map(function(e9, o17) {
        return "int " + t1[o17] + " = " + n8 + " / " + e9 + "; " + (o17 === r15.length - 1 ? "int " + t1[o17 + 1] + " = " + n8 + " - " + t1[o17] + " * " + e9 : "index -= " + t1[o17] + " * " + e9) + ";";
    }).join("");
}
function la(t1) {
    var e8 = $(t1).map(function(t5) {
        return t5.toString();
    });
    return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e8[0] + " + coords.y * " + e8[1] + " + coords.z;\n  }\n";
}
var ha = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
function fa(t1, e8, n8, r15) {
    var o17 = [];
    t1.forEach(function(t5) {
        var e9 = k(t5.shapeInfo.logicalShape);
        t5.shapeInfo.isUniform ? o17.push("uniform float " + t5.name + (e9 > 1 ? "[" + e9 + "]" : "") + ";") : (o17.push("uniform sampler2D " + t5.name + ";"), o17.push("uniform int offset" + t5.name + ";"));
    });
    var a16, i14, s16 = o17.join("\n"), u7 = t1.map(function(t5) {
        return (function(t7, e9, n10) {
            (void 0) === n10 && (n10 = !1);
            var r17 = "";
            r17 += n10 ? pa(t7) : da(t7);
            var o18 = t7.shapeInfo.logicalShape, a17 = e9.logicalShape;
            o18.length <= a17.length && (r17 += n10 ? (function(t8, e10) {
                var n11, r18 = t8.name, o19 = r18.charAt(0).toUpperCase() + r18.slice(1), a18 = "get" + o19 + "AtOutCoords", i15 = t8.shapeInfo.logicalShape.length, s17 = e10.logicalShape.length, u8 = Co(t8.shapeInfo.logicalShape, e10.logicalShape), c4 = wa(s17), l3 = s17 - i15, h2 = [
                    "x",
                    "y",
                    "z",
                    "w",
                    "u",
                    "v"
                ];
                n11 = 0 === i15 ? "" : s17 < 2 && u8.length >= 1 ? "coords = 0;" : u8.map(function(t9) {
                    return "coords." + h2[t9 + l3] + " = 0;";
                }).join("\n");
                var f5 = "";
                f5 = s17 < 2 && i15 > 0 ? "coords" : t8.shapeInfo.logicalShape.map(function(t9, e11) {
                    return "coords." + h2[e11 + l3];
                }).join(", ");
                var d6 = "return outputValue;", p7 = 1 === k(t8.shapeInfo.logicalShape), v7 = 1 === k(e10.logicalShape);
                if (1 !== i15 || p7 || v7) {
                    if (p7 && !v7) d6 = 1 === s17 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                    else if (u8.length) {
                        var m7 = i15 - 2, g6 = i15 - 1;
                        u8.indexOf(m7) > -1 && u8.indexOf(g6) > -1 ? d6 = "return vec4(outputValue.x);" : u8.indexOf(m7) > -1 ? d6 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u8.indexOf(g6) > -1 && (d6 = "return vec4(outputValue.xx, outputValue.zz);");
                    }
                } else d6 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                return "\n    vec4 " + a18 + "() {\n      " + c4 + " coords = getOutputCoords();\n      " + n11 + "\n      vec4 outputValue = get" + o19 + "(" + f5 + ");\n      " + d6 + "\n    }\n  ";
            })(t7, e9) : (function(t8, e10) {
                var n11 = t8.name, r18 = n11.charAt(0).toUpperCase() + n11.slice(1), o19 = "get" + r18 + "AtOutCoords", a18 = e10.texShape, i15 = t8.shapeInfo.texShape, s17 = t8.shapeInfo.logicalShape.length, u8 = e10.logicalShape.length;
                if (!t8.shapeInfo.isUniform && s17 === u8 && null == t8.shapeInfo.flatOffset && S(i15, a18)) return "\n      float " + o19 + "() {\n        return sampleTexture(" + n11 + ", resultUV);\n      }\n    ";
                var c4, l3 = wa(u8), h2 = Co(t8.shapeInfo.logicalShape, e10.logicalShape), f5 = u8 - s17, d6 = [
                    "x",
                    "y",
                    "z",
                    "w",
                    "u",
                    "v"
                ];
                c4 = 0 === s17 ? "" : u8 < 2 && h2.length >= 1 ? "coords = 0;" : h2.map(function(t9) {
                    return "coords." + d6[t9 + f5] + " = 0;";
                }).join("\n");
                var p7 = "";
                p7 = u8 < 2 && s17 > 0 ? "coords" : t8.shapeInfo.logicalShape.map(function(t9, e11) {
                    return "coords." + d6[e11 + f5];
                }).join(", ");
                return "\n    float " + o19 + "() {\n      " + l3 + " coords = getOutputCoords();\n      " + c4 + "\n      return get" + r18 + "(" + p7 + ");\n    }\n  ";
            })(t7, e9));
            return r17;
        })(t5, e8, r15);
    }).join("\n"), c4 = e8.texShape, l3 = ua(), h2 = function(t5) {
        return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t5.texture2D + "(textureSampler, uv).r;\n    }\n  ";
    }(l3), f5 = function(t5) {
        return t5.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t5.varyingFs + " vec2 resultUV;\n    " + t5.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t5.defineSpecialNaN + "\n    " + t5.defineSpecialInf + "\n    " + t5.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + va + "\n    " + ma + "\n    " + ga + "\n  ";
    }(l3);
    return e8.isPacked ? (a16 = (function(t5, e9) {
        switch(t5.length){
            case 0:
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
                return (function(t7, e10) {
                    var n10 = [
                        Math.ceil(e10[0] / 2),
                        Math.ceil(e10[1] / 2)
                    ];
                    if (1 === n10[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n10[1] + ".0);\n      }\n    ";
                    if (1 === n10[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n10[0] + ".0);\n      }\n    ";
                    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n10[0] + ", " + n10[1] + "));\n      return 2 * (resTexRC.x * " + n10[1] + " + resTexRC.y);\n    }\n  ";
                })(0, e9);
            case 2:
                return (function(t7, e10) {
                    var n10 = [
                        Math.ceil(e10[0] / 2),
                        Math.ceil(e10[1] / 2)
                    ];
                    if (S(t7, e10)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n10[0] + ", " + n10[1] + "));\n      }\n    ";
                    var r17 = Math.ceil(t7[1] / 2);
                    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n10[0] + ", " + n10[1] + "));\n\n      int index = resTexRC.x * " + n10[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r17 + ");\n      int c = imod(index, " + r17 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
                })(t5, e9);
            case 3:
                return n11 = t5, r18 = e9, o18 = [
                    Math.ceil(r18[0] / 2),
                    Math.ceil(r18[1] / 2)
                ], a18 = Math.ceil(n11[2] / 2), i16 = a18 * Math.ceil(n11[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o18[0] + ", " + o18[1] + "));\n      int index = resTexRC.x * " + o18[1] + " + resTexRC.y;\n\n      int b = index / " + i16 + ";\n      index -= b * " + i16 + ";\n\n      int r = 2 * (index / " + a18 + ");\n      int c = imod(index, " + a18 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
            default:
                return (function(t7, e10) {
                    for(var n11 = [
                        Math.ceil(e10[0] / 2),
                        Math.ceil(e10[1] / 2)
                    ], r18 = Math.ceil(t7[t7.length - 1] / 2), o18 = r18 * Math.ceil(t7[t7.length - 2] / 2), a18 = o18, i16 = "", s17 = "b, r, c", u8 = 2; u8 < t7.length - 1; u8++)a18 *= t7[t7.length - u8 - 1], i16 = "\n      int b" + u8 + " = index / " + a18 + ";\n      index -= b" + u8 + " * " + a18 + ";\n    " + i16, s17 = "b" + u8 + ", " + s17;
                    return "\n    ivec" + t7.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n11[0] + ", " + n11[1] + "));\n      int index = resTexRC.x * " + n11[1] + " + resTexRC.y;\n\n      " + i16 + "\n\n      int b = index / " + o18 + ";\n      index -= b * " + o18 + ";\n\n      int r = 2 * (index / " + r18 + ");\n      int c = imod(index, " + r18 + ") * 2;\n\n      return ivec" + t7.length + "(" + s17 + ");\n    }\n  ";
                })(t5, e9);
        }
        var n11, r18, o18, a18, i16;
    })(e8.logicalShape, c4), i14 = (function(t5) {
        return "\n    void setOutput(vec4 val) {\n      " + t5.output + " = val;\n    }\n  ";
    })(l3)) : (a16 = (function(t5, e9) {
        switch(t5.length){
            case 0:
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
                return (function(t7, e10) {
                    if (1 === e10[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e10[1] + ".0);\n      }\n    ";
                    if (1 === e10[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e10[0] + ".0);\n      }\n    ";
                    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e10[0] + ", " + e10[1] + "));\n      return resTexRC.x * " + e10[1] + " + resTexRC.y;\n    }\n  ";
                })(0, e9);
            case 2:
                return (function(t7, e10) {
                    if (S(t7, e10)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e10[0] + ", " + e10[1] + "));\n      }\n    ";
                    if (1 === t7[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e10[0] + ", " + e10[1] + "));\n        int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
                    if (1 === t7[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e10[0] + ", " + e10[1] + "));\n        int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
                    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e10[0] + ", " + e10[1] + "));\n      int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n      int r = index / " + t7[1] + ";\n      int c = index - r * " + t7[1] + ";\n      return ivec2(r, c);\n    }\n  ";
                })(t5, e9);
            case 3:
                return n11 = e9, r18 = ca([
                    "r",
                    "c",
                    "d"
                ], t5), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n11[0] + ", " + n11[1] + "));\n      int index = resTexRC.x * " + n11[1] + " + resTexRC.y;\n      " + r18 + "\n      return ivec3(r, c, d);\n    }\n  ";
            case 4:
                return (function(t7, e10) {
                    var n11 = ca([
                        "r",
                        "c",
                        "d",
                        "d2"
                    ], t7);
                    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e10[0] + ", " + e10[1] + "));\n      int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n      " + n11 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
                })(t5, e9);
            case 5:
                return (function(t7, e10) {
                    var n11 = ca([
                        "r",
                        "c",
                        "d",
                        "d2",
                        "d3"
                    ], t7);
                    return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e10[0] + ",\n                             " + e10[1] + "));\n\n      int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n\n      " + n11 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
                })(t5, e9);
            case 6:
                return (function(t7, e10) {
                    var n11 = ca([
                        "r",
                        "c",
                        "d",
                        "d2",
                        "d3",
                        "d4"
                    ], t7);
                    return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e10[0] + ", " + e10[1] + "));\n      int index = resTexRC.x * " + e10[1] + " + resTexRC.y;\n\n      " + n11 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
                })(t5, e9);
            default:
                throw new Error(t5.length + "-D output sampling is not yet supported");
        }
        var n11, r18;
    })(e8.logicalShape, c4), i14 = (function(t5) {
        return "\n    void setOutput(float val) {\n      " + t5.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
    })(l3)), r15 && (f5 += ya), [
        f5,
        h2,
        i14,
        s16,
        a16,
        u7,
        n8
    ].join("\n");
}
function da(t1) {
    var e8 = t1.shapeInfo.logicalShape;
    switch(e8.length){
        case 0:
            return (function(t5) {
                var e9 = t5.name, n8 = "get" + e9.charAt(0).toUpperCase() + e9.slice(1);
                if (t5.shapeInfo.isUniform) return "float " + n8 + "() {return " + e9 + ";}";
                var r15 = t5.shapeInfo.texShape, o17 = r15[0], a16 = r15[1];
                if (1 === o17 && 1 === a16) return "\n      float " + n8 + "() {\n        return sampleTexture(" + e9 + ", halfCR);\n      }\n    ";
                var i14 = t5.shapeInfo.texShape, s16 = i14[0], u7 = i14[1], c4 = xa(e9);
                return "\n    float " + n8 + "() {\n      vec2 uv = uvFromFlat(" + s16 + ", " + u7 + ", " + c4 + ");\n      return sampleTexture(" + e9 + ", uv);\n    }\n  ";
            })(t1);
        case 1:
            return (function(t5) {
                var e9 = t5.name, n8 = "get" + e9.charAt(0).toUpperCase() + e9.slice(1);
                if (t5.shapeInfo.isUniform) return "\n      float " + n8 + "(int index) {\n        " + ba(t5) + "\n      }\n    ";
                var r15 = t5.shapeInfo.texShape, o17 = r15[0], a16 = r15[1];
                if (1 === a16 && 1 === o17) return "\n      float " + n8 + "(int index) {\n        return sampleTexture(" + e9 + ", halfCR);\n      }\n    ";
                var i14 = xa(e9);
                if (1 === a16) return "\n      float " + n8 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i14 + ") + 0.5) / " + o17 + ".0);\n        return sampleTexture(" + e9 + ", uv);\n      }\n    ";
                if (1 === o17) return "\n      float " + n8 + "(int index) {\n        vec2 uv = vec2((float(index + " + i14 + ") + 0.5) / " + a16 + ".0, 0.5);\n        return sampleTexture(" + e9 + ", uv);\n      }\n    ";
                return "\n    float " + n8 + "(int index) {\n      vec2 uv = uvFromFlat(" + o17 + ", " + a16 + ", index + " + i14 + ");\n      return sampleTexture(" + e9 + ", uv);\n    }\n  ";
            })(t1);
        case 2:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n8 = t5.name, r15 = "get" + n8.charAt(0).toUpperCase() + n8.slice(1), o17 = t5.shapeInfo.texShape;
                if (null != o17 && S(e9, o17)) {
                    var a16 = o17[0], i14 = o17[1];
                    return "\n    float " + r15 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i14 + ".0, " + a16 + ".0);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
                }
                var s16 = M(e9), u7 = s16.newShape, c4 = s16.keptDims, l3 = u7;
                if (l3.length < e9.length) {
                    var h2 = Ca(t5, l3);
                    return "\n      " + da(h2) + "\n      float " + r15 + "(int row, int col) {\n        return " + r15 + "(" + Ea([
                        "row",
                        "col"
                    ], c4) + ");\n      }\n    ";
                }
                if (t5.shapeInfo.isUniform) return "\n      float " + r15 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e9[1] + ", 1)));\n        " + ba(t5) + "\n      }\n    ";
                var f5 = o17[0], d6 = o17[1], p7 = xa(n8);
                if (1 === d6) return "\n    float " + r15 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p7 + "), vec3(" + e9[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f5 + ".0);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
                if (1 === f5) return "\n    float " + r15 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p7 + "), vec3(" + e9[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d6 + ".0, 0.5);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
                return "\n  float " + r15 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e9[1] + " + col + " + p7 + ";\n    vec2 uv = uvFromFlat(" + f5 + ", " + d6 + ", index);\n    return sampleTexture(" + n8 + ", uv);\n  }\n";
            })(t1);
        case 3:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n8 = t5.name, r15 = "get" + n8.charAt(0).toUpperCase() + n8.slice(1), o17 = e9[1] * e9[2], a18 = e9[2], i16 = M(e9), s16 = i16.newShape, u7 = i16.keptDims, c4 = s16;
                if (c4.length < e9.length) {
                    var l3 = Ca(t5, c4);
                    return "\n        " + da(l3) + "\n        float " + r15 + "(int row, int col, int depth) {\n          return " + r15 + "(" + Ea([
                        "row",
                        "col",
                        "depth"
                    ], u7) + ");\n        }\n      ";
                }
                if (t5.shapeInfo.isUniform) return "\n      float " + r15 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o17 + ", " + a18 + ", 1)));\n        " + ba(t5) + "\n      }\n    ";
                var h4 = t5.shapeInfo.texShape, f5 = h4[0], d6 = h4[1], p7 = t5.shapeInfo.flatOffset;
                if (d6 === o17 && null == p7) return "\n        float " + r15 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a18 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d6 + ".0, " + f5 + ".0);\n          return sampleTexture(" + n8 + ", uv);\n        }\n      ";
                if (d6 === a18 && null == p7) return "\n    float " + r15 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e9[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d6 + ".0, " + f5 + ".0);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
                var v7 = xa(n8);
                return "\n      float " + r15 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o17 + " + col * " + a18 + " + depth + " + v7 + ";\n        vec2 uv = uvFromFlat(" + f5 + ", " + d6 + ", index);\n        return sampleTexture(" + n8 + ", uv);\n      }\n  ";
            })(t1);
        case 4:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n8 = t5.name, r15 = "get" + n8.charAt(0).toUpperCase() + n8.slice(1), o17 = e9[3], a18 = e9[2] * o17, i16 = e9[1] * a18, s16 = M(e9), u7 = s16.newShape, c4 = s16.keptDims;
                if (u7.length < e9.length) {
                    var l4 = Ca(t5, u7);
                    return "\n      " + da(l4) + "\n      float " + r15 + "(int row, int col, int depth, int depth2) {\n        return " + r15 + "(" + Ea([
                        "row",
                        "col",
                        "depth",
                        "depth2"
                    ], c4) + ");\n      }\n    ";
                }
                if (t5.shapeInfo.isUniform) return "\n      float " + r15 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i16 + ", " + a18 + ", " + o17 + ", 1)));\n        " + ba(t5) + "\n      }\n    ";
                var h4 = t5.shapeInfo.flatOffset, f5 = t5.shapeInfo.texShape, d6 = f5[0], p7 = f5[1];
                if (p7 === i16 && null == h4) return "\n      float " + r15 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a18 + ", " + o17 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + p7 + ".0, " + d6 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                if (p7 === o17 && null == h4) return "\n      float " + r15 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e9[1] * e9[2] + ", " + e9[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + p7 + ".0, " + d6 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                var v7 = xa(n8);
                return "\n    float " + r15 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i16 + " + col * " + a18 + " +\n          depth * " + o17 + " + depth2;\n      vec2 uv = uvFromFlat(" + d6 + ", " + p7 + ", index + " + v7 + ");\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
            })(t1);
        case 5:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n8 = t5.name, r15 = "get" + n8.charAt(0).toUpperCase() + n8.slice(1), o17 = e9[4], a18 = e9[3] * o17, i16 = e9[2] * a18, s16 = e9[1] * i16, u7 = M(e9), c4 = u7.newShape, l5 = u7.keptDims;
                if (c4.length < e9.length) {
                    var h4 = Ca(t5, c4);
                    return "\n      " + da(h4) + "\n      float " + r15 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r15 + "(" + Ea([
                        "row",
                        "col",
                        "depth",
                        "depth2",
                        "depth3"
                    ], l5) + ");\n      }\n    ";
                }
                if (t5.shapeInfo.isUniform) return "\n      float " + r15 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s16 + ", " + i16 + ", " + a18 + ", " + o17 + ")) +\n          depth3;\n        " + ba(t5) + "\n      }\n    ";
                var f5 = t5.shapeInfo.flatOffset, d6 = t5.shapeInfo.texShape, p7 = d6[0], v7 = d6[1];
                if (v7 === s16 && null == f5) return "\n      float " + r15 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i16 + ", " + a18 + ", " + o17 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v7 + ".0, " + p7 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                if (v7 === o17 && null == f5) return "\n      float " + r15 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e9[1] * e9[2] * e9[3] + ",\n               " + e9[2] * e9[3] + ", " + e9[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v7 + ".0, " + p7 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                var m8 = xa(n8);
                return "\n    float " + r15 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s16 + " + col * " + i16 + " + depth * " + a18 + " +\n          depth2 * " + o17 + " + depth3 + " + m8 + ";\n      vec2 uv = uvFromFlat(" + p7 + ", " + v7 + ", index);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
            })(t1);
        case 6:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n8 = t5.name, r15 = "get" + n8.charAt(0).toUpperCase() + n8.slice(1), o17 = M(e9), a18 = o17.newShape, i16 = o17.keptDims;
                if (a18.length < e9.length) {
                    var s16 = Ca(t5, a18);
                    return "\n      " + da(s16) + "\n      float " + r15 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r15 + "(" + Ea([
                        "row",
                        "col",
                        "depth",
                        "depth2",
                        "depth3",
                        "depth4"
                    ], i16) + ");\n      }\n    ";
                }
                var u7 = e9[5], c4 = e9[4] * u7, l5 = e9[3] * c4, h5 = e9[2] * l5, f5 = e9[1] * h5;
                if (t5.shapeInfo.isUniform) return "\n      float " + r15 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f5 + ", " + h5 + ", " + l5 + ", " + c4 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u7 + ", 1)));\n        " + ba(t5) + "\n      }\n    ";
                var d6 = t5.shapeInfo.flatOffset, p7 = t5.shapeInfo.texShape, v7 = p7[0], m8 = p7[1];
                if (m8 === f5 && null == d6) return "\n      float " + r15 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h5 + ", " + l5 + ", " + c4 + ", " + u7 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m8 + ".0, " + v7 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                if (m8 === u7 && null == d6) return "\n      float " + r15 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e9[1] * e9[2] * e9[3] * e9[4] + ",\n               " + e9[2] * e9[3] * e9[4] + ",\n               " + e9[3] * e9[4] + ",\n               " + e9[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m8 + ".0, " + v7 + ".0);\n        return sampleTexture(" + n8 + ", uv);\n      }\n    ";
                var g7 = xa(n8);
                return "\n    float " + r15 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f5 + " + col * " + h5 + " + depth * " + l5 + " +\n          depth2 * " + c4 + " + depth3 * " + u7 + " + depth4 + " + g7 + ";\n      vec2 uv = uvFromFlat(" + v7 + ", " + m8 + ", index);\n      return sampleTexture(" + n8 + ", uv);\n    }\n  ";
            })(t1);
        default:
            throw new Error(e8.length + "-D input sampling is not yet supported");
    }
}
function pa(t1) {
    var e8, n8, r15;
    switch(t1.shapeInfo.logicalShape.length){
        case 0:
            return e8 = t1.name, n8 = "get" + e8.charAt(0).toUpperCase() + e8.slice(1), r15 = ua(), "\n    vec4 " + n8 + "() {\n      return " + r15.texture2D + "(" + e8 + ", halfCR);\n    }\n  ";
        case 1:
            return (function(t5) {
                var e9 = t5.name, n11 = "get" + e9.charAt(0).toUpperCase() + e9.slice(1), r18 = t5.shapeInfo.texShape, o17 = [
                    Math.ceil(r18[0] / 2),
                    Math.ceil(r18[1] / 2)
                ], a18 = ua();
                return "\n    vec4 " + n11 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o17[0] + ", " + o17[1] + ", index);\n      return " + a18.texture2D + "(" + e9 + ", uv);\n    }\n  ";
            })(t1);
        case 2:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n11 = t5.name, r18 = "get" + n11.charAt(0).toUpperCase() + n11.slice(1), o17 = t5.shapeInfo.texShape, a18 = o17[0], i16 = o17[1], s17 = ua();
                if (null != o17 && S(e9, o17)) return "\n      vec4 " + r18 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i16 + ".0, " + a18 + ".0);\n\n        return " + s17.texture2D + "(" + n11 + ", uv);\n      }\n    ";
                var u7 = [
                    Math.ceil(o17[0] / 2),
                    Math.ceil(o17[1] / 2)
                ], c4 = Math.ceil(e9[1] / 2);
                return "\n    vec4 " + r18 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c4 + ", " + u7[0] + ", " + u7[1] + ", row, col);\n      return " + s17.texture2D + "(" + n11 + ", uv);\n    }\n  ";
            })(t1);
        case 3:
            return (function(t5) {
                var e9 = t5.shapeInfo.logicalShape, n11 = t5.name, r18 = "get" + n11.charAt(0).toUpperCase() + n11.slice(1), o17 = t5.shapeInfo.texShape, a18 = [
                    Math.ceil(o17[0] / 2),
                    Math.ceil(o17[1] / 2)
                ];
                if (1 === e9[0]) {
                    var i16 = e9.slice(1), s17 = Ca(t5, i16);
                    return "\n        " + pa(s17) + "\n        vec4 " + r18 + "(int b, int row, int col) {\n          return " + r18 + "(" + Ea([
                        "b",
                        "row",
                        "col"
                    ], [
                        1,
                        2
                    ]) + ");\n        }\n      ";
                }
                var u7 = a18[0], c4 = a18[1], l5 = Math.ceil(e9[2] / 2), h5 = l5 * Math.ceil(e9[1] / 2), f5 = ua();
                return "\n    vec4 " + r18 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u7 + ", " + c4 + ", " + h5 + ", " + l5 + ", b, row, col);\n      return " + f5.texture2D + "(" + n11 + ", uv);\n    }\n  ";
            })(t1);
        default:
            return (function(t5) {
                for(var e9 = t5.shapeInfo.logicalShape, n11 = e9.length, r18 = t5.name, o17 = "get" + r18.charAt(0).toUpperCase() + r18.slice(1), a18 = t5.shapeInfo.texShape, i17 = [
                    Math.ceil(a18[0] / 2),
                    Math.ceil(a18[1] / 2)
                ], s18 = i17[0], u7 = i17[1], c4 = Math.ceil(e9[n11 - 1] / 2), l5 = c4 * Math.ceil(e9[n11 - 2] / 2), h5 = "int b, int row, int col", f5 = "b * " + l5 + " + (row / 2) * " + c4 + " + (col / 2)", d6 = 2; d6 < n11 - 1; d6++)h5 = "int b" + d6 + ", " + h5, l5 *= e9[n11 - d6 - 1], f5 = "b" + d6 + " * " + l5 + " + " + f5;
                var p7 = ua();
                return "\n    vec4 " + o17 + "(" + h5 + ") {\n      int index = " + f5 + ";\n      int texR = index / " + u7 + ";\n      int texC = index - texR * " + u7 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u7 + ", " + s18 + ");\n      return " + p7.texture2D + "(" + r18 + ", uv);\n    }\n  ";
            })(t1);
    }
}
var va = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ma = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ga = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ya = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function xa(t1) {
    return "offset" + t1;
}
function ba(t1) {
    var e8 = t1.name, n8 = k(t1.shapeInfo.logicalShape);
    return n8 < 2 ? "return " + e8 + ";" : "\n    for (int i = 0; i < " + n8 + "; i++) {\n      if (i == index) {\n        return " + e8 + "[i];\n      }\n    }\n  ";
}
function wa(t1) {
    if (t1 <= 1) return "int";
    if (2 === t1) return "ivec2";
    if (3 === t1) return "ivec3";
    if (4 === t1) return "ivec4";
    if (5 === t1) return "ivec5";
    if (6 === t1) return "ivec6";
    throw Error("GPU for rank " + t1 + " is not yet supported");
}
function Ca(t1, e8) {
    var n8 = JSON.parse(JSON.stringify(t1));
    return n8.shapeInfo.logicalShape = e8, n8;
}
function Ea(t1, e8) {
    return e8.map(function(e9) {
        return t1[e9];
    }).join(", ");
}
var Ra = function(t1, e8, n8, r15) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, C(t1.length > 2, function() {
        return "Packed arg" + (n8.charAt(0).toUpperCase() + n8.slice(1)) + " supports only inputs with rank above 2.";
    });
    var o17 = t1[t1.length - 1], a18 = Math.ceil(o17 / e8);
    this.outputShape = t1.slice(0, -1), a18 > 1 && this.outputShape.push(a18), r15 || this.variableNames.push("bestIndicesA");
    var i17, s18, u7 = this.outputShape, c4 = u7.length, l5 = wa(c4), h5 = sa("coords", c4);
    if (1 === a18) {
        var f5 = wa(s18 = c4 + 1);
        i17 = "\n        " + f5 + " sourceLocR = " + f5 + "(" + h5.join() + ", 0);\n        ++" + h5[c4 - 1] + ";\n        " + f5 + " sourceLocG = " + f5 + "(" + h5.join() + ", 0);\n        ++" + h5[c4 - 2] + ";\n        " + f5 + " sourceLocA = " + f5 + "(" + h5.join() + ", 0);\n        --" + h5[c4 - 1] + ";\n        " + f5 + " sourceLocB = " + f5 + "(" + h5.join() + ", 0);\n        --" + h5[c4 - 2] + ";";
    } else s18 = c4, i17 = "\n        " + l5 + " sourceLocR = coords;\n        ++" + h5[c4 - 1] + ";\n        " + l5 + " sourceLocG = coords;\n        ++" + h5[c4 - 2] + ";\n        " + l5 + " sourceLocA = coords;\n        --" + h5[c4 - 1] + ";\n        " + l5 + " sourceLocB = coords;\n        --" + h5[c4 - 2] + ";";
    var d6 = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, s18), p7 = "." + d6[s18 - 1], v7 = d6.map(function(t5) {
        return "int " + t5;
    }), m8 = sa("sourceLocR", s18 - 1).concat("inIdx.r"), g7 = sa("sourceLocG", s18 - 1).concat("inIdx.g"), y5 = sa("sourceLocB", s18 - 1).concat("inIdx.b"), x3 = sa("sourceLocA", s18 - 1).concat("inIdx.a"), b1 = "max" === n8 ? "greaterThan" : "lessThan", w1 = r15 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m8.join() + "),\n                             getBestIndicesAChannel(" + g7.join() + "),\n                             getBestIndicesAChannel(" + y5.join() + "),\n                             getBestIndicesAChannel(" + x3.join() + ")));", E1 = "vec4(\n            getAChannel(" + m8.join() + "),\n            hasNextCol ? getAChannel(" + g7.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y5.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x3.join() + ") : 0.)", R1 = r15 ? "" : "\n      float getBestIndicesAChannel(" + v7.join() + ") {\n        return getChannel(getBestIndicesA(" + d6.join() + "),\n                                          vec2(" + d6.slice(-2).join() + "));\n      }";
    this.userCode = "\n      float getAChannel(" + v7.join() + ") {\n        return getChannel(getA(" + d6.join() + "),\n                               vec2(" + d6.slice(-2).join() + "));\n      }\n      " + R1 + "\n      void main() {\n        " + l5 + " coords = getOutputCoords();\n        bool hasNextCol = " + h5[c4 - 1] + " < " + (u7[c4 - 1] - 1) + ";\n        bool hasNextRow = " + h5[c4 - 2] + " < " + (u7[c4 - 2] - 1) + ";\n        " + i17 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + p7 + ", sourceLocG" + p7 + ",\n          sourceLocB" + p7 + ", sourceLocA" + p7 + ") * " + e8 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E1 + ";\n\n        for (int i = 0; i < " + e8 + "; i++) {\n          inIdx = srcIdx;\n          " + w1 + "\n          vec4 candidate = " + E1 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + b1 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
}, Ia = function(t1) {
    this.variableNames = [
        "dy"
    ], this.outputShape = t1.inShape;
    var e8 = t1.filterHeight, n8 = t1.filterWidth, r15 = t1.strideHeight, o17 = t1.strideWidth, a18 = t1.dilationHeight, i17 = t1.dilationWidth, s18 = t1.effectiveFilterHeight, u7 = t1.effectiveFilterWidth, c4 = s18 - 1 - t1.padInfo.top, l5 = u7 - 1 - t1.padInfo.left, h5 = 1 / (e8 * n8);
    this.userCode = "\n      const ivec2 pads = ivec2(" + c4 + ", " + l5 + ");\n      const float avgMultiplier = float(" + h5 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s18 + ";\n            wR += " + a18 + ") {\n          float dyR = float(dyRCorner + wR) / " + r15 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u7 + ";\n            wC+= " + i17 + ") {\n            float dyC = float(dyCCorner + wC) / " + o17 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, ka = function(t1) {
    this.variableNames = [
        "dy"
    ], this.outputShape = t1.inShape;
    var e8 = t1.filterDepth, n8 = t1.filterHeight, r15 = t1.filterWidth, o17 = t1.strideDepth, a18 = t1.strideHeight, i17 = t1.strideWidth, s18 = t1.dilationDepth, u7 = t1.dilationHeight, c4 = t1.dilationWidth, l5 = t1.effectiveFilterDepth, h5 = t1.effectiveFilterHeight, f6 = t1.effectiveFilterWidth, d6 = l5 - 1 - t1.padInfo.front, p7 = h5 - 1 - t1.padInfo.top, v7 = f6 - 1 - t1.padInfo.left, m8 = 1 / (e8 * n8 * r15);
    this.userCode = "\n      const ivec3 pads = ivec3(" + d6 + ", " + p7 + ", " + v7 + ");\n      const float avgMultiplier = float(" + m8 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l5 + ";\n            wD += " + s18 + ") {\n          float dyD = float(dyDCorner + wD) / " + o17 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t1.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h5 + ";\n              wR += " + u7 + ") {\n            float dyR = float(dyRCorner + wR) / " + a18 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f6 + ";\n                wC += " + c4 + ") {\n              float dyC = float(dyCCorner + wC) / " + i17 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Sa = function(t1, e8, n8, r15, o17, a18) {
    this.outputShape = [], this.variableNames = [
        "x",
        "mean",
        "variance"
    ], Ro(t1, e8), Ro(t1, n8);
    var i17 = "0.0";
    null != r15 && (Ro(t1, r15), this.variableNames.push("offset"), i17 = "getOffsetAtOutCoords()");
    var s18 = "1.0";
    null != o17 && (Ro(t1, o17), this.variableNames.push("scale"), s18 = "getScaleAtOutCoords()"), this.outputShape = t1, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i17 + ";\n        float scale = " + s18 + ";\n        float inv = scale * inversesqrt(variance + float(" + a18 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
}, Aa = function(t1, e8, n8, r15, o17, a18) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [
        "x",
        "mean",
        "variance"
    ], Ro(t1, e8), Ro(t1, n8);
    var i17 = "vec4(0.0)";
    null != r15 && (Ro(t1, r15), this.variableNames.push("offset"), i17 = "getOffsetAtOutCoords()");
    var s18 = "vec4(1.0)";
    null != o17 && (Ro(t1, o17), this.variableNames.push("scale"), s18 = "getScaleAtOutCoords()"), this.outputShape = t1, this.userCode = "\n      void main() {\n        vec4 offset = " + i17 + ";\n        vec4 scale = " + s18 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a18 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
}, Da = "return areal * breal - aimag * bimag;", Ta = "return areal * bimag + aimag * breal;", Na = function(t1, e8, n8) {
    this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
    ], this.outputShape = Ro(e8, n8), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t1 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
}, Fa = "return a + b;", _a = "return a - b;", Oa = "return a * b;", Ma = "return (a < 0.) ? b * a : a;", Ba = function(t1, e8, n8) {
    this.variableNames = [
        "A",
        "B"
    ], this.outputShape = Ro(e8, n8), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t1 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
}, Pa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n", La = function(t1, e8, n8, r15) {
    (void 0) === r15 && (r15 = !1), this.variableNames = [
        "A",
        "B"
    ], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Ro(e8, n8);
    var o17 = this.outputShape.length, a18 = "";
    if (r15) {
        if (0 === o17 || 1 === k(this.outputShape)) a18 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else if (a18 = "\n          " + wa(o17) + " coords = getOutputCoords();\n        ", 1 === o17) a18 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
        else {
            var i17 = sa("coords", o17);
            a18 += "\n            bool nextRowOutOfBounds =\n              (" + i17[o17 - 2] + " + 1) >= " + this.outputShape[o17 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i17[o17 - 1] + " + 1) >= " + this.outputShape[o17 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
        }
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t1 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a18 + "\n\n        setOutput(result);\n      }\n    ";
}, Wa = function() {
    function t1(t5) {
        this.variableNames = [
            "A"
        ], this.outputShape = t5, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t5, e8) {
        var n8 = this;
        return function(r15, o17) {
            null == n8.minLoc && (n8.minLoc = r15.getUniformLocationNoThrow(o17, "minVal"), n8.maxLoc = r15.getUniformLocationNoThrow(o17, "maxVal")), r15.gl.uniform1f(n8.minLoc, t5), r15.gl.uniform1f(n8.maxLoc, e8);
        };
    }, t1;
}(), Ua = function() {
    function t1(t5) {
        this.variableNames = [
            "A"
        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t5, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t5, e8) {
        var n8 = this;
        return function(r15, o17) {
            null == n8.minLoc && (n8.minLoc = r15.getUniformLocationNoThrow(o17, "minVal"), n8.maxLoc = r15.getUniformLocationNoThrow(o17, "maxVal")), r15.gl.uniform1f(n8.minLoc, t5), r15.gl.uniform1f(n8.maxLoc, e8);
        };
    }, t1;
}(), Va = function(t1) {
    this.variableNames = [
        "real",
        "imag"
    ], this.outputShape = t1, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
}, za = function(t1) {
    this.outputShape = [], this.outputShape = Sn(t1, 1), this.variableNames = t1.map(function(t5, e8) {
        return "T" + e8;
    });
    var e8 = new Array(t1.length - 1);
    e8[0] = t1[0][1];
    for(var n8 = 1; n8 < e8.length; n8++)e8[n8] = e8[n8 - 1] + t1[n8][1];
    var r15 = [
        "if (yC < " + e8[0] + ") setOutput(getT0(yR, yC));"
    ];
    for(n8 = 1; n8 < e8.length; n8++){
        var o17 = e8[n8 - 1];
        r15.push("else if (yC < " + e8[n8] + ") setOutput(getT" + n8 + "(yR, yC-" + o17 + "));");
    }
    var a18 = e8.length, i18 = e8[e8.length - 1];
    r15.push("else setOutput(getT" + a18 + "(yR, yC-" + i18 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r15.join("\n        ") + "\n      }\n    ";
}, Ga = function(t1, e8) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t1, e8);
    var n8 = this.outputShape, r15 = n8.length, o18 = wa(r15), a18 = sa("coords", r15), i18 = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, r15);
    this.variableNames = t1.map(function(t5, e9) {
        return "T" + e9;
    });
    var s18 = new Array(t1.length - 1);
    s18[0] = t1[0][e8];
    for(var u7 = 1; u7 < s18.length; u7++)s18[u7] = s18[u7 - 1] + t1[u7][e8];
    var c4 = i18[e8], l5 = i18.slice(-2), h5 = i18.join(), f6 = "if (" + c4 + " < " + s18[0] + ") {\n        return getChannel(\n            getT0(" + h5 + "), vec2(" + l5.join() + "));\n        }";
    for(u7 = 1; u7 < s18.length; u7++){
        var d6 = s18[u7 - 1];
        f6 += "\n        if (" + c4 + " < " + s18[u7] + "  && " + c4 + " >= " + s18[u7 - 1] + ") {\n          return getChannel(\n            getT" + u7 + "(" + Ha(i18, c4, d6) + "),\n            vec2(" + Ha(l5, c4, d6) + "));\n        }";
    }
    var p7 = s18.length, v7 = s18[s18.length - 1];
    f6 += "\n        return getChannel(\n          getT" + p7 + "(" + Ha(i18, c4, v7) + "),\n          vec2(" + Ha(l5, c4, v7) + "));", this.userCode = "\n      float getValue(" + i18.map(function(t5) {
        return "int " + t5;
    }) + ") {\n        " + f6 + "\n      }\n\n      void main() {\n        " + o18 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a18 + "), 0., 0., 0.);\n\n        " + a18[r15 - 1] + " = " + a18[r15 - 1] + " + 1;\n        if (" + a18[r15 - 1] + " < " + n8[r15 - 1] + ") {\n          result.g = getValue(" + a18 + ");\n        }\n\n        " + a18[r15 - 2] + " = " + a18[r15 - 2] + " + 1;\n        if (" + a18[r15 - 2] + " < " + n8[r15 - 2] + ") {\n          result.a = getValue(" + a18 + ");\n        }\n\n        " + a18[r15 - 1] + " = " + a18[r15 - 1] + " - 1;\n        if (" + a18[r15 - 2] + " < " + n8[r15 - 2] + " &&\n            " + a18[r15 - 1] + " < " + n8[r15 - 1] + ") {\n          result.b = getValue(" + a18 + ");\n        }\n        setOutput(result);\n      }\n    ";
};
function Ha(t1, e8, n8) {
    var r15 = t1.indexOf(e8);
    return t1.map(function(t5, e9) {
        return e9 === r15 ? t5 + " - " + n8 : t5;
    }).join();
}
var qa = function(t1) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t1.filterShape;
    var e8 = t1.strideHeight, n8 = t1.strideWidth, r15 = t1.padInfo.top, o18 = t1.padInfo.left, a18 = "channelsLast" === t1.dataFormat;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t1.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t1.outHeight + "; yR++) {\n            int xR = wR + yR * " + e8 + " - " + r15 + ";\n\n            if (xR < 0 || xR >= " + t1.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t1.outWidth + "; yC++) {\n              int xC = wC + yC * " + n8 + " - " + o18 + ";\n\n              if (xC < 0 || xC >= " + t1.inWidth + ") {\n                continue;\n              }\n\n              if (" + a18 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Ka = function(t1) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t1.inShape;
    var e8 = t1.filterHeight, n8 = t1.filterWidth, r15 = t1.strideHeight, o18 = t1.strideWidth, a18 = "channelsLast" === t1.dataFormat, i18 = e8 - 1 - t1.padInfo.top, s18 = n8 - 1 - t1.padInfo.left, u7 = a18 ? 1 : 2, c4 = a18 ? 2 : 3, l5 = a18 ? 3 : 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i18 + ", " + s18 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l5 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u7 + "], coords[" + c4 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e8 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r15 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e8 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n8 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o18 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n8 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t1.outChannels + "; d2++) {\n\n              if (" + a18 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, ja = function(t1) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t1.filterShape;
    var e8 = t1.strideDepth, n8 = t1.strideHeight, r15 = t1.strideWidth, o18 = t1.padInfo.front, a18 = t1.padInfo.top, i18 = t1.padInfo.left;
    this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t1.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t1.outDepth + "; yF++) {\n            int xF = wF + yF * " + e8 + " - " + o18 + ";\n\n            if (xF < 0 || xF >= " + t1.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t1.outHeight + "; yR++) {\n              int xR = wR + yR * " + n8 + " - " + a18 + ";\n\n              if (xR < 0 || xR >= " + t1.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t1.outWidth + "; yC++) {\n                int xC = wC + yC * " + r15 + " - " + i18 + ";\n\n                if (xC < 0 || xC >= " + t1.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Xa = function(t1) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t1.inShape;
    var e8 = t1.filterDepth, n8 = t1.filterHeight, r15 = t1.filterWidth, o18 = t1.strideDepth, a18 = t1.strideHeight, i18 = t1.strideWidth, s18 = e8 - 1 - t1.padInfo.front, u7 = n8 - 1 - t1.padInfo.top, c4 = r15 - 1 - t1.padInfo.left;
    this.userCode = "\n      const ivec3 pads = ivec3(" + s18 + ", " + u7 + ", " + c4 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e8 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o18 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t1.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e8 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n8 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a18 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n8 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r15 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i18 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r15 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t1.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Ya = function(t1) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t1.filterShape;
    var e8 = t1.strideHeight, n8 = t1.strideWidth, r15 = t1.padInfo.top, o18 = t1.padInfo.left, a18 = t1.outChannels / t1.inChannels;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a18 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t1.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t1.outHeight + "; yR++) {\n            int xR = wR + yR * " + e8 + " - " + r15 + ";\n\n            if (xR < 0 || xR >= " + t1.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t1.outWidth + "; yC++) {\n              int xC = wC + yC * " + n8 + " - " + o18 + ";\n\n              if (xC < 0 || xC >= " + t1.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, $a = function(t1) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t1.inShape;
    var e8 = t1.filterHeight, n8 = t1.filterWidth, r15 = t1.strideHeight, o18 = t1.strideWidth, a18 = e8 - 1 - t1.padInfo.top, i18 = n8 - 1 - t1.padInfo.left, s18 = t1.outChannels / t1.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(" + a18 + ", " + i18 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e8 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r15 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e8 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n8 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o18 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n8 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s18 + "; dm++) {\n              int d2 = d1 * " + s18 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Qa = function(t1, e8, n8, r15) {
    (void 0) === e8 && (e8 = !1), (void 0) === n8 && (n8 = null), (void 0) === r15 && (r15 = !1), this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t1.outShape;
    var o18 = t1.padInfo.top, a18 = t1.padInfo.left, i18 = t1.strideHeight, s18 = t1.strideWidth, u7 = t1.dilationHeight, c4 = t1.dilationWidth, l5 = t1.filterHeight, h5 = t1.filterWidth, f6 = 4 * Math.floor(t1.inChannels / 4), d7 = t1.inChannels % 4, p7 = "channelsLast" === t1.dataFormat, v7 = p7 ? 1 : 2, m8 = p7 ? 2 : 3, g7 = p7 ? 3 : 1, y5 = "", x3 = "";
    n8 && (y5 = r15 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n8 + "\n        }" : "\n          float activation(float x) {\n            " + n8 + "\n          }\n        ", x3 = "result = activation(result);");
    var b1 = e8 ? "result += getBiasAtOutCoords();" : "";
    e8 && this.variableNames.push("bias"), r15 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y5 + "\n\n      const ivec2 strides = ivec2(" + i18 + ", " + s18 + ");\n      const ivec2 pads = ivec2(" + o18 + ", " + a18 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g7 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v7 + "], coords[" + m8 + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l5 + "; wR++) {\n          int xR = xRCorner + wR * " + u7 + ";\n\n          if (xR < 0 || xR >= " + t1.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h5 + "; wC++) {\n            int xC = xCCorner + wC * " + c4 + ";\n\n            if (xC < 0 || xC >= " + t1.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f6 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + p7 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d7) + ") {\n\n              if (" + p7 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f6 + ") *\n                    getW(wR, wC, " + f6 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f6 + ", xR, xC) *\n                    getW(wR, wC, " + f6 + ", d2);\n              }\n\n            } else if (" + (2 === d7) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f6 + ", d2),\n                getW(wR, wC, " + f6 + " + 1, d2)\n              );\n\n              if (" + p7 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f6 + "),\n                  getX(batch, xR, xC, " + f6 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f6 + ", xR, xC),\n                  getX(batch, " + f6 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d7) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f6 + ", d2),\n                getW(wR, wC, " + f6 + " + 1, d2),\n                getW(wR, wC, " + f6 + " + 2, d2)\n              );\n\n              if (" + p7 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f6 + "),\n                  getX(batch, xR, xC, " + f6 + " + 1),\n                  getX(batch, xR, xC, " + f6 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f6 + ", xR, xC),\n                  getX(batch, " + f6 + " + 1, xR, xC),\n                  getX(batch, " + f6 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b1 + "\n        " + x3 + "\n        setOutput(result);\n      }\n    ";
}, Ja = function(t1) {
    this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t1.outShape;
    var e8 = t1.padInfo.front, n8 = t1.padInfo.top, r15 = t1.padInfo.left, o18 = t1.strideDepth, a18 = t1.strideHeight, i18 = t1.strideWidth, s18 = t1.dilationDepth, u7 = t1.dilationHeight, c4 = t1.dilationWidth, l5 = t1.filterDepth, h5 = t1.filterHeight, f6 = t1.filterWidth, d7 = 4 * Math.floor(t1.inChannels / 4), p7 = t1.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(" + o18 + ", " + a18 + ", " + i18 + ");\n      const ivec3 pads = ivec3(" + e8 + ", " + n8 + ", " + r15 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l5 + "; wF++) {\n          int xF = xFCorner + wF * " + s18 + ";\n\n          if (xF < 0 || xF >= " + t1.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h5 + "; wR++) {\n            int xR = xRCorner + wR * " + u7 + ";\n\n            if (xR < 0 || xR >= " + t1.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f6 + "; wC++) {\n              int xC = xCCorner + wC * " + c4 + ";\n\n              if (xC < 0 || xC >= " + t1.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + d7 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === p7) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + d7 + ") *\n                  getW(wF, wR, wC, " + d7 + ", d2);\n              } else if (" + (2 === p7) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + d7 + "),\n                  getX(batch, xF, xR, xC, " + d7 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + d7 + ", d2),\n                  getW(wF, wR, wC, " + d7 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === p7) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + d7 + "),\n                  getX(batch, xF, xR, xC, " + d7 + " + 1),\n                  getX(batch, xF, xR, xC, " + d7 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + d7 + ", d2),\n                  getW(wF, wR, wC, " + d7 + " + 1, d2),\n                  getW(wF, wR, wC, " + d7 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Za = function(t1, e8, n8, r15) {
    (void 0) === e8 && (e8 = !1), (void 0) === n8 && (n8 = null), (void 0) === r15 && (r15 = !1), this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t1.outShape;
    var o18 = t1.inHeight, a18 = t1.inWidth, i18 = t1.padInfo.top, s18 = t1.padInfo.left, u7 = t1.strideHeight, c4 = t1.strideWidth, l5 = t1.dilationHeight, h5 = t1.dilationWidth, f6 = t1.filterHeight, d7 = t1.filterWidth, p7 = t1.outChannels / t1.inChannels, v7 = "", m8 = "";
    n8 && (v7 = r15 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n8 + "\n        }" : "\n          float activation(float x) {\n            " + n8 + "\n          }\n        ", m8 = "result = activation(result);");
    var g7 = e8 ? "result += getBiasAtOutCoords();" : "";
    e8 && this.variableNames.push("bias"), r15 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v7 + "\n\n      const ivec2 strides = ivec2(" + u7 + ", " + c4 + ");\n      const ivec2 pads = ivec2(" + i18 + ", " + s18 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + p7 + ";\n        int q = d2 - d1 * " + p7 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f6 + "; wR++) {\n          int xR = xRCorner + wR * " + l5 + ";\n\n          if (xR < 0 || xR >= " + o18 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d7 + "; wC++) {\n            int xC = xCCorner + wC * " + h5 + ";\n\n            if (xC < 0 || xC >= " + a18 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g7 + "\n        " + m8 + "\n        setOutput(result);\n      }\n    ";
}, ti = function(t1, e8, n8, r15) {
    (void 0) === e8 && (e8 = !1), (void 0) === n8 && (n8 = null), (void 0) === r15 && (r15 = !1), this.variableNames = [
        "x",
        "W"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t1.outShape;
    for(var o18 = t1.inHeight, a18 = t1.inWidth, i18 = t1.padInfo.top, s18 = t1.padInfo.left, u7 = t1.strideHeight, c4 = t1.strideWidth, l5 = t1.dilationHeight, h5 = t1.dilationWidth, f6 = t1.filterHeight, d7 = t1.filterWidth, p7 = d7, v7 = "int xR; int xC; int xCOffset;", m8 = 0; m8 < f6; m8++)for(var g7 = 0; g7 < d7; g7++)v7 += "\n          vec4 xTexelR" + m8 + "C" + 2 * g7 + " = vec4(0.);\n          vec4 wR" + m8 + "C" + g7 + " = vec4(0.);\n          vec4 xR" + m8 + "C" + g7 + " = vec4(0.);";
    for(m8 = 0; m8 < f6; m8++)for(var y5 = 0; y5 < p7; y5++){
        if (v7 += "\n          xR = xRCorner + " + m8 * l5 + ";\n          xC = xCCorner + " + (g7 = 2 * y5) * h5 + ";\n        ", 1 === c4) {
            if (g7 < d7 && (v7 += s18 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o18 + " && xCOffset >= 0 && xCOffset < " + a18 + ") {\n                  xTexelR" + m8 + "C" + g7 + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a18 + ") {\n                    xTexelR" + m8 + "C" + g7 + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + m8 + "C" + g7 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o18 + " && xCOffset >= 0 && xCOffset < " + a18 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a18 + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + m8 + "C" + g7 + " = vec4(previous.zw, xTexelR" + m8 + "C" + g7 + ".xy);\n                } else {\n                  xR" + m8 + "C" + g7 + " = vec4(0, 0, xTexelR" + m8 + "C" + g7 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o18 + " && xC >= 0 && xC < " + a18 + ") {\n                  xTexelR" + m8 + "C" + g7 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m8 + "C" + g7 + " = vec4(0.);\n                }\n\n                xR" + m8 + "C" + g7 + " = xTexelR" + m8 + "C" + g7 + ";\n              ", g7 + 1 < d7)) {
                var x3 = s18 % 2 == 0 ? b(h5) : h5;
                h5 % 2 == 0 && s18 % 2 == 1 || h5 % 2 != 0 && s18 % 2 != 1 ? (v7 += "\n                  xCOffset = xC + " + s18 % 2 + " + " + x3 + ";\n\n                  if(xR >= 0 && xR < " + o18 + " &&\n                    xCOffset >= 0 && xCOffset < " + a18 + ") {\n                    xTexelR" + m8 + "C" + (g7 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h5 > 1 && (v7 += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o18 + " &&\n                      xCOffset >= 0 && xCOffset < " + a18 + ") {\n                      xTexelR" + m8 + "C" + g7 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m8 + "C" + g7 + " = vec4(0.);\n                    }\n                  "), v7 += "\n                  xR" + m8 + "C" + (g7 + 1) + " = vec4(\n                    xTexelR" + m8 + "C" + g7 + ".zw, xTexelR" + m8 + "C" + (g7 + 2) + ".xy);\n                ") : v7 += "\n                  xCOffset = xC + " + x3 + ";\n\n                  if(xR >= 0 && xR < " + o18 + " &&\n                    xCOffset >= 0 && xCOffset < " + a18 + ") {\n                    xTexelR" + m8 + "C" + (g7 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m8 + "C" + (g7 + 1) + " = xTexelR" + m8 + "C" + (g7 + 2) + ";\n                ";
            }
        } else g7 < d7 && (v7 += "\n              if(xR >= 0 && xR < " + o18 + ") {\n            ", s18 % 2 == 1 ? (v7 += "\n                xCOffset = xC + 1 - " + c4 + ";\n                if(xCOffset >= 0 && xCOffset < " + a18 + ") {\n                  xTexelR" + m8 + "C" + g7 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m8 + "C" + g7 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a18 + ") {\n                  xTexelR" + m8 + "C" + (g7 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m8 + "C" + (g7 + 2) + " = vec4(0.);\n                }\n\n                xR" + m8 + "C" + g7 + " = vec4(\n                  xTexelR" + m8 + "C" + g7 + ".zw, xTexelR" + m8 + "C" + (g7 + 2) + ".zw);\n              ", g7 + 1 < d7 && (v7 += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c4 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a18 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m8 + "C" + (g7 + 1) + " = vec4(xTexelR" + m8 + "C" + (g7 + 2) + ".xy, final.xy);\n                ")) : (v7 += "\n                if(xC >= 0 && xC < " + a18 + ") {\n                  xTexelR" + m8 + "C" + g7 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m8 + "C" + g7 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c4 + ";\n                if(xCOffset >= 0 && xCOffset < " + a18 + ") {\n                  xTexelR" + m8 + "C" + (g7 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m8 + "C" + (g7 + 2) + " = vec4(0.);\n                }\n\n                xR" + m8 + "C" + g7 + " = vec4(\n                  xTexelR" + m8 + "C" + g7 + ".xy, xTexelR" + m8 + "C" + (g7 + 2) + ".xy);\n              ", g7 + 1 < d7 && (v7 += "\n                  xR" + m8 + "C" + (g7 + 1) + " = vec4(\n                    xTexelR" + m8 + "C" + g7 + ".zw, xTexelR" + m8 + "C" + (g7 + 2) + ".zw);\n                ")), v7 += "}");
        g7 < d7 && (v7 += "\n            vec4 wTexelR" + m8 + "C" + g7 + " = getW(" + m8 + ", " + g7 + ", d1, q);\n            wR" + m8 + "C" + g7 + " = vec4(wTexelR" + m8 + "C" + g7 + ".xz, wTexelR" + m8 + "C" + g7 + ".xz);\n          ", g7 + 1 < d7 && (v7 += "\n              vec4 wTexelR" + m8 + "C" + (g7 + 1) + " = getW(" + m8 + ", " + (g7 + 1) + ", d1, q);\n              wR" + m8 + "C" + (g7 + 1) + " =\n                vec4(wTexelR" + m8 + "C" + (g7 + 1) + ".xz, wTexelR" + m8 + "C" + (g7 + 1) + ".xz);"));
    }
    for(m8 = 0; m8 < f6; m8++)for(g7 = 0; g7 < d7; g7++)v7 += "dotProd += xR" + m8 + "C" + g7 + " * wR" + m8 + "C" + g7 + ";";
    var w1 = "", C1 = "";
    n8 && (w1 = r15 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n8 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n8 + "\n        }", C1 = "result = activation(result);");
    var E1 = e8 ? "result += getBiasAtOutCoords();" : "";
    e8 && this.variableNames.push("bias"), r15 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w1 + "\n\n      const ivec2 strides = ivec2(" + u7 + ", " + c4 + ");\n      const ivec2 pads = ivec2(" + i18 + ", " + s18 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v7 + "\n\n        vec4 result = dotProd;\n        " + E1 + "\n        " + C1 + "\n        setOutput(result);\n      }\n    ";
}, ei = function(t1, e8, n8, r15, o18) {
    this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
    ], this.outputShape = [];
    var a18 = t1[0], i18 = t1[1], s18 = t1[2], u7 = t1[3], c4 = e8[0], l5 = n8[0], h5 = n8[1];
    this.outputShape = [
        c4,
        l5,
        h5,
        u7
    ];
    var f6 = "bilinear" === r15 ? 1 : 0, d7 = [
        i18 - 1 + ".0",
        s18 - 1 + ".0"
    ], p7 = d7[0], v7 = d7[1], m8 = l5 > 1 ? [
        "" + (i18 - 1) / (l5 - 1),
        "(y2-y1) * height_ratio",
        "y1*" + p7 + " + float(y)*(height_scale)"
    ] : [
        "0.0",
        "0.0",
        "0.5 * (y1+y2) * " + p7
    ], g7 = m8[0], y5 = m8[1], x5 = m8[2], b1 = h5 > 1 ? [
        "" + (s18 - 1) / (h5 - 1),
        "(x2-x1) * width_ratio",
        "x1*" + v7 + " + float(x)*(width_scale)"
    ] : [
        "0.0",
        "0.0",
        "0.5 * (x1+x2) * " + v7
    ], w1 = b1[0], C1 = b1[1], E1 = b1[2];
    this.userCode = "\n      const float height_ratio = float(" + g7 + ");\n      const float width_ratio = float(" + w1 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a18 + ") {\n          return;\n        }\n\n        float height_scale = " + y5 + ";\n        float width_scale = " + C1 + ";\n\n        float in_y = " + x5 + ";\n        if( in_y < 0.0 || in_y > " + p7 + " ) {\n          setOutput(float(" + o18 + "));\n          return;\n        }\n        float in_x = " + E1 + ";\n        if( in_x < 0.0 || in_x > " + v7 + " ) {\n          setOutput(float(" + o18 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f6 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
}, ni = function(t1, e8, n8) {
    this.variableNames = [
        "x"
    ], this.outputShape = t1;
    var r15 = t1.length, o18 = t1[t1.length - 1], a18 = n8 ? "<" : ">";
    this.userCode = "\n      int getIndex(int i) {\n        " + (n8 ? "return " + o18 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + wa(r15) + " coords = getOutputCoords();\n        int end = " + ri(r15, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o18 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a18 + " end) {\n            continue;\n          }\n          if (idx == end && " + e8 + ") {\n            continue;\n          }\n          " + ri(r15, "coords") + " = idx;\n          val += getX(" + (function(t5, e9) {
        if (1 === t5) return "" + e9;
        if (2 === t5) return e9 + ".x, " + e9 + ".y";
        if (3 === t5) return e9 + ".x, " + e9 + ".y, " + e9 + ".z";
        if (4 === t5) return e9 + ".x, " + e9 + ".y, " + e9 + ".z, " + e9 + ".w";
        throw Error("Cumulative sum for rank " + t5 + " is not yet supported");
    })(r15, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
};
function ri(t1, e8) {
    if (1 === t1) return "" + e8;
    if (2 === t1) return e8 + ".y";
    if (3 === t1) return e8 + ".z";
    if (4 === t1) return e8 + ".w";
    throw Error("Cumulative sum for rank " + t1 + " is not yet supported");
}
var oi = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
    var e8 = Yt(t1), n8 = ua();
    this.outputShape = t1, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca([
        "r",
        "c",
        "d"
    ], t1) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e8[0] + ", " + e8[1] + "));\n        int index = 4 * (resTexRC.x * " + e8[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n8.output + " = result;\n      }\n    ";
}, ai = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
    var e8 = Yt(t1), n8 = ua();
    this.outputShape = t1, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca([
        "r",
        "c",
        "d"
    ], t1) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e8[0] + ", " + e8[1] + "));\n        int index = 4 * (resTexRC.x * " + e8[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n8.output + " = result;\n      }\n    ";
}, ii = function() {
    function t1(t5, e8, n8) {
        this.variableNames = [
            "x"
        ], this.outputShape = [], this.outputShape = t5, this.blockSize = e8, this.dataFormat = n8, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e8 + ";\n      int offset_h = imod(h, " + e8 + ");\n      int in_w = w / " + e8 + ";\n      int offset_w = imod(w, " + e8 + ");\n      int offset_d = (offset_h * " + e8 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
    }
    return t1.prototype.getHeightCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
    }, t1.prototype.getWidthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
    }, t1.prototype.getDepthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
    }, t1.prototype.getOutputDepthSize = function() {
        return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
    }, t1.prototype.getInputSamplingString = function() {
        return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }, t1;
}(), si = function(t1) {
    this.variableNames = [
        "X"
    ], this.outputShape = [
        t1,
        t1
    ], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
}, ui = function(t1) {
    this.variableNames = [
        "A"
    ], this.outTexUsage = zt.DOWNLOAD;
    var e8 = ua();
    this.outputShape = t1, this.userCode = "\n      " + ha + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e8.output + " = encode_float(x);\n      }\n    ";
}, ci = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;
    var e8 = ua();
    this.outputShape = t1, this.userCode = "\n      " + ha + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e8.output + " = encode_float(x);\n      }\n    ";
}, li = function(t1, e8, n8) {
    (void 0) === n8 && (n8 = !1), this.variableNames = [
        "A"
    ];
    var r15 = ua(), o18 = e8[0], a18 = e8[1];
    this.outputShape = t1;
    var i18 = "result";
    n8 && (i18 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + la(t1) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a18 + ";\n        int c = imod(flatIndex, " + a18 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a18 + ".0, " + o18 + ".0);\n        vec4 values = " + r15.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r15.output + " = vec4(" + i18 + ", 0., 0., 0.);\n      }\n    ";
}, hi = function(t1, e8, n8) {
    (void 0) === n8 && (n8 = !1), this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0;
    var r15 = ua(), o18 = e8[0], a18 = e8[1];
    this.outputShape = t1;
    var i18 = "", s18 = "result";
    n8 && (s18 = "floor(result * 255. + 0.5)");
    for(var u7 = 0; u7 <= 1; u7++)for(var c4 = 0; c4 <= 1; c4++){
        var l5 = 2 * u7 + c4;
        i18 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c4 + " < " + t1[2] + ") {\n            localCoords[2] += " + c4 + ";\n            if(localCoords[1] + " + u7 + " < " + t1[1] + ") {\n              localCoords[1] += " + u7 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a18 + ";\n              c = imod(flatIndex, " + a18 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a18 + ".0, " + o18 + ".0);\n              values = " + r15.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l5 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l5 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l5 + "] = values[2];\n              } else {\n                result[" + l5 + "] = values[3];\n              }\n            }\n          }\n        ";
    }
    this.userCode = "\n      " + la(t1) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i18 + "\n\n        " + r15.output + " = " + s18 + ";\n      }\n    ";
}, fi = "return real * expR - imag * expI;", di = "return real * expI + imag * expR;", pi = function(t1, e8, n8) {
    this.variableNames = [
        "real",
        "imag"
    ];
    var r15 = e8[1];
    this.outputShape = e8;
    var o18 = n8 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a18 = n8 ? r15 + ".0" : "1.0";
    this.userCode = "\n      const float exponentMultiplier = " + o18 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t1 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r15 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r15 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a18 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
}, vi = function() {
    function t1(t5, e8) {
        this.outputShape = [], this.variableNames = [
            "x"
        ], this.outputShape = t5, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t5) {
        var e8 = this;
        return function(n8, r15) {
            null == e8.valueLoc && (e8.valueLoc = n8.getUniformLocationNoThrow(r15, "value")), n8.gl.uniform1f(e8.valueLoc, t5);
        };
    }, t1;
}(), mi = function(t1, e8, n8) {
    this.variableNames = [
        "A",
        "indices"
    ];
    var r15 = t1.slice();
    r15[n8] = e8, this.outputShape = r15, this.rank = r15.length;
    var o18 = wa(this.rank), a18 = function(t5, e9) {
        var n11 = t5.length;
        if (n11 > 4) throw Error("Gather for rank " + n11 + " is not yet supported");
        if (1 === n11) return "int(getIndices(resRC))";
        for(var r18 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w"
        ], o19 = [], a19 = 0; a19 < t5.length; a19++)a19 === e9 ? o19.push("int(getIndices(" + r18[a19] + "))") : o19.push("" + r18[a19]);
        return o19.join();
    }(t1, n8);
    this.userCode = "\n      void main() {\n        " + o18 + " resRC = getOutputCoords();\n        setOutput(getA(" + a18 + "));\n      }\n    ";
};
var gi = function(t1, e8, n8) {
    this.sliceDim = t1, this.strides = e8, this.variableNames = [
        "x",
        "indices"
    ], this.outputShape = n8;
    var r15 = wa(e8.length), o18 = wa(n8.length), a18 = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + r15 + " strides = " + r15 + "(" + this.strides + ");\n         void main() {\n          " + o18 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a18 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
};
function yi(t1, e8) {
    var n8 = ua();
    return oe(t1, e8, n8.version + "\n    precision highp float;\n    " + n8.attribute + " vec3 clipSpacePos;\n    " + n8.attribute + " vec2 uv;\n    " + n8.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}
function xi(t1, e8) {
    return fe(t1, e8, new Float32Array([
        -1,
        1,
        0,
        0,
        1,
        -1,
        -1,
        0,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        -1,
        0,
        1,
        0
    ]));
}
function bi(t1, e8) {
    return de(t1, e8, new Uint16Array([
        0,
        1,
        2,
        2,
        1,
        3
    ]));
}
function wi(t1, e8, n8, r15, o18, a18, i18) {
    ve(n8, r15);
    var s18 = pe(t1, e8), u7 = t1.TEXTURE_2D;
    return Jt(t1, e8, function() {
        return t1.bindTexture(u7, s18);
    }), Jt(t1, e8, function() {
        return t1.texParameteri(u7, t1.TEXTURE_WRAP_S, t1.CLAMP_TO_EDGE);
    }), Jt(t1, e8, function() {
        return t1.texParameteri(u7, t1.TEXTURE_WRAP_T, t1.CLAMP_TO_EDGE);
    }), Jt(t1, e8, function() {
        return t1.texParameteri(u7, t1.TEXTURE_MIN_FILTER, t1.NEAREST);
    }), Jt(t1, e8, function() {
        return t1.texParameteri(u7, t1.TEXTURE_MAG_FILTER, t1.NEAREST);
    }), Jt(t1, e8, function() {
        return t1.texImage2D(u7, 0, o18, n8, r15, 0, a18, i18, null);
    }), Jt(t1, e8, function() {
        return t1.bindTexture(t1.TEXTURE_2D, null);
    }), s18;
}
function Ci(t1, e8, n8, r15, o18) {
    var a18 = Xt(n8, r15);
    return wi(t1, e8, a18[0], a18[1], o18.internalFormatFloat, o18.textureFormatFloat, t1.FLOAT);
}
function Ei(t1, e8, n8, r15, o18) {
    var a18 = Xt(n8, r15);
    return wi(t1, e8, a18[0], a18[1], o18.internalFormatHalfFloat, o18.textureFormatFloat, o18.textureTypeHalfFloat);
}
function Ri(t1, e8, n8, r15, o18) {
    var a18 = Xt(n8, r15);
    return wi(t1, e8, a18[0], a18[1], t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE);
}
function Ii(t1, e8, n8, r15, o18) {
    var a18 = $t(n8, r15);
    return wi(t1, e8, a18[0], a18[1], o18.internalFormatPackedFloat, t1.RGBA, t1.FLOAT);
}
function ki(t1, e8, n8, r15, o18) {
    var a18 = $t(n8, r15);
    return wi(t1, e8, a18[0], a18[1], o18.internalFormatPackedHalfFloat, t1.RGBA, o18.textureTypeHalfFloat);
}
function Si(t1, e8, n8, r15) {
    return Jt(t1, e8, function() {
        return t1.bindBuffer(t1.ARRAY_BUFFER, r15);
    }), ge(t1, e8, n8, "clipSpacePos", r15, 3, 20, 0) && ge(t1, e8, n8, "uv", r15, 2, 20, 12);
}
function Ai(t1, e8, n8, r15, o18, a18, i18) {
    var s18, u7, c4;
    Jt(t1, e8, function() {
        return t1.bindTexture(t1.TEXTURE_2D, n8);
    }), a18 instanceof Uint8Array ? (s18 = new Uint8Array(r15 * o18 * 4), u7 = t1.UNSIGNED_BYTE, c4 = t1.RGBA) : (s18 = new Float32Array(r15 * o18 * 4), u7 = t1.FLOAT, c4 = i18.internalFormatPackedFloat), s18.set(a18), Jt(t1, e8, function() {
        return t1.texImage2D(t1.TEXTURE_2D, 0, c4, r15, o18, 0, t1.RGBA, u7, s18);
    }), Jt(t1, e8, function() {
        return t1.bindTexture(t1.TEXTURE_2D, null);
    });
}
function Di(t1, e8, n8, r15) {
    Jt(t1, e8, function() {
        return t1.bindTexture(t1.TEXTURE_2D, n8);
    }), r15.data instanceof Uint8Array ? Jt(t1, e8, function() {
        return t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, r15.width, r15.height, 0, t1.RGBA, t1.UNSIGNED_BYTE, r15.data);
    }) : Jt(t1, e8, function() {
        return t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, r15);
    }), Jt(t1, e8, function() {
        return t1.bindTexture(t1.TEXTURE_2D, null);
    });
}
function Ti(t1, e8, n8, r15, o18) {
    var a18 = t1.createBuffer();
    Jt(t1, e8, function() {
        return t1.bindBuffer(t1.PIXEL_PACK_BUFFER, a18);
    });
    var i18 = 16 * n8 * r15;
    return Jt(t1, e8, function() {
        return t1.bufferData(t1.PIXEL_PACK_BUFFER, i18, t1.STREAM_READ);
    }), Jt(t1, e8, function() {
        return t1.readPixels(0, 0, r15, n8, t1.RGBA, t1.FLOAT, 0);
    }), Jt(t1, e8, function() {
        return t1.bindBuffer(t1.PIXEL_PACK_BUFFER, null);
    }), a18;
}
function Ni(t1, e8, n8) {
    var r15 = t1, o18 = new Float32Array(n8);
    return r15.bindBuffer(r15.PIXEL_PACK_BUFFER, e8), r15.getBufferSubData(r15.PIXEL_PACK_BUFFER, 0, o18), r15.bindBuffer(r15.PIXEL_PACK_BUFFER, null), o18;
}
function Fi(t1, e8, n8, r15, o18) {
    var a18 = Xt(n8, r15), i18 = a18[0], s18 = a18[1], u7 = new Uint8Array(n8 * r15 * 4);
    return Jt(t1, e8, function() {
        return t1.readPixels(0, 0, i18, s18, o18.downloadTextureFormat, t1.UNSIGNED_BYTE, u7);
    }), new Float32Array(u7.buffer);
}
function _i(t1, e8, n8, r15, o18, a18, i18, s18) {
    var u7 = t1, c4 = new Float32Array(function(t5, e9) {
        var n11 = $t(t5, e9);
        return n11[0] * n11[1] * 4;
    }(a18, i18));
    return u7.bindBuffer(u7.PIXEL_PACK_BUFFER, e8), u7.getBufferSubData(u7.PIXEL_PACK_BUFFER, 0, c4), u7.bindBuffer(u7.PIXEL_PACK_BUFFER, null), c4;
}
function Oi(t1, e8, n8, r15) {
    var o18 = new Float32Array(n8 * r15 * 4);
    return Jt(t1, e8, function() {
        return t1.readPixels(0, 0, r15, n8, t1.RGBA, t1.FLOAT, o18);
    }), o18;
}
var Mi = Object.freeze({
    createVertexShader: yi,
    createVertexBuffer: xi,
    createIndexBuffer: bi,
    createFloat32MatrixTexture: Ci,
    createFloat16MatrixTexture: Ei,
    createUnsignedBytesMatrixTexture: Ri,
    createPackedMatrixTexture: Ii,
    createFloat16PackedMatrixTexture: ki,
    bindVertexProgramAttributeStreams: Si,
    uploadDenseMatrixToTexture: Ai,
    uploadPixelDataToTexture: Di,
    createBufferFromOutputTexture: Ti,
    downloadFloat32MatrixFromBuffer: Ni,
    downloadByteEncodedFloatMatrixFromOutputTexture: Fi,
    downloadPackedMatrixFromBuffer: _i,
    downloadMatrixFromPackedOutputTexture: Oi
}), Bi = function() {
    function t1(t5) {
        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
        var e8 = i15().getNumber("WEBGL_VERSION");
        null != t5 ? (this.gl = t5, Kt(e8, t5)) : this.gl = jt(e8);
        var n8 = "WEBGL_color_buffer_float";
        if (1 === i15().getNumber("WEBGL_VERSION")) {
            if (this.textureFloatExtension = re(this.gl, this.debug, "OES_texture_float"), Pe(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = re(this.gl, this.debug, "OES_texture_half_float");
            else if (i15().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
            if (this.colorBufferFloatExtension = this.gl.getExtension(n8), Pe(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, "EXT_color_buffer_half_float");
            else if (i15().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        } else if (n8 = "EXT_color_buffer_float", Pe(this.gl, n8)) this.colorBufferFloatExtension = this.gl.getExtension(n8);
        else {
            if (!Pe(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
            this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
        }
        this.vertexBuffer = xi(this.gl, this.debug), this.indexBuffer = bi(this.gl, this.debug), this.framebuffer = me(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);
    }
    return Object.defineProperty(t1.prototype, "debug", {
        get: function() {
            return i15().getBool("DEBUG");
        },
        enumerable: !0,
        configurable: !0
    }), t1.prototype.dispose = function() {
        var t5 = this;
        if (!this.disposed) {
            null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
            var e8 = this.gl;
            Jt(e8, this.debug, function() {
                return e8.finish();
            }), Jt(e8, this.debug, function() {
                return e8.bindFramebuffer(e8.FRAMEBUFFER, null);
            }), Jt(e8, this.debug, function() {
                return e8.deleteFramebuffer(t5.framebuffer);
            }), Jt(e8, this.debug, function() {
                return e8.bindBuffer(e8.ARRAY_BUFFER, null);
            }), Jt(e8, this.debug, function() {
                return e8.bindBuffer(e8.ELEMENT_ARRAY_BUFFER, null);
            }), Jt(e8, this.debug, function() {
                return e8.deleteBuffer(t5.indexBuffer);
            }), this.disposed = !0;
        }
    }, t1.prototype.createFloat32MatrixTexture = function(t5, e9) {
        return this.throwIfDisposed(), Ci(this.gl, this.debug, t5, e9, this.textureConfig);
    }, t1.prototype.createFloat16MatrixTexture = function(t5, e9) {
        return this.throwIfDisposed(), Ei(this.gl, this.debug, t5, e9, this.textureConfig);
    }, t1.prototype.createUnsignedBytesMatrixTexture = function(t5, e9) {
        return this.throwIfDisposed(), Ri(this.gl, this.debug, t5, e9, this.textureConfig);
    }, t1.prototype.uploadPixelDataToTexture = function(t5, e9) {
        this.throwIfDisposed(), Di(this.gl, this.debug, t5, e9);
    }, t1.prototype.uploadDenseMatrixToTexture = function(t5, e9, n8, r15) {
        this.throwIfDisposed(), Ai(this.gl, this.debug, t5, e9, n8, r15, this.textureConfig);
    }, t1.prototype.createFloat16PackedMatrixTexture = function(t5, e9) {
        return this.throwIfDisposed(), ki(this.gl, this.debug, t5, e9, this.textureConfig);
    }, t1.prototype.createPackedMatrixTexture = function(t5, e9) {
        return this.throwIfDisposed(), Ii(this.gl, this.debug, t5, e9, this.textureConfig);
    }, t1.prototype.deleteMatrixTexture = function(t5) {
        var e9 = this;
        this.throwIfDisposed(), this.outputTexture === t5 && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function() {
            return e9.gl.deleteTexture(t5);
        });
    }, t1.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t5, e9, n8) {
        var r15 = this;
        return this.downloadMatrixDriver(t5, function() {
            return Fi(r15.gl, r15.debug, e9, n8, r15.textureConfig);
        });
    }, t1.prototype.downloadPackedMatrixFromBuffer = function(t5, e9, n8, r15, o18, a18) {
        return _i(this.gl, t5, 0, 0, 0, o18, a18, this.textureConfig);
    }, t1.prototype.downloadFloat32MatrixFromBuffer = function(t5, e9) {
        return Ni(this.gl, t5, e9);
    }, t1.prototype.createBufferFromTexture = function(t5, e9, n8) {
        this.bindTextureToFrameBuffer(t5);
        var r15 = Ti(this.gl, this.debug, e9, n8, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), r15;
    }, t1.prototype.createAndWaitForFence = function() {
        var t5 = this.createFence(this.gl);
        return this.pollFence(t5);
    }, t1.prototype.createFence = function(t5) {
        var e9, n8, r15 = this;
        if (i15().getBool("WEBGL_FENCE_API_ENABLED")) {
            var o18 = t5, a18 = o18.fenceSync(o18.SYNC_GPU_COMMANDS_COMPLETE, 0);
            t5.flush(), n8 = function() {
                var t7 = o18.clientWaitSync(a18, 0, 0);
                return t7 === o18.ALREADY_SIGNALED || t7 === o18.CONDITION_SATISFIED;
            }, e9 = a18;
        } else i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e9 = this.beginQuery(), this.endQuery(), n8 = function() {
            return r15.isQueryAvailable(e9, i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        }) : n8 = function() {
            return !0;
        };
        return {
            query: e9,
            isFencePassed: n8
        };
    }, t1.prototype.downloadMatrixFromPackedTexture = function(t5, e9, n8) {
        var r15 = this;
        return this.downloadMatrixDriver(t5, function() {
            return Oi(r15.gl, r15.debug, e9, n8);
        });
    }, t1.prototype.createProgram = function(t5) {
        this.throwIfDisposed();
        var e9 = this.gl, n8 = ae(e9, this.debug, t5), r15 = yi(e9, this.debug), o19 = ce(e9, this.debug);
        return Jt(e9, this.debug, function() {
            return e9.attachShader(o19, r15);
        }), Jt(e9, this.debug, function() {
            return e9.attachShader(o19, n8);
        }), le(e9, this.debug, o19), this.debug && he(e9, this.debug, o19), this.vertexAttrsAreBound || (this.setProgram(o19), this.vertexAttrsAreBound = Si(e9, this.debug, this.program, this.vertexBuffer)), o19;
    }, t1.prototype.deleteProgram = function(t5) {
        var e9 = this;
        this.throwIfDisposed(), t5 === this.program && (this.program = null), null != t5 && Jt(this.gl, this.debug, function() {
            return e9.gl.deleteProgram(t5);
        });
    }, t1.prototype.setProgram = function(t5) {
        var e9 = this;
        this.throwIfDisposed(), this.program = t5, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function() {
            return e9.gl.useProgram(t5);
        });
    }, t1.prototype.getUniformLocation = function(t5, e9, n8) {
        return (void 0) === n8 && (n8 = !0), this.throwIfDisposed(), n8 ? xe(this.gl, this.debug, t5, e9) : be(this.gl, t5, e9);
    }, t1.prototype.getAttributeLocation = function(t5, e9) {
        var n8 = this;
        return this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return n8.gl.getAttribLocation(t5, e9);
        });
    }, t1.prototype.getUniformLocationNoThrow = function(t5, e9) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t5, e9);
    }, t1.prototype.setInputMatrixTexture = function(t5, e9, n8) {
        this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t5, e9, n8);
    }, t1.prototype.setOutputMatrixTexture = function(t5, e9, n8) {
        this.setOutputMatrixTextureDriver(t5, n8, e9);
    }, t1.prototype.setOutputPackedMatrixTexture = function(t5, e9, n8) {
        this.throwIfDisposed();
        var r15 = $t(e9, n8), o19 = r15[0], a19 = r15[1];
        this.setOutputMatrixTextureDriver(t5, o19, a19);
    }, t1.prototype.setOutputMatrixWriteRegion = function(t5, e9, n8, r15) {
        this.setOutputMatrixWriteRegionDriver(n8, t5, r15, e9);
    }, t1.prototype.setOutputPackedMatrixWriteRegion = function(t5, e9, n8, r15) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }, t1.prototype.debugValidate = function() {
        null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);
    }, t1.prototype.executeProgram = function() {
        this.throwIfDisposed(), this.throwIfNoProgram();
        var t5 = this.gl;
        this.debug && this.debugValidate(), Jt(t5, this.debug, function() {
            return t5.drawElements(t5.TRIANGLES, 6, t5.UNSIGNED_SHORT, 0);
        });
    }, t1.prototype.blockUntilAllProgramsCompleted = function() {
        var t5 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return t5.gl.finish();
        });
    }, t1.prototype.getQueryTimerExtension = function() {
        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }, t1.prototype.getQueryTimerExtensionWebGL2 = function() {
        return this.getQueryTimerExtension();
    }, t1.prototype.getQueryTimerExtensionWebGL1 = function() {
        return this.getQueryTimerExtension();
    }, t1.prototype.beginQuery = function() {
        if (2 === i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var t5 = this.gl, e9 = this.getQueryTimerExtensionWebGL2(), n8 = t5.createQuery();
            return t5.beginQuery(e9.TIME_ELAPSED_EXT, n8), n8;
        }
        var r15 = this.getQueryTimerExtensionWebGL1(), o19 = r15.createQueryEXT();
        return r15.beginQueryEXT(r15.TIME_ELAPSED_EXT, o19), o19;
    }, t1.prototype.endQuery = function() {
        if (2 !== i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var t7 = this.getQueryTimerExtensionWebGL1();
            t7.endQueryEXT(t7.TIME_ELAPSED_EXT);
        } else {
            var e10 = this.gl, n11 = this.getQueryTimerExtensionWebGL2();
            e10.endQuery(n11.TIME_ELAPSED_EXT);
        }
    }, t1.prototype.waitForQueryAndGetTime = function(t8) {
        return n10(this, void 0, void 0, function() {
            var e11 = this;
            return r17(this, function(n12) {
                switch(n12.label){
                    case 0:
                        return [
                            4,
                            F(function() {
                                return e11.disposed || e11.isQueryAvailable(t8, i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                            })
                        ];
                    case 1:
                        return n12.sent(), [
                            2,
                            this.getQueryTime(t8, i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                        ];
                }
            });
        });
    }, t1.prototype.getQueryTime = function(t8, e11) {
        if (0 === e11) return null;
        if (2 === e11) {
            var n12 = this.gl;
            return n12.getQueryParameter(t8, n12.QUERY_RESULT) / 1000000;
        }
        var r15 = this.getQueryTimerExtensionWebGL1();
        return r15.getQueryObjectEXT(t8, r15.QUERY_RESULT_EXT) / 1000000;
    }, t1.prototype.isQueryAvailable = function(t8, e11) {
        if (0 === e11) return !0;
        if (2 === e11) {
            var n13 = this.gl, r15 = this.getQueryTimerExtensionWebGL2(), o19 = n13.getQueryParameter(t8, n13.QUERY_RESULT_AVAILABLE);
            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r15.GPU_DISJOINT_EXT)), o19 && !this.disjoint;
        }
        o19 = (r15 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t8, r15.QUERY_RESULT_AVAILABLE_EXT);
        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r15.GPU_DISJOINT_EXT)), o19 && !this.disjoint;
    }, t1.prototype.pollFence = function(t8) {
        var e11 = this;
        return new Promise(function(n14) {
            e11.addItemToPoll(function() {
                return t8.isFencePassed();
            }, function() {
                return n14();
            });
        });
    }, t1.prototype.pollItems = function() {
        for(var t8 = function(t9) {
            for(var e11 = 0; e11 < t9.length; ++e11){
                if (!t9[e11]()) break;
            }
            return e11 - 1;
        }(this.itemsToPoll.map(function(t9) {
            return t9.isDoneFn;
        })), e11 = 0; e11 <= t8; ++e11)this.itemsToPoll[e11].resolveFn();
        this.itemsToPoll = this.itemsToPoll.slice(t8 + 1);
    }, t1.prototype.addItemToPoll = function(t8, e11) {
        var n14 = this;
        this.itemsToPoll.push({
            isDoneFn: t8,
            resolveFn: e11
        }), this.itemsToPoll.length > 1 || F(function() {
            return n14.pollItems(), 0 === n14.itemsToPoll.length;
        });
    }, t1.prototype.bindTextureToFrameBuffer = function(t8) {
        this.throwIfDisposed(), Ce(this.gl, this.debug, t8, this.framebuffer), this.debug && Re(this.gl);
    }, t1.prototype.unbindTextureToFrameBuffer = function() {
        null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);
    }, t1.prototype.downloadMatrixDriver = function(t8, e11) {
        this.bindTextureToFrameBuffer(t8);
        var n14 = e11();
        return this.unbindTextureToFrameBuffer(), n14;
    }, t1.prototype.setOutputMatrixTextureDriver = function(t8, e11, n14) {
        this.throwIfDisposed();
        var r18 = this.gl;
        Ce(r18, this.debug, t8, this.framebuffer), this.debug && Re(r18), this.outputTexture = t8, Jt(r18, this.debug, function() {
            return r18.viewport(0, 0, e11, n14);
        }), Jt(r18, this.debug, function() {
            return r18.scissor(0, 0, e11, n14);
        });
    }, t1.prototype.setOutputMatrixWriteRegionDriver = function(t8, e11, n14, r18) {
        var o20 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return o20.gl.scissor(t8, e11, n14, r18);
        });
    }, t1.prototype.throwIfDisposed = function() {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }, t1.prototype.throwIfNoProgram = function() {
        if (null == this.program) throw new Error("No GPU program is currently set.");
    }, t1;
}();
function Pi(t1, e11) {
    if (t1.length !== e11.length) throw Error("Binary was compiled with " + t1.length + " inputs, but was executed with " + e11.length + " inputs");
    t1.forEach(function(t8, n14) {
        var r18 = t8.logicalShape, o20 = e11[n14], a19 = o20.shape;
        if (!S(r18, a19)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r18 + " and " + a19 + " must match");
        if (!t8.isUniform || !o20.isUniform) {
            var i18 = t8.texShape, s18 = o20.isUniform ? null : o20.texData.texShape;
            if (!S(i18, s18)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i18 + " and " + s18 + " must match");
        }
    });
}
var Li = function(t1, e11, n14) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t1;
    for(var r18 = n14.filterWidth, o20 = n14.inChannels, a19 = n14.strideWidth, i19 = n14.strideHeight, s19 = n14.padInfo, u7 = n14.outWidth, c4 = n14.dilationWidth, l6 = n14.dilationHeight, h5 = n14.dataFormat, f6 = s19.left, d7 = s19.top, p7 = o20 * r18, v7 = ua(), m8 = "channelsLast" === h5, g7 = m8 ? 0 : 1, y5 = m8 ? 1 : 2, x5 = "", b1 = 0; b1 <= 1; b1++)for(var w1 = 0; w1 <= 1; w1++)x5 += "\n          blockIndex = rc.y + " + w1 + ";\n          pos = rc.x + " + b1 + ";\n\n          if(blockIndex < " + t1[1] + " && pos < " + t1[0] + ") {\n            offsetY = int(blockIndex / (" + u7 + ")) * " + i19 + " - " + d7 + ";\n            d0 = offsetY + " + l6 + " * (pos / " + p7 + ");\n\n            if(d0 < " + e11[g7] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u7 + ".) * " + a19 + ". - " + f6 + ".);\n              d1 = offsetX + " + c4 + " * (int(mod(float(pos), " + p7 + ".) / " + o20 + ".));\n\n              if(d1 < " + e11[y5] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o20 + ".));\n\n                if (" + m8 + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b1 + w1) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b1 + w1) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x5 + "\n\n        " + v7.output + " = result;\n      }\n    ";
}, Wi = function(t1, e11, n14, r18, o20) {
    this.variableNames = [
        "x"
    ], this.outputShape = [];
    var a19, i19 = e11, s19 = t1[3] - 1;
    this.outputShape = t1;
    var u7 = "float(" + n14 + ") + float(" + r18 + ") * sum";
    a19 = 0.5 === o20 ? "inversesqrt(" + u7 + ")" : 1 === o20 ? "1.0/(" + u7 + ")" : "exp(log(" + u7 + ") * float(-" + o20 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i19 + "; j <= " + i19 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s19 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a19 + ";\n        setOutput(val);\n      }\n    ";
}, Ui = function(t1, e11, n14, r18, o20) {
    this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
    ], this.outputShape = [], this.outputShape = t1, this.depth = t1[3], this.depthRadius = e11, this.bias = n14, this.alpha = r18, this.beta = o20, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e11 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e11 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r18 + ") * norm + float(" + n14 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r18 + ")\n                * float(" + o20 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o20 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
}, Vi = function(t1, e11, n14, r18, o20) {
    this.variableNames = [
        "x"
    ], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    var a19, i19 = e11, s19 = t1[3] - 1;
    this.outputShape = t1;
    var u7 = "float(" + n14 + ") + float(" + r18 + ") * sum";
    a19 = 0.5 === o20 ? "inversesqrt(" + u7 + ")" : 1 === o20 ? "1.0/(" + u7 + ")" : "exp(log(" + u7 + ") * float(-" + o20 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i19 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i19 + "; j <= " + i19 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s19 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a19 + ";\n        setOutput(result);\n      }\n    ";
}, zi = function(t1) {
    this.variableNames = [
        "dy",
        "maxPos"
    ], this.outputShape = t1.inShape;
    var e11 = t1.strideHeight, n14 = t1.strideWidth, r18 = t1.dilationHeight, o20 = t1.effectiveFilterHeight, a19 = t1.effectiveFilterWidth, i19 = o20 - 1 - t1.padInfo.top, s19 = a19 - 1 - t1.padInfo.left, u7 = o20 * a19 - 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i19 + ", " + s19 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o20 + ";\n          wR += " + r18 + ") {\n          float dyR = float(dyRCorner + wR) / " + e11 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a19 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n14 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u7 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a19 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Gi = function(t1) {
    this.variableNames = [
        "dy",
        "maxPos"
    ], this.outputShape = t1.inShape;
    var e11 = t1.strideDepth, n14 = t1.strideHeight, r18 = t1.strideWidth, o20 = t1.dilationDepth, a19 = t1.dilationHeight, i19 = t1.dilationWidth, s19 = t1.effectiveFilterDepth, u7 = t1.effectiveFilterHeight, c4 = t1.effectiveFilterWidth, l6 = s19 - 1 - t1.padInfo.front, h5 = u7 - 1 - t1.padInfo.top, f6 = c4 - 1 - t1.padInfo.left, d7 = s19 * u7 * c4 - 1;
    this.userCode = "\n      const ivec3 pads = ivec3(" + l6 + ", " + h5 + ", " + f6 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s19 + ";\n           wD += " + o20 + ") {\n          float dyD = float(dyDCorner + wD) / " + e11 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t1.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u7 + ";\n              wR += " + a19 + ") {\n            float dyR = float(dyRCorner + wR) / " + n14 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t1.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c4 + ";\n                wC += " + i19 + ") {\n              float dyC = float(dyCCorner + wC) / " + r18 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t1.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + d7 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u7 + " * " + c4 + " +\n                  wR * " + c4 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Hi = function(t1, e11, n14, r18, o20, a19, i19) {
    (void 0) === n14 && (n14 = !1), (void 0) === r18 && (r18 = !1), (void 0) === o20 && (o20 = !1), (void 0) === a19 && (a19 = null), (void 0) === i19 && (i19 = !1), this.variableNames = [
        "matrixA",
        "matrixB"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e11;
    var s19 = n14 ? t1[1] : t1[2], u7 = Math.ceil(s19 / 2), c4 = n14 ? "i * 2, rc.y" : "rc.y, i * 2", l6 = r18 ? "rc.z, i * 2" : "i * 2, rc.z", h5 = n14 ? [
        "a.xxyy",
        "a.zzww"
    ] : [
        "a.xxzz",
        "a.yyww"
    ], f6 = r18 ? [
        "b.xzxz",
        "b.ywyw"
    ] : [
        "b.xyxy",
        "b.zwzw"
    ], d7 = "", p7 = "";
    a19 && (d7 = i19 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a19 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a19 + "\n        }", p7 = "result = activation(result);");
    var v7 = o20 ? "result += getBiasAtOutCoords();" : "";
    o20 && this.variableNames.push("bias"), i19 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + d7 + "\n\n      const float sharedDimension = " + u7 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u7 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c4 + ");\n          vec4 b = getMatrixB(rc.x, " + l6 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h5[0] + " * " + f6[0] + ");\n          result += (" + h5[1] + " * " + f6[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v7 + "\n\n        " + p7 + "\n\n        setOutput(result);\n      }\n    ";
}, qi = function() {
    function t1(t8, e11, n14) {
        this.variableNames = [
            "probs"
        ], this.outputShape = [
            t8,
            n14
        ], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e11 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e11 - 1) + "));\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t8) {
        var e11 = this;
        return function(n14, r18) {
            null == e11.seedLoc && (e11.seedLoc = n14.getUniformLocation(r18, "seed")), n14.gl.uniform1f(e11.seedLoc, t8);
        };
    }, t1;
}(), Ki = function(t1, e11, n14, r18) {
    this.variableNames = [
        "indices"
    ], this.outputShape = [
        t1,
        e11
    ], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r18 + "), float(" + n14 + "),\n                      float(index == coords.y)));\n      }\n    ";
}, ji = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t1;
    var e11 = t1.length;
    if (0 === e11) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
        var n14 = sa("rc", e11), r18 = wa(e11), o20 = function(t8, e12, n15) {
            if (1 === t8) return "rc > " + e12[0];
            for(var r19 = "", o21 = t8 - 2; o21 < t8; o21++)r19 += n15[o21] + " >= " + e12[o21], o21 < t8 - 1 && (r19 += "||");
            return r19;
        }(e11, t1, n14), a19 = function(t8, e12, n15, r19) {
            if (1 === t8) return "";
            var o21 = r19.slice(-2);
            return "\n    int r = " + o21[0] + ";\n    int c = " + o21[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e12 + ";\n    bool rEdge = rp1 >= " + n15 + ";\n  ";
        }(e11, t1[t1.length - 1], t1[t1.length - 2], n14), i19 = function(t8, e12) {
            var n15 = t8.length, r19 = function(t9, e13) {
                for(var n16 = [], r20 = 0; r20 <= 1; r20++)for(var o21 = 0; o21 <= 1; o21++){
                    for(var a20 = (0 === r20 ? "r" : "rp1") + ", " + (0 === o21 ? "c" : "cp1"), i20 = 2; i20 < t9; i20++)a20 = e13[e13.length - 1 - i20] + "," + a20;
                    n16.push(a20);
                }
                return n16;
            }(n15, e12);
            return 1 === n15 ? "getA(rc),\n            rc + 1 >= " + t8[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r19[0] + "),\n          cEdge ? 0. : getA(" + r19[1] + "),\n          rEdge ? 0. : getA(" + r19[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r19[3] + ")";
        }(t1, n14);
        this.userCode = "\n        void main() {\n          " + r18 + " rc = getOutputCoords();\n\n          if(" + o20 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a19 + "\n\n            setOutput(vec4(" + i19 + "));\n          }\n        }\n      ";
    }
};
var Xi = function(t1, e11, n15) {
    this.variableNames = [
        "x"
    ], this.outputShape = e11.map(function(e12, n16) {
        return e12[0] + t1[n16] + e12[1];
    });
    var r19 = t1.length, o21 = wa(r19), a21 = e11.map(function(t8) {
        return t8[0];
    }).join(","), i21 = e11.map(function(e12, n16) {
        return e12[0] + t1[n16];
    }).join(","), s19 = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
    ].slice(0, r19);
    this.userCode = 1 !== r19 ? "\n      " + o21 + " start = " + o21 + "(" + a21 + ");\n      " + o21 + " end = " + o21 + "(" + i21 + ");\n\n      void main() {\n        " + o21 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n15 + "));\n        } else {\n          " + o21 + " coords = outC - start;\n          setOutput(getX(" + s19 + "));\n        }\n      }\n    " : "\n        int start = " + a21 + ";\n        int end = " + i21 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n15 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
}, Yi = function(t1, e11, n15) {
    this.variableNames = [
        "x"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e11.map(function(e12, n16) {
        return e12[0] + t1[n16] + e12[1];
    });
    for(var r19 = t1.length, o21 = wa(r19), a21 = e11.map(function(t8) {
        return t8[0];
    }).join(","), i21 = e11.map(function(e12, n16) {
        return e12[0] + t1[n16];
    }).join(","), s19 = sa("rc", r19), u7 = sa("source", r19), c4 = s19[r19 - 1] + " < " + this.outputShape[r19 - 1], l6 = 1 === r19 ? "source" : "vec2(" + u7.slice(-2).join() + ")", h5 = [
        o21 + " rc = outputLoc;",
        s19[r19 - 1] + " += 1;\n       if(" + c4 + ") {\n      ",
        1 === r19 ? "" : "}\n       rc = outputLoc;\n       " + s19[r19 - 2] + " += 1;\n       if(" + s19[r19 - 2] + " < " + this.outputShape[r19 - 2] + ") {",
        1 === r19 ? "" : "  " + s19[r19 - 1] + " += 1;\n         if(" + c4 + ") {"
    ], f6 = 1 === r19 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", d7 = "", p7 = 0, v7 = 1 === r19 ? 2 : 4; p7 < v7; p7++)d7 += "\n        " + h5[p7] + "\n        if (" + f6 + ") {\n          result[" + p7 + "] = float(" + n15 + ");\n        } else {\n          " + o21 + " source = rc - start;\n          result[" + p7 + "] = getChannel(getX(" + u7.join() + "), " + l6 + ");\n        }\n      ";
    d7 += 1 === r19 ? "} " : "}}", this.userCode = "\n      const " + o21 + " start = " + o21 + "(" + a21 + ");\n      const " + o21 + " end = " + o21 + "(" + i21 + ");\n\n      void main() {\n        " + o21 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + d7 + "\n        setOutput(result);\n      }\n    ";
}, $i = function(t1, e11, n15) {
    if (this.variableNames = [
        "x"
    ], "avg" === e11 && n15) throw new Error("Cannot compute positions for average pool.");
    var r19 = t1.filterWidth, o21 = t1.strideHeight, a21 = t1.strideWidth, i21 = t1.dilationHeight, s19 = t1.dilationWidth, u7 = t1.effectiveFilterHeight, c4 = t1.effectiveFilterWidth, l6 = t1.padInfo.top, h5 = t1.padInfo.left;
    this.outputShape = t1.outShape;
    var f6 = "avg" === e11, d7 = "0.0";
    if (f6 || (d7 = "-1.0 / 1e-20"), n15) this.userCode = "\n        const ivec2 strides = ivec2(" + o21 + ", " + a21 + ");\n        const ivec2 pads = ivec2(" + l6 + ", " + h5 + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u7 + ";\n              wR += " + i21 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t1.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c4 + ";\n                wC += " + s19 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t1.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c4 + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
        var p7 = e11 + "(" + e11 + "(" + e11 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e11 && (p7 = "avgValue / count");
        var v7 = 4 * Math.floor(r19 / 4), m8 = r19 % 4, g7 = "\n      if (" + f6 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + o21 + ", " + a21 + ");\n      const ivec2 pads = ivec2(" + l6 + ", " + h5 + ");\n      const float initializationValue = " + d7 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t1.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + d7 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u7 + ";\n            wR += " + i21 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t1.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v7 + "; wC += 4) {\n            int xC = xCCorner + wC * " + s19 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s19 + ", d),\n              getValue(batch, xR, xC + 2 * " + s19 + ", d),\n              getValue(batch, xR, xC + 3 * " + s19 + ", d)\n            );\n\n            " + g7 + "\n          }\n\n          int xC = xCCorner + " + v7 + ";\n          if (" + (1 === m8) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g7 + "\n          } else if (" + (2 === m8) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s19 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g7 + "\n          } else if (" + (3 === m8) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s19 + ", d),\n              getValue(batch, xR, xC + 2 * " + s19 + ", d),\n              initializationValue\n            );\n\n            " + g7 + "\n          }\n        }\n        setOutput(" + p7 + ");\n      }\n    ";
    }
}, Qi = function(t1, e11, n15) {
    if (this.variableNames = [
        "x"
    ], "avg" === e11 && n15) throw new Error("Cannot compute positions for average pool.");
    var r19 = t1.filterWidth, o21 = t1.strideDepth, a21 = t1.strideHeight, i21 = t1.strideWidth, s19 = t1.dilationDepth, u7 = t1.dilationHeight, c4 = t1.dilationWidth, l6 = t1.effectiveFilterDepth, h5 = t1.effectiveFilterHeight, f6 = t1.effectiveFilterWidth, d7 = t1.padInfo.front, p8 = t1.padInfo.top, v8 = t1.padInfo.left;
    this.outputShape = t1.outShape;
    var m9 = "avg" === e11, g8 = "0.0";
    if (m9 || (g8 = "-1.0 / 1e-20"), n15) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o21 + ", " + a21 + ", " + i21 + ");\n        const ivec3 pads = ivec3(" + d7 + ", " + p8 + ", " + v8 + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l6 + ";\n              wD += " + s19 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t1.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h5 + ";\n                wR += " + u7 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t1.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f6 + ";\n                  wC += " + c4 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t1.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h5 + " * " + f6 + " +\n                      wR * " + f6 + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
        var y5 = e11 + "(" + e11 + "(" + e11 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e11 && (y5 = "avgValue / count");
        var x5 = 4 * Math.floor(r19 / 4), b1 = r19 % 4, w1 = "\n      if (" + m9 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o21 + ", " + a21 + ", " + i21 + ");\n      const ivec3 pads = ivec3(" + d7 + ", " + p8 + ", " + v8 + ");\n      const float initializationValue = " + g8 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t1.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g8 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l6 + ";\n            wD += " + s19 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t1.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h5 + ";\n            wR += " + u7 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t1.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x5 + "; wC += 4) {\n              int xC = xCCorner + wC * " + c4 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c4 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c4 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c4 + ", ch)\n              );\n\n              " + w1 + "\n            }\n\n            int xC = xCCorner + " + x5 + ";\n            if (" + (1 === b1) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w1 + "\n            } else if (" + (2 === b1) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c4 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w1 + "\n            } else if (" + (3 === b1) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c4 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c4 + ", ch),\n                initializationValue\n              );\n\n              " + w1 + "\n            }\n          }\n          setOutput(" + y5 + ");\n        }\n      }\n    ";
    }
}, Ji = function(t1, e11) {
    this.variableNames = [
        "x"
    ];
    var n15 = t1.windowSize, r19 = t1.batchSize, o21 = t1.inSize, a21 = Math.ceil(o21 / n15);
    this.outputShape = [
        r19,
        a21
    ];
    var i21 = "0.0", s19 = "";
    "prod" === e11 ? i21 = "1.0" : "min" === e11 ? (i21 = "1.0 / 1e-20", s19 = "min") : "max" === e11 && (i21 = "-1.0 / 1e-20", s19 = "max");
    var u7 = e11 + "(" + e11 + "(" + e11 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "sum" === e11 ? u7 = "sumValue" : "prod" === e11 ? u7 = "prodValue" : "all" === e11 ? u7 = "allValue" : "any" === e11 && (u7 = "anyValue");
    var c4 = 4 * Math.floor(n15 / 4), l6 = n15 % 4, h5 = "\n      if (" + ("sum" === e11) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e11) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s19 + "(values, minMaxValue);\n      }\n    ", f6 = "vec4";
    "all" === e11 ? (i21 = "1.0", h5 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f6 = "bvec4") : "any" === e11 && (i21 = "0.0", h5 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f6 = "bvec4");
    var d7 = "";
    o21 % n15 > 0 && (d7 = "\n        if (inIdx < 0 || inIdx >= " + o21 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i21 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + d7 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n15 + ";\n\n        vec4 minMaxValue = vec4(" + i21 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f6 + " values = " + f6 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h5 + "\n        }\n\n        int inIdx = inOffset + " + c4 + ";\n        if (" + (1 === l6) + ") {\n          " + f6 + " values = " + f6 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h5 + "\n        } else if (" + (2 === l6) + ") {\n          " + f6 + " values = " + f6 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h5 + "\n        } else if (" + (3 === l6) + ") {\n          " + f6 + " values = " + f6 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h5 + "\n        }\n        setOutput(" + u7 + ");\n      }\n    ";
}, Zi = function(t1, e11) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t1;
    for(var n15 = "", r19 = 0; r19 < 4; r19++){
        var o21 = "thisRC = rc;";
        r19 % 2 == 1 && (o21 += "thisRC.z += 1;"), r19 > 1 && (o21 += "thisRC.y += 1;"), n15 += "\n        " + o21 + "\n        " + (r19 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r19 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r19 > 0 ? "}" : "") + "\n      ";
    }
    this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + ca([
        "r",
        "c",
        "d"
    ], e11) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + la(t1) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t1[1] + ";\n        int cols = " + t1[2] + ";\n\n        " + n15 + "\n\n        setOutput(result);\n      }\n    ";
};
var ts = function(t1, e11, n15) {
    this.variableNames = [
        "dy"
    ], this.outputShape = [], this.outputShape = e11.shape;
    var r19 = e11.shape, o22 = r19[1], a21 = r19[2], i21 = t1.shape, s19 = i21[1], u7 = i21[2], c4 = [
        n15 && s19 > 1 ? o22 - 1 : o22,
        n15 && u7 > 1 ? a21 - 1 : a21
    ], l6 = [
        n15 && s19 > 1 ? s19 - 1 : s19,
        n15 && u7 > 1 ? u7 - 1 : u7
    ], h5 = c4[0] / l6[0], f6 = c4[1] / l6[1], d7 = 1 / h5, p8 = 1 / f6, v8 = 2 * Math.ceil(d7) + 2, m9 = 2 * Math.ceil(p8) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h5 + ");\n        const float widthScale = float(" + f6 + ");\n\n        const float invHeightScale = float(" + d7 + ");\n        const float invWidthScale = float(" + p8 + ");\n\n        const int winHeight = int(" + v8 + ");\n        const int winWidth = int(" + m9 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s19 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u7 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o22 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a21 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
}, es = function(t1, e11, n15, r19) {
    this.variableNames = [
        "A"
    ], this.outputShape = [];
    var o22 = t1[0], a21 = t1[1], i21 = t1[2], s19 = t1[3];
    this.outputShape = [
        o22,
        e11,
        n15,
        s19
    ];
    var u7 = [
        r19 && e11 > 1 ? a21 - 1 : a21,
        r19 && n15 > 1 ? i21 - 1 : i21
    ], c4 = [
        r19 && e11 > 1 ? e11 - 1 : e11,
        r19 && n15 > 1 ? n15 - 1 : n15
    ];
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u7[0] / c4[0] + ",\n          " + u7[1] / c4[1] + ");\n      const vec2 inputShapeRC = vec2(" + a21 + ".0, " + i21 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
}, ns = function(t1, e11, n15, r19) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var o22 = t1[0], a21 = t1[1], i21 = t1[2], s19 = t1[3];
    this.outputShape = [
        o22,
        e11,
        n15,
        s19
    ];
    var u7 = [
        r19 && e11 > 1 ? a21 - 1 : a21,
        r19 && n15 > 1 ? i21 - 1 : i21
    ], c4 = [
        r19 && e11 > 1 ? e11 - 1 : e11,
        r19 && n15 > 1 ? n15 - 1 : n15
    ];
    this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u7[0] / c4[0] + ",\n          " + u7[1] / c4[1] + ",\n          " + u7[1] / c4[1] + ");\n      const vec3 inputShapeRC = vec3(" + a21 + ".0, " + i21 + ".0,\n                                     " + i21 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s19 - 1) + ";\n        bool hasNextRow = coords.z < " + (n15 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
}, rs = function(t1, e11, n15) {
    this.variableNames = [
        "dy"
    ], this.outputShape = [], this.outputShape = e11.shape;
    var r19 = e11.shape, o22 = r19[1], a21 = r19[2], i21 = t1.shape, s19 = i21[1], u7 = i21[2], c4 = [
        n15 && s19 > 1 ? o22 - 1 : o22,
        n15 && u7 > 1 ? a21 - 1 : a21
    ], l6 = [
        n15 && s19 > 1 ? s19 - 1 : s19,
        n15 && u7 > 1 ? u7 - 1 : u7
    ], h5 = c4[0] / l6[0], f6 = c4[1] / l6[1], d7 = 1 / h5, p8 = 1 / f6, v8 = 2 * Math.ceil(d7) + 2, m9 = 2 * Math.ceil(p8) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h5 + ");\n        const float widthScale = float(" + f6 + ");\n\n        const float invHeightScale = float(" + d7 + ");\n        const float invWidthScale = float(" + p8 + ");\n\n        const int winHeight = int(" + v8 + ");\n        const int winWidth = int(" + m9 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s19 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u7 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c4[0] + ") *\n                (float(dyR) / float(" + l6[0] + "));\n\n            float sourceFracCol =\n                float(" + c4[1] + ") *\n                  (float(dyC) / float(" + l6[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o22 + ") - 1),\n                " + n15 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a21 + ") - 1),\n                " + n15 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
}, os = function(t1, e11, n15, r19) {
    this.variableNames = [
        "A"
    ], this.outputShape = [];
    var o22 = t1[0], a21 = t1[1], i21 = t1[2], s19 = t1[3];
    this.outputShape = [
        o22,
        e11,
        n15,
        s19
    ];
    var u7 = [
        r19 && e11 > 1 ? a21 - 1 : a21,
        r19 && n15 > 1 ? i21 - 1 : i21
    ], c4 = [
        r19 && e11 > 1 ? e11 - 1 : e11,
        r19 && n15 > 1 ? n15 - 1 : n15
    ], l6 = r19 ? "0.5" : "0.0";
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u7[0] / c4[0] + ",\n          " + u7[1] / c4[1] + ");\n      const vec2 inputShapeRC = vec2(" + a21 + ".0, " + i21 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l6 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
}, as = function(t1, e11) {
    this.variableNames = [
        "x"
    ];
    var n15 = t1.length;
    if (n15 > 4) throw new Error("WebGL backend: Reverse of rank-" + n15 + " tensor is not yet supported");
    if (this.outputShape = t1, 1 !== n15) {
        var r19 = t1.map(function(n16, r20) {
            return (function(n17) {
                return -1 !== e11.indexOf(n17) && 1 !== t1[n17] ? t1[n17] + " - coords[" + n17 + "] - 1" : "coords[" + n17 + "]";
            })(r20);
        }).join(","), o22 = wa(n15);
        this.userCode = "\n      void main() {\n        " + o22 + " coords = getOutputCoords();\n        setOutput(getX(" + r19 + "));\n      }\n    ";
    } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t1[0] + " - coord - 1));\n        }\n      ";
}, is = function(t1, e11) {
    this.variableNames = [
        "x"
    ], this.packedInputs = !0, this.packedOutput = !0;
    var n15 = t1.length;
    if (n15 > 4) throw new Error("WebGL backend: Reverse of rank-" + n15 + " tensor is not yet supported");
    this.outputShape = t1;
    var r20 = sa("rc", n15), o23 = r20[n15 - 1] + " + 1 < " + this.outputShape[n15 - 1], a21 = r20[n15 - 2] + " + 1 < " + this.outputShape[n15 - 2], i21 = wa(n15);
    function s19(n16) {
        var r21 = t1.map(function(r22, o24) {
            return (function(n17, r23) {
                return -1 !== e11.indexOf(n17) && 1 !== t1[n17] ? t1[n17] + " - " + r23[n17] + " - 1" : "" + r23[n17];
            })(o24, n16);
        });
        return "getChannel(getX(" + r21.join(",") + "), vec2(" + r21.slice(-2).join(",") + "))";
    }
    this.userCode = 1 === n15 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t1[0] + " - rc - 1),\n            " + t1[0] + " - rc - 1);\n          if(" + o23 + "){\n              result.g = getChannel(getX(" + t1[0] + " - (rc  + 1) - 1),\n                " + t1[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i21 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + (function(t8) {
        return s19(t8);
    })(r20.slice()) + ";\n          if(" + o23 + "){\n            result.g = " + (function(t8) {
        return t8[n15 - 1] = "(" + t8[n15 - 1] + " + 1)", s19(t8);
    })(r20.slice()) + ";\n          }\n          if(" + a21 + ") {\n            result.b = " + (function(t8) {
        return t8[n15 - 2] = "(" + t8[n15 - 2] + " + 1)", s19(t8);
    })(r20.slice()) + ";\n            if(" + o23 + ") {\n              result.a = " + (function(t8) {
        return t8[n15 - 1] = "(" + t8[n15 - 1] + " + 1)", t8[n15 - 2] = "(" + t8[n15 - 2] + " + 1)", s19(t8);
    })(r20.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
}, ss = function(t1, e11, n15, r20, o23, a21, i21) {
    (void 0) === i21 && (i21 = !0), this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
    ], this.outputShape = a21;
    var s19 = wa(o23.length), u7 = wa(a21.length), c4 = "";
    1 === n15 ? c4 = "i" : 2 === n15 && (c4 = "i, j");
    var l6 = "getIndices(" + c4 + ")", h5 = "";
    1 === r20 ? h5 = "i" : 2 === r20 && (h5 = "i, coords[1]");
    var f6 = "getUpdates(" + h5 + ")", d7 = e11 > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + s19 + " strides = " + s19 + "(" + o23 + ");\n\n        void main() {\n          " + u7 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t1 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e11 + "; j++) {\n              int index = round(" + l6 + ");\n              flattenedIndex += index * " + d7 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f6 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
}, us = function(t1, e11) {
    this.variableNames = [
        "x",
        "segmentIds"
    ];
    var n15 = t1.windowSize, r20 = t1.batchSize, o23 = t1.inSize, a21 = t1.numSegments, i21 = a21 * Math.ceil(o23 / n15);
    this.outputShape = [
        r20,
        i21
    ];
    var s19 = 4 * Math.floor(n15 / 4), u7 = n15 % 4, c4 = "\n        sumValue += dot(values, segFilter);\n    ", l6 = "";
    o23 % n15 > 0 && (l6 = "\n        if (inIdx < 0 || inIdx >= " + o23 + ") {\n          return initializationValue;\n        }\n      ");
    var h5 = "";
    o23 % n15 > 0 && (h5 = "\n        if (inIdx < 0 || inIdx >= " + o23 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l6 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h5 + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a21 + ")) * float(" + n15 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a21 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s19 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c4 + "\n        }\n\n        int inIdx = inOffset + " + s19 + ";\n        if (" + (1 === u7) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c4 + "\n        } else if (" + (2 === u7) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c4 + "\n        } else if (" + (3 === u7) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c4 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
}, cs = function(t1, e11, n15) {
    var r20, o23;
    if (this.variableNames = [
        "c",
        "a",
        "b"
    ], this.outputShape = e11, n15 > 4) throw Error("Where for rank " + n15 + " is not yet supported");
    if (1 === n15) o23 = "resRC", r20 = "resRC";
    else {
        for(var a21 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w"
        ], i21 = [], s19 = [], u7 = 0; u7 < e11.length; u7++)s19.push("" + a21[u7]), u7 < t1 && i21.push("" + a21[u7]);
        r20 = i21.join(), o23 = s19.join();
    }
    var c4 = wa(n15);
    this.userCode = "\n      void main() {\n        " + c4 + " resRC = getOutputCoords();\n        float cVal = getC(" + r20 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o23 + "));\n        } else {\n          setOutput(getB(" + o23 + "));\n        }\n      }\n    ";
}, ls = function() {
    function t1(t8) {
        this.variableNames = [
            "source"
        ], this.outputShape = t8, this.rank = t8.length;
        var e11, n15 = wa(this.rank), r20 = "uniform int start[" + this.rank + "];", o23 = function(t9) {
            if (1 === t9) return "sourceLoc";
            if (t9 <= 6) return hs.slice(0, t9).map(function(t10) {
                return "sourceLoc." + t10;
            }).join(",");
            throw Error("Slicing for rank " + t9 + " is not yet supported");
        }(this.rank);
        e11 = "\n        " + n15 + " sourceLoc;\n        " + n15 + " coords = getOutputCoords();\n        " + t8.map(function(t9, e12) {
            return "sourceLoc." + hs[e12] + " = start[" + e12 + "] + coords." + hs[e12] + ";";
        }).join("\n") + "\n      ", this.userCode = "\n      " + r20 + "\n      void main() {\n        " + e11 + "\n        setOutput(getSource(" + o23 + "));\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t8) {
        var e11 = this;
        if (t8.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t8.length + ")");
        return function(n15, r20) {
            null == e11.startLoc && (e11.startLoc = n15.getUniformLocationNoThrow(r20, "start"), null == e11.startLoc) || n15.gl.uniform1iv(e11.startLoc, t8);
        };
    }, t1;
}(), hs = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
];
var fs = function() {
    function t1(t8) {
        this.variableNames = [
            "source"
        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t8, this.rank = t8.length;
        var e11 = wa(this.rank), n15 = sa("coords", this.rank), r20 = sa("sourceLoc", this.rank), o23 = 1 === this.rank ? "sourceLoc" : "vec2(" + r20.slice(-2).join() + ")", a22 = "getChannel(getSource(" + r20.join() + "), " + o23 + ")", i22 = "\n      result.x = " + a22 + ";\n      if (++" + n15[this.rank - 1] + " < " + t8[this.rank - 1] + ") {\n        ++" + r20[this.rank - 1] + ";\n        result.y = " + a22 + ";\n        --" + r20[this.rank - 1] + ";\n      }\n    ", s20 = 1 === this.rank ? "" : "\n      --" + n15[this.rank - 1] + ";\n      if (++" + n15[this.rank - 2] + " < " + t8[this.rank - 2] + ") {\n        ++" + r20[this.rank - 2] + ";\n        result.z = " + a22 + ";\n        if (++" + n15[this.rank - 1] + " < " + t8[this.rank - 1] + ") {\n          ++" + r20[this.rank - 1] + ";\n          result.w = " + a22 + ";\n        }\n      }\n    ", u8 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e11 + "(" + t8.map(function(t9, e12) {
            return "start[" + e12 + "]";
        }).join() + ");" : t8.map(function(t9, e12) {
            return r20[e12] + " = " + n15[e12] + " + start[" + e12 + "];";
        }).join("\n");
        this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e11 + " coords = getOutputCoords();\n        " + e11 + " sourceLoc;\n        " + u8 + "\n        vec4 result = vec4(0.);\n        " + i22 + "\n        " + s20 + "\n        setOutput(result);\n      }\n    ";
    }
    return t1.prototype.getCustomSetupFunc = function(t8) {
        var e11 = this;
        if (t8.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t8.length + ")");
        return function(n15, r20) {
            null == e11.startLoc && (e11.startLoc = n15.getUniformLocationNoThrow(r20, "start"), null == e11.startLoc) || n15.gl.uniform1iv(e11.startLoc, t8);
        };
    }, t1;
}(), ds = function(t1, e11, n15) {
    this.variableNames = [
        "x"
    ], this.outputShape = n15;
    var r20 = n15.length, o23 = wa(n15.length), a22 = wa(n15.length), i22 = "";
    if (1 === r20) i22 = "coords * strides + begin";
    else {
        var s20 = 0;
        i22 = n15.map(function(t8, e12) {
            return s20++, 1 === n15.length ? "coords * strides[" + e12 + "] + begin[" + e12 + "]" : "coords[" + (s20 - 1) + "] * strides[" + e12 + "] + begin[" + e12 + "]";
        }).join(",");
    }
    this.userCode = "\n      " + o23 + " begin = " + o23 + "(" + t1 + ");\n      " + o23 + " strides = " + o23 + "(" + e11 + ");\n\n      void main() {\n        " + a22 + " coords = getOutputCoords();\n        setOutput(getX(" + i22 + "));\n      }\n    ";
}, ps = function() {
    function t1(t8) {
        this.gpgpu = t8, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {
        }, this.logEnabled = !1, this.usedTextures = {
        };
    }
    return t1.prototype.acquireTexture = function(t8, e11, n15) {
        var r20, o23 = vs(e11, n15), a22 = ms(t8, o23, n15);
        if (a22 in this.freeTextures || (this.freeTextures[a22] = []), a22 in this.usedTextures || (this.usedTextures[a22] = []), this.freeTextures[a22].length > 0) {
            this.numFreeTextures--, this.numUsedTextures++, this.log();
            var i22 = this.freeTextures[a22].shift();
            return this.usedTextures[a22].push(i22), i22;
        }
        return this.numUsedTextures++, this.log(), o23 === Gt.PACKED_2X2_FLOAT32 ? r20 = this.gpgpu.createPackedMatrixTexture(t8[0], t8[1]) : o23 === Gt.PACKED_2X2_FLOAT16 ? r20 = this.gpgpu.createFloat16PackedMatrixTexture(t8[0], t8[1]) : o23 === Gt.UNPACKED_FLOAT32 ? r20 = this.gpgpu.createFloat32MatrixTexture(t8[0], t8[1]) : o23 === Gt.UNPACKED_FLOAT16 ? r20 = this.gpgpu.createFloat16MatrixTexture(t8[0], t8[1]) : o23 === Gt.PACKED_4X1_UNSIGNED_BYTE && (r20 = this.gpgpu.createUnsignedBytesMatrixTexture(t8[0], t8[1])), this.usedTextures[a22].push(r20), r20;
    }, t1.prototype.releaseTexture = function(t8, e11, n15, r20) {
        if (null != this.freeTextures) {
            var o23 = ms(e11, vs(n15, r20), r20);
            o23 in this.freeTextures || (this.freeTextures[o23] = []), this.freeTextures[o23].push(t8), this.numFreeTextures++, this.numUsedTextures--;
            var a22 = this.usedTextures[o23], i23 = a22.indexOf(t8);
            if (i23 < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
            a22.splice(i23, 1), this.log();
        }
    }, t1.prototype.log = function() {
        if (this.logEnabled) {
            var t8 = this.numFreeTextures + this.numUsedTextures;
            console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t8 + ")");
        }
    }, t1.prototype.getNumUsedTextures = function() {
        return this.numUsedTextures;
    }, t1.prototype.getNumFreeTextures = function() {
        return this.numFreeTextures;
    }, t1.prototype.dispose = function() {
        var t9 = this;
        if (null != this.freeTextures) {
            for(var e11 in this.freeTextures)this.freeTextures[e11].forEach(function(e12) {
                t9.gpgpu.deleteMatrixTexture(e12);
            });
            for(var e11 in this.usedTextures)this.usedTextures[e11].forEach(function(e12) {
                t9.gpgpu.deleteMatrixTexture(e12);
            });
            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
        }
    }, t1;
}();
function vs(t1, e12) {
    if (t1 === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
    if (t1 === zt.RENDER || null == t1) return (function(t9) {
        return i15().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t9 ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t9 ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;
    })(e12);
    if (t1 === zt.DOWNLOAD || t1 === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error("Unknown logical texture type " + t1);
}
function ms(t1, e12, n15) {
    return t1[0] + "_" + t1[1] + "_" + e12 + "_" + n15;
}
var gs = function(t1, e12) {
    this.variableNames = [
        "A"
    ];
    for(var n15 = new Array(t1.length), r20 = 0; r20 < n15.length; r20++)n15[r20] = t1[r20] * e12[r20];
    this.outputShape = n15, this.rank = n15.length;
    var o24 = wa(this.rank), a23 = function(t9) {
        var e13 = t9.length;
        if (e13 > 5) throw Error("Tile for rank " + e13 + " is not yet supported");
        if (1 === e13) return "imod(resRC, " + t9[0] + ")";
        for(var n16 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w",
            "resRC.u"
        ], r21 = [], o25 = 0; o25 < t9.length; o25++)r21.push("imod(" + n16[o25] + ", " + t9[o25] + ")");
        return r21.join();
    }(t1);
    this.userCode = "\n      void main() {\n        " + o24 + " resRC = getOutputCoords();\n        setOutput(getA(" + a23 + "));\n      }\n    ";
};
var ys = function(t1, e12) {
    this.variableNames = [
        "A"
    ];
    for(var n15 = new Array(t1.length), r20 = 0; r20 < n15.length; r20++)n15[r20] = t1[e12[r20]];
    this.outputShape = n15, this.rank = n15.length;
    var o24 = wa(this.rank), a23 = function(t9) {
        var e13 = t9.length;
        if (e13 > 6) throw Error("Transpose for rank " + e13 + " is not yet supported");
        for(var n16 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w",
            "resRC.u",
            "resRC.v"
        ], r21 = new Array(e13), o25 = 0; o25 < t9.length; o25++)r21[t9[o25]] = n16[o25];
        return r21.join();
    }(e12);
    this.userCode = "\n    void main() {\n      " + o24 + " resRC = getOutputCoords();\n      setOutput(getA(" + a23 + "));\n    }\n    ";
};
var xs = function(t1, e12) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0;
    for(var n15 = new Array(t1.length), r20 = 0; r20 < n15.length; r20++)n15[r20] = t1[e12[r20]];
    if (this.outputShape = n15, this.rank = n15.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
    var o24 = wa(this.rank), a23 = ia("rc", this.rank), i24 = new Array(this.rank);
    for(r20 = 0; r20 < e12.length; r20++)i24[e12[r20]] = a23[r20];
    var s21 = "vec2(" + i24.slice(-2).join() + ")", u8 = "++" + a23[this.rank - 1] + " < " + n15[this.rank - 1], c4 = "getChannel(getA(" + i24.join() + "), " + s21 + ")";
    this.userCode = "\n    void main() {\n      " + o24 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c4 + ";\n      if(" + u8 + ") {\n        result[1] = " + c4 + ";\n      }\n      --" + a23[this.rank - 1] + ";\n      if(++" + a23[this.rank - 2] + " < " + n15[this.rank - 2] + ") {\n        result[2] = " + c4 + ";\n        if(" + u8 + ") {\n          result[3] = " + c4 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
}, bs = 1.7580993408473768, ws = 1.0507009873554805, Cs = function(t1, e12) {
    this.variableNames = [
        "A"
    ], this.outputShape = t1, this.userCode = "\n      float unaryOperation(float x) {\n        " + e12 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
}, Es = "if (isnan(x)) return x;", Rs = "return x;", Is = "return abs(x);", ks = Es + "\n  return (x < 0.0) ? 0.0 : x;\n", Ss = Es + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n", As = "return (x >= 0.0) ? x : (exp(x) - 1.0);", Ds = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + bs + ";\n  float scale = " + ws + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
var Ts = "return -x;", Ns = "return ceil(x);", Fs = "return floor(x);", _s = "return exp(x);", Os = "return exp(x) - 1.0;", Ms = Es + "\n  return sin(x);\n", Bs = Es + "\n  return cos(x);\n", Ps = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n", Ls = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n", Ws = Es + "\n  return atan(x);\n", Us = Es + "return log(x + sqrt(x * x + 1.0));", Vs = Es + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));", zs = Es + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;", Gs = "return x;", Hs = "return x;", qs = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", Ks = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", js = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n", Xs = function(t1, e12) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t1, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e12 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
}, Ys = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t1;
    var e12 = t1.length, n15 = sa("rc", e12), r20 = wa(e12), o24 = function(t9, e13) {
        if (1 === t9) return "rc";
        for(var n16 = "", r21 = 0; r21 < t9; r21++)n16 += e13[r21], r21 < t9 - 1 && (n16 += ",");
        return n16;
    }(e12, n15), a23 = n15.slice(-2), i24 = e12 <= 1 ? "rc" : "vec2(" + a23.join(",") + ")";
    this.userCode = "\n      void main() {\n        " + r20 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o24 + ");\n\n        setOutput(getChannel(packedInput, " + i24 + "));\n      }\n    ";
}, $s = {
};
function Qs(t1, e12) {
    if ((void 0) === e12 && (e12 = !1), "linear" === t1) return e12 ? Hs : Rs;
    if ("relu" === t1) return e12 ? qs : ks;
    if ("elu" === t1) return e12 ? js : As;
    if ("relu6" === t1) return e12 ? Ks : Ss;
    if ("prelu" === t1) return e12 ? Pa : Ma;
    throw new Error("Activation " + t1 + " has not been implemented for the WebGL backend.");
}
var Js = 600;
var Zs = function(t1) {
    function o24(e12) {
        var n15, r20 = t1.call(this) || this;
        if (r20.pendingRead = new WeakMap, r20.pendingDisposal = new WeakSet, r20.dataRefCount = new WeakMap, r20.numBytesInGPU = 0, r20.uploadWaitMs = 0, r20.downloadWaitMs = 0, r20.warnedAboutMemory = !1, r20.pendingDeletes = 0, r20.disposed = !1, !i15().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        if (null == e12) {
            var o25 = jt(i15().getNumber("WEBGL_VERSION"));
            r20.binaryCache = (n15 = i15().getNumber("WEBGL_VERSION")) in $s ? $s[n15] : ($s[n15] = {
            }, $s[n15]), r20.gpgpu = new Bi(o25), r20.canvas = o25.canvas, r20.gpgpuCreatedLocally = !0;
        } else r20.gpgpu = e12, r20.binaryCache = {
        }, r20.gpgpuCreatedLocally = !1, r20.canvas = e12.gl.canvas;
        return r20.textureManager = new ps(r20.gpgpu), r20.numMBBeforeWarning = null == i15().global.screen ? 1024 : i15().global.screen.height * i15().global.screen.width * window.devicePixelRatio * Js / 1024 / 1024, r20.texData = new xo(r20, Lt), r20;
    }
    return e(o24, t1), o24.prototype.numDataIds = function() {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
    }, o24.prototype.write = function(t9, e12, n15) {
        if (i15().getBool("DEBUG") && this.checkNumericalProblems(t9), "complex64" === n15 && null != t9) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        var r20 = {
        };
        return this.texData.set(r20, {
            shape: e12,
            dtype: n15,
            values: t9,
            usage: zt.UPLOAD
        }), r20;
    }, o24.prototype.move = function(t9, e12, n15, r20) {
        if (i15().getBool("DEBUG") && this.checkNumericalProblems(e12), "complex64" === r20) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t9, {
            shape: n15,
            dtype: r20,
            values: e12,
            usage: zt.UPLOAD
        });
    }, o24.prototype.readSync = function(t9) {
        var e12 = this.texData.get(t9), n15 = e12.values, r20 = e12.dtype, o26 = e12.complexTensors, a23 = e12.slice, i24 = e12.shape, s21 = e12.isPacked;
        if (null != a23) {
            var u8 = void 0;
            u8 = s21 ? new Xs(i24, Gs) : new Cs(i24, Gs);
            var c4 = this.runWebGLProgram(u8, [
                {
                    dataId: t9,
                    shape: i24,
                    dtype: r20
                }
            ], r20), l6 = this.readSync(c4.dataId);
            return this.disposeData(c4.dataId), l6;
        }
        if (null != n15) return this.convertAndCacheOnCPU(t9);
        if ("string" === r20) return n15;
        var h5, f6, d7 = null != this.activeTimers;
        (d7 && (h5 = et()), "complex64" === r20) ? f6 = Vo(o26.real.dataSync(), o26.imag.dataSync()) : f6 = this.getValuesFromTexture(t9);
        return d7 && (this.downloadWaitMs += et() - h5), this.convertAndCacheOnCPU(t9, f6);
    }, o24.prototype.read = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e12, n15, o26, a23, s21, u9, c5, l7, h5, f6, d7, p8, v8, m9, g8, y6, x6, b3, w3, C1, E1, R1;
            return r17(this, function(r20) {
                switch(r20.label){
                    case 0:
                        if (this.pendingRead.has(t9)) return e12 = this.pendingRead.get(t9), [
                            2,
                            new Promise(function(t10) {
                                return e12.push(t10);
                            })
                        ];
                        if (n15 = this.texData.get(t9), o26 = n15.values, a23 = n15.shape, s21 = n15.slice, u9 = n15.dtype, c5 = n15.complexTensors, l7 = n15.isPacked, null != s21) return h5 = void 0, h5 = l7 ? new Xs(a23, Gs) : new Cs(a23, Gs), f6 = this.runWebGLProgram(h5, [
                            {
                                dataId: t9,
                                shape: a23,
                                dtype: u9
                            }
                        ], u9), d7 = this.read(f6.dataId), this.disposeData(f6.dataId), [
                            2,
                            d7
                        ];
                        if (null != o26) return [
                            2,
                            this.convertAndCacheOnCPU(t9)
                        ];
                        if (!i15().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === i15().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                        return p8 = null, "complex64" !== u9 && i15().get("WEBGL_BUFFER_SUPPORTED") && (v8 = this.decode(t9), m9 = this.texData.get(v8.dataId), p8 = (R1 = this.gpgpu).createBufferFromTexture.apply(R1, [
                            m9.texture
                        ].concat(Yt(a23)))), this.pendingRead.set(t9, []), "complex64" === u9 ? [
                            3,
                            2
                        ] : [
                            4,
                            this.gpgpu.createAndWaitForFence()
                        ];
                    case 1:
                        r20.sent(), r20.label = 2;
                    case 2:
                        return "complex64" !== u9 ? [
                            3,
                            4
                        ] : [
                            4,
                            Promise.all([
                                c5.real.data(),
                                c5.imag.data()
                            ])
                        ];
                    case 3:
                        return y6 = r20.sent(), x6 = y6[0], b3 = y6[1], g8 = Vo(x6, b3), [
                            3,
                            5
                        ];
                    case 4:
                        null == p8 ? g8 = this.getValuesFromTexture(t9) : (w3 = k(a23), g8 = this.gpgpu.downloadFloat32MatrixFromBuffer(p8, w3)), r20.label = 5;
                    case 5:
                        return null != v8 && this.disposeData(v8.dataId), C1 = this.convertAndCacheOnCPU(t9, g8), E1 = this.pendingRead.get(t9), this.pendingRead.delete(t9), E1.forEach(function(t10) {
                            return t10(C1);
                        }), this.pendingDisposal.has(t9) && (this.pendingDisposal.delete(t9), this.disposeData(t9), this.pendingDeletes--), [
                            2,
                            C1
                        ];
                }
            });
        });
    }, o24.prototype.checkNumericalProblems = function(t9) {
        if (null != t9) for(var e12 = 0; e12 < t9.length; e12++){
            var n15 = t9[e12];
            if (!ee(n15)) {
                if (i15().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n15 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
                throw Error("The value " + n15 + " cannot be represented on this device.");
            }
        }
    }, o24.prototype.getValuesFromTexture = function(t9) {
        var e12, n16 = this.texData.get(t9), r20 = n16.shape, o26 = n16.dtype, a23 = n16.isPacked, s21 = k(r20);
        if (i15().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
            var u9 = this.decode(t9), c5 = this.texData.get(u9.dataId), l7 = (e12 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e12, [
                c5.texture
            ].concat(Yt(r20))).subarray(0, s21);
            return this.disposeData(u9.dataId), l7;
        }
        var h5 = i15().getBool("WEBGL_PACK") && !0 === a23, f6 = h5 ? Te(r20) : r20, d7 = h5 ? new ci(f6) : new ui(f6), p8 = this.runWebGLProgram(d7, [
            {
                shape: f6,
                dtype: o26,
                dataId: t9
            }
        ], "float32"), v8 = this.texData.get(p8.dataId), m9 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v8.texture, v8.texShape[0], v8.texShape[1]).subarray(0, s21);
        return this.disposeData(p8.dataId), m9;
    }, o24.prototype.time = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e12, n16, o26, a23, s21, u10, c6;
            return r17(this, function(r20) {
                switch(r20.label){
                    case 0:
                        return e12 = this.activeTimers, n16 = [], o26 = !1, null == this.programTimersStack ? (this.programTimersStack = n16, o26 = !0) : this.activeTimers.push(n16), this.activeTimers = n16, t9(), a23 = I(this.activeTimers.map(function(t10) {
                            return t10.query;
                        })).filter(function(t10) {
                            return null != t10;
                        }), s21 = I(this.activeTimers.map(function(t10) {
                            return t10.name;
                        })).filter(function(t10) {
                            return null != t10;
                        }), this.activeTimers = e12, o26 && (this.programTimersStack = null), u10 = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: null,
                            wallMs: null
                        }, i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [
                            4,
                            Promise.all(a23)
                        ] : [
                            3,
                            2
                        ];
                    case 1:
                        return c6 = r20.sent(), u10.kernelMs = w(c6), u10.getExtraProfileInfo = function() {
                            return c6.map(function(t10, e13) {
                                return {
                                    name: s21[e13],
                                    ms: t10
                                };
                            }).map(function(t10) {
                                return t10.name + ": " + t10.ms;
                            }).join(", ");
                        }, [
                            3,
                            3
                        ];
                    case 2:
                        u10.kernelMs = {
                            error: "WebGL query timers are not supported in this environment."
                        }, r20.label = 3;
                    case 3:
                        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [
                            2,
                            u10
                        ];
                }
            });
        });
    }, o24.prototype.memory = function() {
        return {
            unreliable: !1,
            numBytesInGPU: this.numBytesInGPU
        };
    }, o24.prototype.startTimer = function() {
        return i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
            startMs: et(),
            endMs: null
        };
    }, o24.prototype.endTimer = function(t9) {
        return i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t9) : (t9.endMs = et(), t9);
    }, o24.prototype.getQueryTime = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e12;
            return r17(this, function(n16) {
                return i15().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [
                    2,
                    this.gpgpu.waitForQueryAndGetTime(t9)
                ] : [
                    2,
                    (e12 = t9).endMs - e12.startMs
                ];
            });
        });
    }, o24.prototype.disposeData = function(t9) {
        if (!this.pendingDisposal.has(t9)) {
            if (this.pendingRead.has(t9)) return this.pendingDisposal.add(t9), void this.pendingDeletes++;
            if (this.texData.has(t9)) {
                this.releaseGPUData(t9);
                var e12 = this.texData.get(t9).complexTensors;
                null != e12 && (e12.real.dispose(), e12.imag.dispose()), this.texData.delete(t9);
            }
        }
    }, o24.prototype.releaseGPUData = function(t9) {
        var e13 = this.texData.get(t9), n16 = e13.texture, r20 = e13.dtype, o26 = e13.texShape, a23 = e13.usage, i24 = e13.isPacked, s21 = e13.slice, u10 = s21 && s21.origDataId || t9, c6 = this.dataRefCount.get(u10);
        c6 > 1 ? this.dataRefCount.set(u10, c6 - 1) : (this.dataRefCount.delete(u10), null != n16 && (this.numBytesInGPU -= this.computeBytes(o26, r20), this.textureManager.releaseTexture(n16, o26, a23, i24)));
        var l8 = this.texData.get(t9);
        l8.texture = null, l8.texShape = null, l8.isPacked = !1, l8.slice = null;
    }, o24.prototype.getTexture = function(t9) {
        return this.uploadToGPU(t9), this.texData.get(t9).texture;
    }, o24.prototype.getDataInfo = function(t9) {
        return this.texData.get(t9);
    }, o24.prototype.getCPUBackend = function() {
        return i15().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend("cpu")), this.cpuBackend) : null;
    }, o24.prototype.shouldExecuteOnCPU = function(t9, e13) {
        var n16 = this;
        return (void 0) === e13 && (e13 = 128), null != this.getCPUBackend() && t9.every(function(t10) {
            return null == n16.texData.get(t10.dataId).texture && t10.size < e13;
        });
    }, o24.prototype.getGPGPUContext = function() {
        return this.gpgpu;
    }, o24.prototype.complex = function(t9, e13) {
        var n16 = this.makeOutput(t9.shape, "complex64");
        return this.texData.get(n16.dataId).complexTensors = {
            real: Lt.keep(t9.clone()),
            imag: Lt.keep(e13.clone())
        }, n16;
    }, o24.prototype.real = function(t9) {
        return this.texData.get(t9.dataId).complexTensors.real.clone();
    }, o24.prototype.imag = function(t9) {
        return this.texData.get(t9.dataId).complexTensors.imag.clone();
    }, o24.prototype.slice = function(t9, e13, n16) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.slice(t9, e13, n16);
        if (0 === k(n16)) return Fn([], n16, t9.dtype);
        var r20 = this.texData.get(t9.dataId).isPacked, o26 = io(t9.shape, e13, n16);
        if (r20 || !o26) {
            var a23 = i15().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new fs(n16) : new ls(n16), s21 = a23.getCustomSetupFunc(e13);
            return this.compileAndRun(a23, [
                t9
            ], null, s21);
        }
        return this.uploadToGPU(t9.dataId), this.shallowSlice(t9, e13, n16);
    }, o24.prototype.shallowSlice = function(t9, e13, n16) {
        var r20 = this.texData.get(t9.dataId), o26 = this.makeOutput(n16, t9.dtype), a24 = this.texData.get(o26.dataId);
        Object.assign(a24, r20), a24.shape = n16, a24.dtype = t9.dtype;
        var i24 = so(e13, t9.strides);
        r20.slice && (i24 += r20.slice.flatOffset), a24.slice = {
            flatOffset: i24,
            origDataId: r20.slice && r20.slice.origDataId || t9.dataId
        };
        var s22 = this.dataRefCount.get(a24.slice.origDataId) || 1;
        return this.dataRefCount.set(a24.slice.origDataId, s22 + 1), o26;
    }, o24.prototype.stridedSlice = function(t9, e13, n16, r20) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.stridedSlice(t9, e13, n16, r20);
        var o26 = ro(e13, n16, r20);
        if (o26.some(function(t10) {
            return 0 === t10;
        })) return Fn([], o26);
        var a24 = new ds(e13, r20, o26);
        return this.compileAndRun(a24, [
            t9
        ]);
    }, o24.prototype.reverse = function(t9, e13) {
        var n16 = i15().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new is(t9.shape, e13) : new as(t9.shape, e13);
        return this.compileAndRun(n16, [
            t9
        ]);
    }, o24.prototype.concat = function(t9, e13) {
        if ("complex64" === t9[0].dtype) {
            var n16 = t9.map(function(t10) {
                return Tn(t10);
            }), r20 = t9.map(function(t10) {
                return Nn(t10);
            });
            return Dn(this.concat(n16, e13), this.concat(r20, e13));
        }
        if (this.shouldExecuteOnCPU(t9)) return this.cpuBackend.concat(t9, e13);
        if (1 === t9.length) return t9[0];
        if (t9.length > i15().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
            var o26 = Math.floor(t9.length / 2), a24 = this.concat(t9.slice(0, o26), e13), s22 = this.concat(t9.slice(o26), e13);
            return this.concat([
                a24,
                s22
            ], e13);
        }
        if (i15().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t9[0].rank > 1) {
            var u10 = new Ga(t9.map(function(t10) {
                return t10.shape;
            }), e13);
            return this.compileAndRun(u10, t9);
        }
        var c6 = Sn(t9.map(function(t10) {
            return t10.shape;
        }), e13), l8 = t9.map(function(t10) {
            return t10.as2D(-1, k(t10.shape.slice(e13)));
        }), h5 = new za(l8.map(function(t10) {
            return t10.shape;
        }));
        return this.compileAndRun(h5, l8).reshape(c6);
    }, o24.prototype.neg = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.neg(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, Ts, t9.dtype);
        var e13 = new Cs(t9.shape, Ts);
        return this.compileAndRun(e13, [
            t9
        ]);
    }, o24.prototype.batchMatMul = function(t9, e13, n17, r21) {
        var o27 = n17 ? t9.shape[2] : t9.shape[1], a25 = r21 ? e13.shape[1] : e13.shape[2], i24 = n17 ? t9.shape[1] : t9.shape[2], s23 = t9.shape[0];
        if ((1 === o27 || 1 === a25) && i24 > 1000) {
            n17 && (t9 = t9.transpose([
                0,
                2,
                1
            ])), r21 && (e13 = e13.transpose([
                0,
                2,
                1
            ]));
            var u11 = 1 === a25 ? t9 : t9.as3D(s23, i24, 1), c6 = 1 === a25 ? 2 : 1, l8 = 1 === a25 ? e13.as3D(s23, 1, i24) : e13;
            return this.multiply(u11, l8).sum(c6, !0);
        }
        var h5 = Dt(t9.dtype, e13.dtype), f6 = new Hi(t9.shape, [
            s23,
            o27,
            a25
        ], n17, r21);
        return this.compileAndRun(f6, [
            t9,
            e13
        ], h5);
    }, o24.prototype.fusedBatchMatMul = function(t9) {
        var e13 = t9.a, n17 = t9.b, r21 = t9.transposeA, o27 = t9.transposeB, a25 = t9.bias, i24 = t9.activation, s23 = t9.preluActivationWeights, u12 = r21 ? e13.shape[2] : e13.shape[1], c7 = o27 ? n17.shape[1] : n17.shape[2], l9 = e13.shape[0], h5 = Dt(e13.dtype, n17.dtype), f6 = null != a25, d7 = null != s23, p8 = i24 ? Qs(i24, !0) : null, v8 = new Hi(e13.shape, [
            l9,
            u12,
            c7
        ], r21, o27, f6, p8, d7), m9 = [
            e13,
            n17
        ];
        return a25 && m9.push(a25), s23 && m9.push(s23), this.compileAndRun(v8, m9, h5);
    }, o24.prototype.multiply = function(t9, e13) {
        if ("complex64" === t9.dtype) {
            var n17 = this.texData.get(t9.dataId), r21 = this.texData.get(e13.dataId), o27 = new Na(Da, t9.shape, e13.shape), a25 = new Na(Ta, t9.shape, e13.shape), s23 = [
                this.makeComplexComponentTensorInfo(t9, n17.complexTensors.real),
                this.makeComplexComponentTensorInfo(t9, n17.complexTensors.imag),
                this.makeComplexComponentTensorInfo(e13, r21.complexTensors.real),
                this.makeComplexComponentTensorInfo(e13, r21.complexTensors.imag)
            ], u12 = this.compileAndRun(o27, s23), c7 = this.compileAndRun(a25, s23), l9 = this.complex(u12, c7);
            return u12.dispose(), c7.dispose(), l9;
        }
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.multiply(t9, e13);
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, Oa, t9.dtype);
        var h5 = new Ba(Oa, t9.shape, e13.shape);
        return this.compileAndRun(h5, [
            t9,
            e13
        ], t9.dtype);
    }, o24.prototype.batchNormalization = function(t9, e13, n18, r22, o28, a26) {
        var s24 = [
            t9,
            e13,
            n18
        ], u13 = null;
        null != a26 && (u13 = a26.shape, s24.push(a26));
        var c8 = null;
        if (null != o28 && (c8 = o28.shape, s24.push(o28)), i15().getBool("WEBGL_PACK_NORMALIZATION")) {
            var l10 = new Aa(t9.shape, e13.shape, n18.shape, u13, c8, r22);
            return this.compileAndRun(l10, s24);
        }
        var h5 = new Sa(t9.shape, e13.shape, n18.shape, u13, c8, r22);
        return this.compileAndRun(h5, s24);
    }, o24.prototype.localResponseNormalization4D = function(t9, e13, n18, r22, o28) {
        var a26 = i15().getBool("WEBGL_PACK_NORMALIZATION") ? new Vi(t9.shape, e13, n18, r22, o28) : new Wi(t9.shape, e13, n18, r22, o28);
        return this.compileAndRun(a26, [
            t9
        ]);
    }, o24.prototype.LRNGrad = function(t9, e13, n18, r22, o28, a26, i24) {
        var s24 = new Ui(e13.shape, r22, o28, a26, i24);
        return this.compileAndRun(s24, [
            e13,
            n18,
            t9
        ]);
    }, o24.prototype.tile = function(t9, e13) {
        if ("string" === t9.dtype) {
            var n18 = this.readSync(t9.dataId).map(function(t10) {
                return ot(t10);
            });
            return ta(dr(t9.shape, t9.dtype, n18), e13);
        }
        var r22 = new gs(t9.shape, e13);
        return this.compileAndRun(r22, [
            t9
        ]);
    }, o24.prototype.pad = function(t9, e13, n19) {
        var r22 = i15().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Yi(t9.shape, e13, n19) : new Xi(t9.shape, e13, n19);
        return this.compileAndRun(r22, [
            t9
        ]);
    }, o24.prototype.transpose = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.transpose(t9, e13);
        var n19 = i15().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new xs(t9.shape, e13) : new ys(t9.shape, e13);
        return this.compileAndRun(n19, [
            t9
        ]);
    }, o24.prototype.gather = function(t9, e13, n19) {
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.gather(t9, e13, n19);
        var r22 = new mi(t9.shape, e13.size, n19);
        return this.compileAndRun(r22, [
            t9,
            e13
        ]);
    }, o24.prototype.batchToSpaceND = function(t9, e13, n19) {
        C(t9.rank <= 4, function() {
            return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r22 = e13.reduce(function(t10, e14) {
            return t10 * e14;
        }), o28 = zr(t9.shape, e13, r22), a26 = Gr(o28.length, e13.length), i24 = Hr(t9.shape, e13, r22), s24 = qr(n19, e13.length), u13 = Kr(i24, n19, e13.length);
        return t9.reshape(o28).transpose(a26).reshape(i24).slice(s24, u13);
    }, o24.prototype.spaceToBatchND = function(t9, e13, n19) {
        C(t9.rank <= 4, function() {
            return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r22 = e13.reduce(function(t10, e14) {
            return t10 * e14;
        }), o28 = [
            [
                0,
                0
            ]
        ];
        o28.push.apply(o28, n19);
        for(var a26 = 1 + e13.length; a26 < t9.shape.length; ++a26)o28.push([
            0,
            0
        ]);
        var i24 = t9.pad(o28), s24 = zr(i24.shape, e13, r22, !1), u13 = Gr(s24.length, e13.length, !1), c8 = Hr(i24.shape, e13, r22, !1);
        return i24.reshape(s24).transpose(u13).reshape(c8);
    }, o24.prototype.reduce = function(t9, e13, n19) {
        var r22 = t9.shape[0], o28 = t9.shape[1], a26 = $r(o28), i24 = new Ji({
            windowSize: a26,
            inSize: o28,
            batchSize: r22
        }, e13), s24 = this.compileAndRun(i24, [
            t9
        ], n19);
        return 1 === s24.shape[1] ? s24 : this.reduce(s24, e13, n19);
    }, o24.prototype.argReduce = function(t9, e13, n19) {
        (void 0) === n19 && (n19 = null);
        var r22 = t9.shape[0], o28 = t9.shape[1];
        null != n19 && (r22 = n19.shape[0], o28 = n19.shape[1]);
        var a26 = $r(o28), i24 = new aa({
            windowSize: a26,
            inSize: o28,
            batchSize: r22
        }, e13, null == n19), s24 = [
            t9
        ];
        null != n19 && s24.push(n19);
        var u13 = this.compileAndRun(i24, s24, "int32");
        return 1 === u13.shape[1] ? u13 : this.argReduce(t9, e13, u13);
    }, o24.prototype.argReducePacked = function(t9, e13, n19) {
        (void 0) === n19 && (n19 = null);
        var r22 = null != n19 ? n19.shape : t9.shape, o28 = $r(r22[r22.length - 1]), a26 = new Ra(r22, o28, e13, null == n19), i24 = null == n19 ? [
            t9
        ] : [
            t9,
            n19
        ], s24 = this.compileAndRun(a26, i24, "int32");
        return s24.rank === t9.rank ? this.argReducePacked(t9, e13, s24) : s24;
    }, o24.prototype.sum = function(t9, e13) {
        Cn("sum", e13, t9.rank);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o28 = k(n19[1]), a26 = t9.as2D(-1, o28), i24 = Tt(t9.dtype);
        return this.reduce(a26, "sum", i24).reshape(r22);
    }, o24.prototype.prod = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.prod(t9, e13);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o28 = k(n19[1]), a26 = t9.as2D(-1, o28), i24 = Tt(t9.dtype);
        return this.reduce(a26, "prod", i24).reshape(r22);
    }, o24.prototype.unsortedSegmentSum = function(t9, e13, n19) {
        var r22 = 0, o28 = En([
            r22
        ], t9.rank), a26 = t9;
        null != o28 && (a26 = t9.transpose(o28), r22 = In(1, t9.rank)[0]);
        var i24 = function(t10, e14, n20) {
            for(var r23 = [], o29 = t10.length, a27 = 0; a27 < o29; a27++)a27 !== e14 ? r23.push(t10[a27]) : r23.push(n20);
            return r23;
        }(a26.shape, r22, n19), s24 = k([
            a26.shape[r22]
        ]), u13 = a26.as2D(-1, s24), c8 = Tt(t9.dtype), l11 = this.segOpCompute(u13, "unsortedSegmentSum", e13, c8, n19).reshape(i24);
        return null != o28 && (l11 = l11.transpose(Rn(o28))), l11;
    }, o24.prototype.segOpCompute = function(t9, e13, n19, r22, o28) {
        var a26 = t9.shape[0], i24 = t9.shape[1], s24 = function(t10, e14) {
            var n20, r23 = !1;
            for(t10 <= Yr ? (n20 = t10, r23 = !0) : n20 = Y(t10, Math.floor(Math.sqrt(t10))); !r23;)n20 > e14 || n20 === t10 ? r23 = !0 : n20 = Y(t10, n20 + 1);
            return n20;
        }(i24, o28), u13 = new us({
            windowSize: s24,
            inSize: i24,
            batchSize: a26,
            numSegments: o28
        }, e13), c8 = this.compileAndRun(u13, [
            t9,
            n19
        ], r22);
        return c8.shape[1] === o28 ? c8 : (n19 = Kn(0, o28).tile([
            i24 / s24
        ]), this.segOpCompute(c8, e13, n19, r22, o28));
    }, o24.prototype.argMinMaxReduce = function(t9, e13, n19) {
        var r22 = [
            e13
        ];
        if (Cn("arg" + n19.charAt(0).toUpperCase() + n19.slice(1), r22, t9.rank), !i15().getBool("WEBGL_PACK_REDUCE") || t9.rank <= 2) {
            var o28 = bn(t9.shape, r22), a26 = o28[0], s24 = k(o28[1]), u13 = t9.as2D(-1, s24);
            return this.argReduce(u13, n19).reshape(a26);
        }
        return this.argReducePacked(t9, n19);
    }, o24.prototype.argMin = function(t9, e13) {
        return this.argMinMaxReduce(t9, e13, "min");
    }, o24.prototype.argMax = function(t9, e13) {
        return this.argMinMaxReduce(t9, e13, "max");
    }, o24.prototype.cumsum = function(t9, e13, n19, r22) {
        if (e13 !== t9.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t9.rank - 1) + " but got axis=" + e13);
        var o29 = new ni(t9.shape, n19, r22);
        return this.compileAndRun(o29, [
            t9
        ]);
    }, o24.prototype.equal = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(equal(a, b));\n", "bool");
        var n19 = new Ba("return float(a == b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.notEqual = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(notEqual(a, b));\n", "bool");
        var n19 = new Ba("return float(a != b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.less = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.less(t9, e13);
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(lessThan(a, b));\n", "bool");
        var n19 = new Ba("return float(a < b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.lessEqual = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
        var n19 = new Ba("return float(a <= b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.greater = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.greater(t9, e13);
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(greaterThan(a, b));\n", "bool");
        var n19 = new Ba("return float(a > b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.greaterEqual = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
        var n19 = new Ba("return float(a >= b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.logicalNot = function(t9) {
        var e13 = new Cs(t9.shape, "return float(!(x >= 1.0));");
        return this.compileAndRun(e13, [
            t9
        ]);
    }, o24.prototype.logicalAnd = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
        var n19 = new Ba("return float(a >= 1.0 && b >= 1.0);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.logicalOr = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
        var n19 = new Ba("return float(a >= 1.0 || b >= 1.0);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "bool");
    }, o24.prototype.select = function(t9, e13, n19) {
        var r22 = new cs(t9.rank, e13.shape, e13.rank);
        return this.compileAndRun(r22, [
            t9,
            e13,
            n19
        ], Dt(e13.dtype, n19.dtype));
    }, o24.prototype.where = function(t9) {
        dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var e13 = t9.dataSync();
        return na(t9.shape, e13);
    }, o24.prototype.topk = function(t9, e13, n19) {
        return ea(t9.dataSync(), t9.shape, t9.dtype, e13);
    }, o24.prototype.min = function(t9, e13) {
        Cn("min", e13, t9.rank);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o29 = k(n19[1]), a27 = t9.as2D(-1, o29);
        return this.reduce(a27, "min", a27.dtype).reshape(r22);
    }, o24.prototype.minimum = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.minimum(t9, e13);
        var n19 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t9.shape, e13.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ]);
    }, o24.prototype.mod = function(t9, e13) {
        var n19 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t9.shape, e13.shape) : new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ]);
    }, o24.prototype.max = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.max(t9, e13);
        Cn("max", e13, t9.rank);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o29 = k(n19[1]), a27 = t9.as2D(-1, o29);
        return this.reduce(a27, "max", a27.dtype).reshape(r22);
    }, o24.prototype.maximum = function(t9, e13) {
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.maximum(t9, e13);
        var n19 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t9.shape, e13.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ]);
    }, o24.prototype.all = function(t9, e13) {
        Cn("all", e13, t9.rank);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o29 = k(n19[1]), a27 = t9.as2D(-1, o29);
        return this.reduce(a27, "all", a27.dtype).reshape(r22);
    }, o24.prototype.any = function(t9, e13) {
        Cn("any", e13, t9.rank);
        var n19 = bn(t9.shape, e13), r22 = n19[0], o29 = k(n19[1]), a27 = t9.as2D(-1, o29);
        return this.reduce(a27, "any", a27.dtype).reshape(r22);
    }, o24.prototype.realDivide = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
        var n19 = new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "float32");
    }, o24.prototype.floorDiv = function(t9, e13) {
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
        var n19 = new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t9.shape, e13.shape);
        return this.compileAndRun(n19, [
            t9,
            e13
        ], "int32");
    }, o24.prototype.add = function(t9, e13) {
        if ("complex64" === t9.dtype && "complex64" === e13.dtype) return this.complexSeparableBinaryOp(t9, e13, Fa);
        if (this.shouldExecuteOnCPU([
            t9,
            e13
        ])) return this.cpuBackend.add(t9, e13);
        var n19 = Dt(t9.dtype, e13.dtype);
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e13, Fa, n19);
        var r22 = new Ba(Fa, t9.shape, e13.shape);
        return this.compileAndRun(r22, [
            t9,
            e13
        ], n19);
    }, o24.prototype.packedUnaryOp = function(t9, e13, n19) {
        var r22 = new Xs(t9.shape, e13);
        return this.compileAndRun(r22, [
            t9
        ], n19);
    }, o24.prototype.packedBinaryOp = function(t9, e13, n19, r22, o29) {
        (void 0) === o29 && (o29 = !1);
        var a27 = new La(n19, t9.shape, e13.shape, o29);
        return this.compileAndRun(a27, [
            t9,
            e13
        ], r22);
    }, o24.prototype.complexSeparableBinaryOp = function(t9, e13, n19) {
        var r22 = this, o29 = this.texData.get(t9.dataId), a27 = this.texData.get(e13.dataId), i24 = [
            [
                o29.complexTensors.real,
                a27.complexTensors.real
            ],
            [
                o29.complexTensors.imag,
                a27.complexTensors.imag
            ]
        ].map(function(o30) {
            var a28 = o30[0], i25 = o30[1], s25 = r22.makeComplexComponentTensorInfo(t9, a28), u14 = r22.makeComplexComponentTensorInfo(e13, i25), c8 = new Ba(n19, t9.shape, e13.shape);
            return r22.compileAndRun(c8, [
                s25,
                u14
            ], Dt(a28.dtype, i25.dtype));
        }), s25 = i24[0], u14 = i24[1], c8 = this.complex(s25, u14);
        return s25.dispose(), u14.dispose(), c8;
    }, o24.prototype.makeComplexComponentTensorInfo = function(t9, e13) {
        return {
            dataId: e13.dataId,
            dtype: e13.dtype,
            shape: t9.shape
        };
    }, o24.prototype.addN = function(t9) {
        if (1 === t9.length) return t9[0];
        if (t9.length > i15().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
            var e13 = Math.floor(t9.length / 2), n19 = this.addN(t9.slice(0, e13)), r22 = this.addN(t9.slice(e13));
            return this.addN([
                n19,
                r22
            ]);
        }
        var o29 = t9.map(function(t10) {
            return t10.dtype;
        }).reduce(function(t10, e14) {
            return Dt(t10, e14);
        }), a27 = t9.map(function(t10) {
            return t10.shape;
        }), s25 = i15().getBool("WEBGL_PACK") ? new oa(t9[0].shape, a27) : new ra(t9[0].shape, a27);
        return this.compileAndRun(s25, t9, o29);
    }, o24.prototype.subtract = function(t9, e14) {
        if ("complex64" === t9.dtype && "complex64" === e14.dtype) return this.complexSeparableBinaryOp(t9, e14, _a);
        if (this.shouldExecuteOnCPU([
            t9,
            e14
        ])) return this.cpuBackend.subtract(t9, e14);
        var n20 = Dt(t9.dtype, e14.dtype);
        if (i15().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t9, e14, _a, t9.dtype);
        var r23 = new Ba(_a, t9.shape, e14.shape);
        return this.compileAndRun(r23, [
            t9,
            e14
        ], n20);
    }, o24.prototype.pow = function(t9, e14) {
        var n20 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t9.shape, e14.shape) : new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t9.shape, e14.shape), r23 = Dt(t9.dtype, e14.dtype);
        return this.compileAndRun(n20, [
            t9,
            e14
        ], r23);
    }, o24.prototype.ceil = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.ceil(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, Ns, t9.dtype);
        var e14 = new Cs(t9.shape, Ns);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.floor = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.floor(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, Fs, t9.dtype);
        var e14 = new Cs(t9.shape, Fs);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.sign = function(t9) {
        var e14 = new Cs(t9.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.isNaN = function(t9) {
        var e14 = new Cs(t9.shape, "return float(isnan(x));");
        return this.compileAndRun(e14, [
            t9
        ], "bool");
    }, o24.prototype.isInf = function(t9) {
        var e14 = new Cs(t9.shape, "return float(isinf(x));");
        return this.compileAndRun(e14, [
            t9
        ], "bool");
    }, o24.prototype.isFinite = function(t9) {
        var e14 = new Cs(t9.shape, "return float(!isnan(x) && !isinf(x));");
        return this.compileAndRun(e14, [
            t9
        ], "bool");
    }, o24.prototype.round = function(t9) {
        var e14 = new Cs(t9.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.exp = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.exp(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, _s, t9.dtype);
        var e14 = new Cs(t9.shape, _s);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.expm1 = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.expm1(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, Os, t9.dtype);
        var e14 = new Cs(t9.shape, Os);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.softmax = function(t9, e14) {
        var n20 = O([
            e14
        ], t9.shape), r23 = this.max(t9, n20), o29 = wn(r23.shape, n20), a27 = this.subtract(t9, r23.reshape(o29)), i24 = this.exp(a27), s25 = this.sum(i24, n20).reshape(o29);
        return this.realDivide(i24, s25);
    }, o24.prototype.log = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.log(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t9.dtype);
        var e14 = new Cs(t9.shape, "if (x < 0.0) return NAN;\n  return log(x);");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.log1p = function(t9) {
        var e14 = new Cs(t9.shape, "return log(1.0 + x);");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.sqrt = function(t9) {
        var e14 = new Cs(t9.shape, "return sqrt(x);");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.rsqrt = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.rsqrt(t9);
        var e14 = new Cs(t9.shape, "return inversesqrt(x);");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.reciprocal = function(t9) {
        var e14 = new Cs(t9.shape, "return 1.0 / x;");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.relu = function(t9) {
        var e14;
        return e14 = i15().getBool("WEBGL_PACK") ? new Xs(t9.shape, qs) : new Cs(t9.shape, ks), this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.relu6 = function(t9) {
        var e14;
        return e14 = i15().getBool("WEBGL_PACK") ? new Xs(t9.shape, Ks) : new Cs(t9.shape, Ss), this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.prelu = function(t9, e14) {
        var n20 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La(Pa, t9.shape, e14.shape) : new Ba(Ma, t9.shape, e14.shape);
        return this.compileAndRun(n20, [
            t9,
            e14
        ]);
    }, o24.prototype.elu = function(t9) {
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, js, t9.dtype);
        var e14 = new Cs(t9.shape, As);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.eluDer = function(t9, e14) {
        var n20 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t9.shape, e14.shape) : new Ba("return (b >= 1.0) ? a : a * (b + 1.0);", t9.shape, e14.shape);
        return this.compileAndRun(n20, [
            t9,
            e14
        ]);
    }, o24.prototype.selu = function(t9) {
        var e14 = new Cs(t9.shape, Ds);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.int = function(t9) {
        var e14 = new Cs(t9.shape, "return float(int(x));");
        return this.compileAndRun(e14, [
            t9
        ], "int32");
    }, o24.prototype.clip = function(t9, e14, n20) {
        var r23, o29 = (r23 = i15().getBool("WEBGL_PACK_CLIP") ? new Ua(t9.shape) : new Wa(t9.shape)).getCustomSetupFunc(e14, n20);
        return this.compileAndRun(r23, [
            t9
        ], null, o29);
    }, o24.prototype.abs = function(t9) {
        if (this.shouldExecuteOnCPU([
            t9
        ])) return this.cpuBackend.abs(t9);
        if (i15().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t9, Is, t9.dtype);
        var e14 = new Cs(t9.shape, Is);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.complexAbs = function(t9) {
        var e14 = this.texData.get(t9.dataId), n20 = new Va(t9.shape), r23 = [
            this.makeComplexComponentTensorInfo(t9, e14.complexTensors.real),
            this.makeComplexComponentTensorInfo(t9, e14.complexTensors.imag)
        ];
        return this.compileAndRun(n20, r23);
    }, o24.prototype.sigmoid = function(t9) {
        var e14 = new Cs(t9.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.softplus = function(t9) {
        var e14 = new Cs(t9.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.sin = function(t9) {
        var e14 = new Cs(t9.shape, Ms);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.cos = function(t9) {
        var e14 = new Cs(t9.shape, Bs);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.tan = function(t9) {
        var e14 = new Cs(t9.shape, "return tan(x);");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.asin = function(t9) {
        var e14 = new Cs(t9.shape, Ps);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.acos = function(t9) {
        var e14 = new Cs(t9.shape, Ls);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.atan = function(t9) {
        var e14 = new Cs(t9.shape, Ws);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.atan2 = function(t9, e14) {
        var n20 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t9.shape, e14.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t9.shape, e14.shape);
        return this.compileAndRun(n20, [
            t9,
            e14
        ]);
    }, o24.prototype.sinh = function(t9) {
        var e14 = new Cs(t9.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.cosh = function(t9) {
        var e14 = new Cs(t9.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.tanh = function(t9) {
        var e14 = new Cs(t9.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.asinh = function(t9) {
        var e14 = new Cs(t9.shape, Us);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.acosh = function(t9) {
        var e14 = new Cs(t9.shape, Vs);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.atanh = function(t9) {
        var e14 = new Cs(t9.shape, zs);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.erf = function(t9) {
        var e14 = new Cs(t9.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.step = function(t9, e14) {
        var n20 = new Cs(t9.shape, function(t10) {
            return (void 0) === t10 && (t10 = 0), Es + "\n    return x > 0.0 ? 1.0 : float(" + t10 + ");\n  ";
        }(e14));
        return this.compileAndRun(n20, [
            t9
        ]);
    }, o24.prototype.conv2dByMatMul = function(t9, e14, n20, r23, o29, a27) {
        var s25 = t9.shape, u14 = this.texData.get(t9.dataId), c8 = n20.inChannels, l11 = s25[0] * s25[1] * s25[2], h5 = n20.outChannels, f6 = "channelsLast" === n20.dataFormat, d7 = (1 === l11 || 1 === h5) && c8 > 1000, p8 = s25[2] % 2 != 0 && !!u14.isPacked;
        if (d7 || !i15().getBool("WEBGL_LAZILY_UNPACK") || !i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !p8) {
            var v8 = f6 ? s25[0] * s25[1] * s25[2] : s25[0] * s25[2] * s25[3], m9 = this.reshape(t9, [
                1,
                v8,
                n20.inChannels
            ]), g8 = this.reshape(e14, [
                1,
                n20.inChannels,
                n20.outChannels
            ]);
            return this.reshape(this.fusedBatchMatMul({
                a: m9,
                b: g8,
                transposeA: !1,
                transposeB: !1,
                bias: r23,
                activation: o29,
                preluActivationWeights: a27
            }), n20.outShape);
        }
        var y6 = f6 ? s25[0] * s25[1] * (s25[2] + 1) : s25[0] * s25[2] * (s25[3] + 1), x6 = {
            dataId: t9.dataId,
            shape: [
                1,
                y6,
                n20.inChannels
            ],
            dtype: t9.dtype
        }, b3 = u14.shape;
        u14.shape = u14.shape.slice(), u14.shape[u14.shape.length - 2]++, C(_e(u14.shape, x6.shape), function() {
            return "packed reshape " + u14.shape + " to " + x6.shape + " isn't free";
        });
        var w3 = this.reshape(e14, [
            1,
            n20.inChannels,
            n20.outChannels
        ]), E1 = this.fusedBatchMatMul({
            a: x6,
            b: w3,
            transposeA: !1,
            transposeB: !1,
            bias: r23,
            activation: o29,
            preluActivationWeights: a27
        }), R1 = this.texData.get(E1.dataId);
        return C(R1.isPacked, function() {
            return "batchMatMul result is expected to be packed";
        }), u14.shape = b3, R1.shape = n20.outShape, Lt.makeTensorFromDataId(E1.dataId, n20.outShape, E1.dtype);
    }, o24.prototype.conv2dWithIm2Row = function(t9, e14, n20, r23, o29, a27) {
        var i24 = n20.filterWidth, s25 = n20.filterHeight, u14 = n20.inChannels, c8 = n20.outWidth, l11 = n20.outHeight, h5 = "channelsLast" === n20.dataFormat, f6 = i24 * s25 * u14, d7 = l11 * c8, p8 = [
            f6,
            d7
        ], v9 = t9.squeeze([
            0
        ]), m10 = e14.reshape([
            1,
            f6,
            -1
        ]), g9 = new Li(p8, v9.shape, n20), y6 = this.compileAndRun(g9, [
            v9
        ]).reshape([
            1,
            p8[0],
            p8[1]
        ]), x6 = null != r23, b3 = null != a27, w3 = o29 ? Qs(o29, !0) : null, C1 = new Hi(y6.shape, [
            1,
            d7,
            n20.outChannels
        ], !0, !1, x6, w3, b3), E1 = [
            y6,
            m10
        ];
        r23 && E1.push(r23), b3 && E1.push(a27);
        var R1 = this.compileAndRun(C1, E1);
        return h5 ? R1.reshape([
            1,
            l11,
            c8,
            n20.outChannels
        ]) : R1.reshape([
            1,
            n20.outChannels,
            l11,
            c8
        ]);
    }, o24.prototype.fusedConv2d = function(t9) {
        var e14 = t9.input, n20 = t9.filter, r23 = t9.convInfo, o29 = t9.bias, a27 = t9.activation, s25 = t9.preluActivationWeights;
        if (1 === r23.filterHeight && 1 === r23.filterWidth && 1 === r23.dilationHeight && 1 === r23.dilationWidth && 1 === r23.strideHeight && 1 === r23.strideWidth && ("SAME" === r23.padInfo.type || "VALID" === r23.padInfo.type)) return this.conv2dByMatMul(e14, n20, r23, o29, a27, s25);
        if (i15().getBool("WEBGL_CONV_IM2COL") && 1 === e14.shape[0]) return this.conv2dWithIm2Row(e14, n20, r23, o29, a27, s25);
        var u14 = null != o29, c8 = null != s25, l11 = a27 ? Qs(a27, !1) : null, h5 = new Qa(r23, u14, l11, c8), f6 = [
            e14,
            n20
        ];
        return o29 && f6.push(o29), s25 && f6.push(s25), this.compileAndRun(h5, f6);
    }, o24.prototype.conv2d = function(t9, e14, n20) {
        if (1 === n20.filterHeight && 1 === n20.filterWidth && 1 === n20.dilationHeight && 1 === n20.dilationWidth && 1 === n20.strideHeight && 1 === n20.strideWidth && ("SAME" === n20.padInfo.type || "VALID" === n20.padInfo.type)) return this.conv2dByMatMul(t9, e14, n20);
        if (i15().getBool("WEBGL_CONV_IM2COL") && 1 === t9.shape[0]) return this.conv2dWithIm2Row(t9, e14, n20);
        var r23 = new Qa(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.conv2dDerInput = function(t9, e14, n20) {
        var r23 = new Ka(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.conv2dDerFilter = function(t9, e14, n20) {
        var r23 = new qa(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.fusedDepthwiseConv2D = function(t9) {
        var e14, n20 = t9.input, r23 = t9.filter, o29 = t9.convInfo, a27 = t9.bias, s25 = t9.activation, u14 = t9.preluActivationWeights, c8 = i15().getBool("WEBGL_PACK_DEPTHWISECONV") && o29.strideWidth <= 2 && o29.outChannels / o29.inChannels == 1, l11 = s25 ? Qs(s25, c8) : null, h5 = [
            n20,
            r23
        ], f6 = null != a27, d7 = null != u14;
        return f6 && h5.push(a27), d7 && h5.push(u14), c8 ? (e14 = new ti(o29, f6, l11, d7), this.compileAndRun(e14, h5)) : (e14 = new Za(o29, f6, l11, d7), this.compileAndRun(e14, h5));
    }, o24.prototype.depthwiseConv2D = function(t9, e14, n20) {
        var r23;
        return i15().getBool("WEBGL_PACK_DEPTHWISECONV") && n20.strideWidth <= 2 && n20.outChannels / n20.inChannels == 1 ? (r23 = new ti(n20), this.compileAndRun(r23, [
            t9,
            e14
        ])) : (r23 = new Za(n20), this.compileAndRun(r23, [
            t9,
            e14
        ]));
    }, o24.prototype.depthwiseConv2DDerInput = function(t9, e14, n20) {
        var r23 = new $a(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.depthwiseConv2DDerFilter = function(t9, e14, n20) {
        var r23 = new Ya(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.conv3d = function(t9, e14, n20) {
        var r23 = new Ja(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.conv3dDerInput = function(t9, e14, n20) {
        var r23 = new Xa(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.conv3dDerFilter = function(t9, e14, n20) {
        var r23 = new ja(n20);
        return this.compileAndRun(r23, [
            t9,
            e14
        ]);
    }, o24.prototype.maxPool = function(t9, e14) {
        var n20 = new $i(e14, "max", !1);
        return this.compileAndRun(n20, [
            t9
        ]);
    }, o24.prototype.avgPool = function(t9, e14) {
        var n20 = new $i(e14, "avg", !1);
        return this.compileAndRun(n20, [
            t9
        ], "float32");
    }, o24.prototype.maxPoolBackprop = function(t9, e14, n20, r23) {
        var o29 = new $i(r23, "max", !0), a27 = this.compileAndRun(o29, [
            e14
        ]), i24 = new zi(r23), s25 = this.compileAndRun(i24, [
            t9,
            a27
        ], e14.dtype);
        return a27.dispose(), s25;
    }, o24.prototype.avgPoolBackprop = function(t9, e14, n20) {
        var r23 = new Ia(n20);
        return this.compileAndRun(r23, [
            t9
        ], e14.dtype);
    }, o24.prototype.cast = function(t9, e14) {
        return Po(t9, e14, this);
    }, o24.prototype.unstack = function(t9, e14) {
        for(var n20 = t9.shape[e14], r23 = new Array(t9.rank - 1), o29 = 0, a27 = 0; a27 < t9.rank; a27++)a27 !== e14 && (r23[o29++] = t9.shape[a27]);
        var i24 = new Array(t9.rank).fill(0), s25 = t9.shape.slice();
        s25[e14] = 1;
        var u14 = new Array(n20);
        for(a27 = 0; a27 < u14.length; a27++)i24[e14] = a27, u14[a27] = this.slice(t9, i24, s25).reshape(r23);
        return u14;
    }, o24.prototype.avgPool3d = function(t9, e14) {
        var n20 = new Qi(e14, "avg", !1);
        return this.compileAndRun(n20, [
            t9
        ], "float32");
    }, o24.prototype.avgPool3dBackprop = function(t9, e14, n20) {
        var r23 = new ka(n20);
        return this.compileAndRun(r23, [
            t9
        ], e14.dtype);
    }, o24.prototype.maxPool3d = function(t9, e14) {
        var n20 = new Qi(e14, "max", !1);
        return this.compileAndRun(n20, [
            t9
        ], "float32");
    }, o24.prototype.maxPool3dBackprop = function(t9, e14, n20, r23) {
        var o29 = new Qi(r23, "max", !0), a27 = this.compileAndRun(o29, [
            e14
        ]), i24 = new Gi(r23), s25 = this.compileAndRun(i24, [
            t9,
            a27
        ], e14.dtype);
        return a27.dispose(), s25;
    }, o24.prototype.reshape = function(t9, e14) {
        var n20 = this.texData.get(t9.dataId);
        if (n20.isPacked && !_e(t9.shape, e14) && (null === n20.texture || !_e(n20.shape, e14))) {
            var r23 = this.packedReshape(t9, e14);
            return Lt.makeTensorFromDataId(r23.dataId, r23.shape, r23.dtype);
        }
        return Lo(t9, e14);
    }, o24.prototype.resizeBilinear = function(t9, e14, n20, r24) {
        var o29 = i15().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ns(t9.shape, e14, n20, r24) : new es(t9.shape, e14, n20, r24);
        return this.compileAndRun(o29, [
            t9
        ], "float32");
    }, o24.prototype.resizeBilinearBackprop = function(t9, e14, n20) {
        var r24 = new ts(t9, e14, n20);
        return this.compileAndRun(r24, [
            t9
        ]);
    }, o24.prototype.resizeNearestNeighbor = function(t9, e14, n20, r24) {
        var o29 = new os(t9.shape, e14, n20, r24);
        return this.compileAndRun(o29, [
            t9
        ]);
    }, o24.prototype.resizeNearestNeighborBackprop = function(t9, e14, n20) {
        var r24 = new rs(t9, e14, n20);
        return this.compileAndRun(r24, [
            t9
        ]);
    }, o24.prototype.multinomial = function(t9, e14, n20, r24) {
        var o29 = e14 ? t9 : go(t9), a27 = o29.shape[0], i24 = o29.shape[1], s25 = new qi(a27, i24, n20), u14 = s25.getCustomSetupFunc(r24);
        return this.compileAndRun(s25, [
            o29
        ], "int32", u14);
    }, o24.prototype.oneHot = function(t9, e14, n20, r24) {
        var o29 = new Ki(t9.size, e14, n20, r24);
        return this.compileAndRun(o29, [
            t9
        ]);
    }, o24.prototype.diag = function(t9) {
        var e14 = new si(t9.size);
        return this.compileAndRun(e14, [
            t9
        ]);
    }, o24.prototype.nonMaxSuppression = function(t9, e14, n20, r24, o29) {
        return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), jo(t9.dataSync(), e14.dataSync(), n20, r24, o29);
    }, o24.prototype.cropAndResize = function(t9, e14, n20, r24, o29, a27) {
        var i24 = new ei(t9.shape, e14.shape, r24, o29, a27);
        return this.compileAndRun(i24, [
            t9,
            e14,
            n20
        ], "float32");
    }, o24.prototype.depthToSpace = function(t9, e14, n20) {
        C(e14 > 1, function() {
            return "blockSize should be > 1 for depthToSpace, but was: " + e14;
        });
        var r24 = t9.shape[0], o29 = "NHWC" === n20 ? t9.shape[1] : t9.shape[2], a27 = "NHWC" === n20 ? t9.shape[2] : t9.shape[3], i24 = "NHWC" === n20 ? t9.shape[3] : t9.shape[1], s25 = o29 * e14, u14 = a27 * e14, c8 = i24 / (e14 * e14), l11 = new ii("NHWC" === n20 ? [
            r24,
            s25,
            u14,
            c8
        ] : [
            r24,
            c8,
            s25,
            u14
        ], e14, n20);
        return this.compileAndRun(l11, [
            t9
        ]);
    }, o24.prototype.split = function(t9, e14, n20) {
        return Zo(t9, e14, n20);
    }, o24.prototype.scatterND = function(t9, e14, n20) {
        var r24 = Zr(0, t9, n20), o29 = r24.sliceRank, a27 = r24.numUpdates, i24 = r24.sliceSize, s25 = r24.strides, u14 = r24.outputSize, c8 = [
            u14 / i24,
            i24
        ], l11 = t9.reshape([
            a27,
            o29
        ]), h5 = e14.reshape([
            a27,
            i24
        ]);
        if (0 === u14) return Lo(Fn([]), n20);
        var f6 = On(0), d7 = new ss(a27, o29, l11.rank, h5.rank, s25, c8);
        return this.compileAndRun(d7, [
            h5,
            l11,
            f6
        ]).reshape(n20);
    }, o24.prototype.sparseToDense = function(t9, e14, n20, r24) {
        var o29 = Zr(0, t9, n20), a27 = o29.sliceRank, i24 = o29.numUpdates, s25 = o29.strides, u14 = o29.outputSize, c8 = new ss(i24, a27, t9.rank, e14.rank, s25, [
            u14,
            1
        ], !1);
        return this.compileAndRun(c8, [
            e14,
            t9,
            r24
        ]).reshape(n20);
    }, o24.prototype.fft = function(t9) {
        return this.fftImpl(t9, !1);
    }, o24.prototype.ifft = function(t9) {
        return this.fftImpl(t9, !0);
    }, o24.prototype.fftImpl = function(t9, e14) {
        var n20 = this.texData.get(t9.dataId), r24 = new pi(fi, t9.shape, e14), o29 = new pi(di, t9.shape, e14), a27 = [
            this.makeComplexComponentTensorInfo(t9, n20.complexTensors.real),
            this.makeComplexComponentTensorInfo(t9, n20.complexTensors.imag)
        ], i24 = this.compileAndRun(r24, a27), s25 = this.compileAndRun(o29, a27), u14 = this.complex(i24, s25).as2D(t9.shape[0], t9.shape[1]);
        return i24.dispose(), s25.dispose(), u14;
    }, o24.prototype.gatherND = function(t9, e14) {
        var n20 = e14.shape, r24 = n20[n20.length - 1], o29 = jr(t9, e14), a27 = o29[0], i24 = o29[1], s25 = o29[2], u14 = o29[3], c8 = e14.reshape([
            i24,
            r24
        ]), l11 = t9.reshape([
            t9.size / s25,
            s25
        ]), h5 = new gi(r24, u14, [
            i24,
            s25
        ]);
        return this.compileAndRun(h5, [
            l11,
            c8
        ]).reshape(a27);
    }, o24.prototype.fill = function(t9, e14, n20) {
        if ("string" === (n20 = n20 || j(e14))) {
            var r24 = P(n20, k(t9));
            return r24.fill(e14), Lt.makeTensor(r24, t9, n20, this);
        }
        var o29 = new vi(t9, e14), a27 = o29.getCustomSetupFunc(e14);
        return this.compileAndRun(o29, [], n20, a27);
    }, o24.prototype.onesLike = function(t9) {
        if ("string" === t9.dtype) throw new Error("onesLike is not supported under string dtype");
        return this.fill(t9.shape, 1, t9.dtype);
    }, o24.prototype.zerosLike = function(t9) {
        return this.fill(t9.shape, "string" === t9.dtype ? "" : 0, t9.dtype);
    }, o24.prototype.linspace = function(t9, e14, n20) {
        return Wo(t9, e14, n20);
    }, o24.prototype.makeTensorInfo = function(t9, e14) {
        var n20 = this.write(null, t9, e14);
        return this.texData.get(n20).usage = null, {
            dataId: n20,
            shape: t9,
            dtype: e14
        };
    }, o24.prototype.makeOutput = function(t9, e14) {
        var n20 = this.makeTensorInfo(t9, e14).dataId;
        return Lt.makeTensorFromDataId(n20, t9, e14, this);
    }, o24.prototype.unpackTensor = function(t9) {
        var e14 = new Ys(t9.shape);
        return this.runWebGLProgram(e14, [
            t9
        ], t9.dtype);
    }, o24.prototype.packTensor = function(t9) {
        var e14 = new ji(t9.shape);
        return this.runWebGLProgram(e14, [
            t9
        ], t9.dtype, null, !0);
    }, o24.prototype.packedReshape = function(t9, e14) {
        var n20 = [
            Ae(t9.shape)
        ].concat(De(t9.shape)), r25 = {
            dtype: t9.dtype,
            shape: n20,
            dataId: t9.dataId
        }, o29 = [
            Ae(e14)
        ].concat(De(e14)), a27 = new Zi(o29, n20), i24 = this.runWebGLProgram(a27, [
            r25
        ], t9.dtype, null, !0);
        return {
            dataId: i24.dataId,
            shape: e14,
            dtype: i24.dtype
        };
    }, o24.prototype.decode = function(t9) {
        var e14, n20 = this.texData.get(t9), r25 = n20.isPacked, o29 = n20.shape, a27 = n20.dtype, i24 = Te(o29);
        e14 = r25 ? new ai(i24) : new oi(i24);
        return {
            dtype: a27,
            shape: o29,
            dataId: this.runWebGLProgram(e14, [
                {
                    shape: i24,
                    dtype: a27,
                    dataId: t9
                }
            ], a27, null, !0).dataId
        };
    }, o24.prototype.runWebGLProgram = function(t9, e14, n20, r25, o29) {
        var a27 = this;
        (void 0) === o29 && (o29 = !1);
        var s25 = this.makeTensorInfo(t9.outputShape, n20), u14 = this.texData.get(s25.dataId);
        if (t9.packedOutput && (u14.isPacked = !0), t9.outPackingScheme === Vt.DENSE) {
            var c8 = Yt(t9.outputShape);
            u14.texShape = c8.map(function(t10) {
                return 2 * t10;
            });
        }
        if (null != t9.outTexUsage && (u14.usage = t9.outTexUsage), 0 === k(s25.shape)) return u14.values = B(s25.dtype, 0), s25;
        var l11 = [], h5 = e14.map(function(e15) {
            if ("complex64" === e15.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            var n21 = a27.texData.get(e15.dataId);
            if (null == n21.texture) {
                if (!t9.packedInputs && k(e15.shape) <= i15().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                    shape: e15.shape,
                    texData: null,
                    isUniform: !0,
                    uniformValues: n21.values
                };
                t9.packedInputs && (n21.isPacked = !0, n21.shape = e15.shape);
            } else if (!!n21.isPacked != !!t9.packedInputs) e15 = n21.isPacked ? a27.unpackTensor(e15) : a27.packTensor(e15), l11.push(e15), n21 = a27.texData.get(e15.dataId);
            else if (n21.isPacked && !_e(n21.shape, e15.shape)) {
                var r26 = e15, o30 = e15.shape;
                e15.shape = n21.shape, e15 = a27.packedReshape(e15, o30), l11.push(e15), n21 = a27.texData.get(e15.dataId), r26.shape = o30;
            }
            return a27.uploadToGPU(e15.dataId), {
                shape: e15.shape,
                texData: n21,
                isUniform: !1
            };
        });
        this.uploadToGPU(s25.dataId);
        var f6, d7 = {
            shape: s25.shape,
            texData: u14,
            isUniform: !1
        }, p8 = function(t10, e15, n21) {
            var r27 = "";
            e15.concat(n21).forEach(function(t11) {
                var e16 = null != t11.texData && null != t11.texData.slice && t11.texData.slice.flatOffset > 0, n22 = t11.isUniform ? "uniform" : t11.texData.texShape;
                r27 += t11.shape + "_" + n22 + "_" + e16;
            });
            var o31 = t10.userCode, a28 = t10.constructor.name;
            return a28 += "_" + r27 + "_" + o31;
        }(t9, h5, d7), v9 = this.getAndSaveBinary(p8, function() {
            return (function(t10, e15, n21, r27) {
                var o31 = e15.userCode, a28 = n21.map(function(t11, n22) {
                    var r28 = {
                        logicalShape: t11.shape,
                        texShape: t11.isUniform ? null : t11.texData.texShape,
                        isUniform: t11.isUniform,
                        isPacked: !t11.isUniform && t11.texData.isPacked,
                        flatOffset: null
                    };
                    return null != t11.texData && null != t11.texData.slice && t11.texData.slice.flatOffset > 0 && (r28.flatOffset = t11.texData.slice.flatOffset), {
                        name: e15.variableNames[n22],
                        shapeInfo: r28
                    };
                }), s26 = a28.map(function(t11) {
                    return t11.shapeInfo;
                }), u15 = {
                    logicalShape: r27.shape,
                    texShape: r27.texData.texShape,
                    isUniform: !1,
                    isPacked: r27.texData.isPacked,
                    flatOffset: null
                }, c9 = fa(a28, u15, o31, e15.packedInputs), l12 = t10.createProgram(c9), h6 = null, f7 = t10.getUniformLocation(l12, "NAN", !1);
                1 === i15().getNumber("WEBGL_VERSION") && (h6 = t10.getUniformLocation(l12, "INFINITY", !1));
                for(var d8 = {
                }, p9 = 0; p9 < e15.variableNames.length; p9++){
                    var v10 = e15.variableNames[p9];
                    d8[v10] = t10.getUniformLocation(l12, v10, !1), d8["offset" + v10] = t10.getUniformLocation(l12, "offset" + v10, !1);
                }
                return {
                    program: e15,
                    source: c9,
                    webGLProgram: l12,
                    uniformLocations: d8,
                    inShapeInfos: s26,
                    outShapeInfo: u15,
                    infLoc: h6,
                    nanLoc: f7
                };
            })(a27.gpgpu, t9, h5, d7);
        }), m10 = null != this.activeTimers;
        if (m10 && (f6 = this.startTimer()), (function(t10, e15, n21, r27, o31) {
            Pi(e15.inShapeInfos, n21), Pi([
                e15.outShapeInfo
            ], [
                r27
            ]);
            var a28 = r27.texData.texture, s26 = r27.texData.texShape;
            r27.texData.isPacked ? t10.setOutputPackedMatrixTexture(a28, s26[0], s26[1]) : t10.setOutputMatrixTexture(a28, s26[0], s26[1]), t10.setProgram(e15.webGLProgram), 1 === i15().getNumber("WEBGL_VERSION") && null !== e15.infLoc && t10.gl.uniform1f(e15.infLoc, 1 / 0), null !== e15.nanLoc && t10.gl.uniform1f(e15.nanLoc, NaN), n21.forEach(function(n22, r28) {
                var o32 = e15.program.variableNames[r28], a29 = e15.uniformLocations[o32], i24 = e15.uniformLocations["offset" + o32];
                if (null != a29) {
                    if (n22.isUniform) {
                        if (k(n22.shape) < 2) t10.gl.uniform1f(a29, n22.uniformValues[0]);
                        else {
                            var s27 = n22.uniformValues;
                            s27 instanceof Float32Array || (s27 = new Float32Array(s27)), t10.gl.uniform1fv(a29, s27);
                        }
                    } else null != n22.texData.slice && null != i24 && t10.gl.uniform1i(i24, n22.texData.slice.flatOffset), t10.setInputMatrixTexture(n22.texData.texture, a29, r28);
                }
            }), null != o31 && o31(t10, e15.webGLProgram), t10.executeProgram();
        })(this.gpgpu, v9, h5, d7, r25), l11.forEach(function(t10) {
            return a27.disposeData(t10.dataId);
        }), m10 && (f6 = this.endTimer(f6), this.activeTimers.push({
            name: t9.constructor.name,
            query: this.getQueryTime(f6)
        })), !i15().getBool("WEBGL_LAZILY_UNPACK") && u14.isPacked && !1 === o29) {
            var g9 = this.unpackTensor(s25);
            return this.disposeData(s25.dataId), g9;
        }
        return s25;
    }, o24.prototype.compileAndRun = function(t9, e14, n20, r25, o29) {
        (void 0) === o29 && (o29 = !1), n20 = n20 || e14[0].dtype;
        var a27 = this.runWebGLProgram(t9, e14, n20, r25, o29);
        return Lt.makeTensorFromDataId(a27.dataId, a27.shape, a27.dtype);
    }, o24.prototype.getAndSaveBinary = function(t9, e14) {
        return t9 in this.binaryCache || (this.binaryCache[t9] = e14()), this.binaryCache[t9];
    }, o24.prototype.getTextureManager = function() {
        return this.textureManager;
    }, o24.prototype.dispose = function() {
        var t9 = this;
        if (!this.disposed) {
            if (!i15().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function(e14) {
                t9.gpgpu.deleteProgram(t9.binaryCache[e14].webGLProgram), delete t9.binaryCache[e14];
            });
            this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;
        }
    }, o24.prototype.floatPrecision = function() {
        var t9 = this;
        return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function() {
            if (!i15().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                var e14 = i15().getBool("DEBUG");
                i15().set("DEBUG", !1);
                var n20 = t9.abs(On(0.00000001)).dataSync()[0];
                if (i15().set("DEBUG", e14), n20 > 0) return 32;
            }
            return 16;
        })), this.floatPrecisionValue;
    }, o24.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 0.0000001 : 0.0001;
    }, o24.prototype.uploadToGPU = function(t9) {
        var e15, n21 = this.texData.get(t9), r25 = n21.shape, o29 = n21.dtype, a27 = n21.values, i24 = n21.texture, s25 = n21.usage, u14 = n21.isPacked;
        if (null == i24) {
            var c9, l11 = null != this.activeTimers;
            l11 && (c9 = et());
            var h5 = n21.texShape;
            if (null == h5 && (h5 = Ne(r25, u14), n21.texShape = h5), null != a27) {
                var f6 = Te(r25), d7 = void 0, p8 = h5[1], v9 = h5[0], m10 = a27 instanceof Uint8Array;
                u14 ? (p8 = (e15 = $t(h5[0], h5[1]))[0], v9 = e15[1], d7 = new hi(f6, [
                    v9,
                    p8
                ], m10)) : d7 = new li(f6, [
                    v9,
                    p8
                ], m10);
                var g10 = this.makeTensorInfo([
                    v9,
                    p8
                ], o29);
                this.texData.get(g10.dataId).usage = m10 ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g10.dataId), p8, v9, a27);
                var y6 = this.runWebGLProgram(d7, [
                    g10
                ], o29, null, !0), x6 = this.texData.get(y6.dataId);
                n21.texture = x6.texture, n21.texShape = x6.texShape, n21.isPacked = x6.isPacked, n21.usage = x6.usage, this.disposeData(g10.dataId), this.texData.delete(y6.dataId), n21.values = null, l11 && (this.uploadWaitMs += et() - c9);
            } else {
                var b3 = this.acquireTexture(h5, s25, o29, u14);
                n21.texture = b3;
            }
        }
    }, o24.prototype.convertAndCacheOnCPU = function(t9, e15) {
        var n21 = this.texData.get(t9), r25 = n21.dtype;
        return this.releaseGPUData(t9), null != e15 && (n21.values = (function(t10, e16) {
            if ("float32" === e16 || "complex64" === e16) return t10;
            if ("int32" === e16 || "bool" === e16) {
                for(var n22 = "int32" === e16 ? new Int32Array(t10.length) : new Uint8Array(t10.length), r27 = 0; r27 < n22.length; ++r27)n22[r27] = Math.round(t10[r27]);
                return n22;
            }
            throw new Error("Unknown dtype " + e16);
        })(e15, r25)), n21.values;
    }, o24.prototype.acquireTexture = function(t9, e15, n21, r25) {
        if (this.numBytesInGPU += this.computeBytes(t9, n21), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
            var o29 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + o29 + " MB, most likely due to a memory leak");
        }
        return this.textureManager.acquireTexture(t9, e15, r25);
    }, o24.prototype.computeBytes = function(t9, e15) {
        return t9[0] * t9[1] * z(e15);
    }, o24;
}(bo);
Wt() && Lt.registerBackend("webgl", function() {
    return new Zs;
}, 2);
var tu = An({
    square_: function(t1) {
        var e15 = mn(t1, "x", "square"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9, n23) {
            return n23([
                e15
            ]), t9.square(e15);
        }, {
            x: e15
        }, null, "Square", {
        }, n21, []);
    }
}), eu = "SquaredDifference";
var nu = An({
    squaredDifference_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "squaredDifference"), o24 = mn(e15, "b", "squaredDifference");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape);
        var a27 = {
            a: r25,
            b: o24
        }, i24 = [
            r25,
            o24
        ];
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.squaredDifference(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, a27, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1], o31 = On(2);
            return {
                a: function() {
                    return t9.mul(n23.sub(r28).mul(o31));
                },
                b: function() {
                    return t9.mul(r28.sub(n23).mul(o31));
                }
            };
        }, eu, {
        }, i24, []);
    }
});
var ru = An({
    abs_: function(t1) {
        var e15 = mn(t1, "x", "abs");
        return "complex64" === e15.dtype ? Lt.runKernelFunc(function(t9) {
            return t9.complexAbs(e15);
        }, {
            $x: e15
        }) : Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.abs(e15);
            return n21([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                x: function() {
                    return t9.mul(n21.toFloat().step(-1));
                }
            };
        }, "Abs");
    }
}), ou = An({
    acos_: function(t1) {
        var e15 = mn(t1, "x", "acos");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.acos(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.divStrict(On(1).sub(n21.toFloat().square()).sqrt()).neg();
                }
            };
        });
    }
}), au = An({
    acosh_: function(t1) {
        var e15 = mn(t1, "x", "acosh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.acosh(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.divStrict(n21.toFloat().square().sub(1).sqrt());
                }
            };
        });
    }
}), iu = An({
    asin_: function(t1) {
        var e15 = mn(t1, "x", "asin");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.asin(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.divStrict(On(1).sub(n21.toFloat().square()).sqrt());
                }
            };
        });
    }
}), su = An({
    asinh_: function(t1) {
        var e15 = mn(t1, "x", "asinh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.asinh(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.divStrict(On(1).add(n21.toFloat().square()).sqrt());
                }
            };
        });
    }
}), uu = An({
    atan_: function(t1) {
        var e15 = mn(t1, "x", "atan");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.atan(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(n21.toFloat().square().add(1));
                }
            };
        });
    }
}), cu = An({
    atanh_: function(t1) {
        var e15 = mn(t1, "x", "atanh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.atanh(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(On(1).sub(n21.toFloat().square()));
                }
            };
        });
    }
}), lu = An({
    ceil_: function(t1) {
        var e15 = mn(t1, "x", "ceil");
        return Lt.runKernelFunc(function(t9) {
            return t9.ceil(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), hu = An({
    clipByValue_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "clipByValue");
        C(e15 <= n21, function() {
            return "Error in clip: min (" + e15 + ") must be less than or equal to max (" + n21 + ").";
        });
        var o24 = [
            r25
        ], a27 = {
            min: e15,
            max: n21
        };
        return Lt.runKernelFunc(function(t9, o31) {
            var a28 = t9.clip(r25, e15, n21);
            return o31([
                r25
            ]), a28;
        }, {
            x: r25
        }, function(t9, r28) {
            var o31 = r28[0];
            return {
                x: function() {
                    return t9.where(o31.greaterEqual(e15).logicalAnd(o31.lessEqual(n21)), Xn(t9));
                }
            };
        }, "ClipByValue", a27, o24);
    }
}), fu = An({
    cos_: function(t1) {
        var e15 = mn(t1, "x", "cos"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9, n23) {
            var r25 = t9.cos(e15);
            return n23([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                x: function() {
                    return n23.toFloat().sin().neg().mul(t9);
                }
            };
        }, "Cos", {
        }, n21);
    }
}), du = An({
    cosh_: function(t1) {
        var e15 = mn(t1, "x", "cosh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.cosh(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return n21.toFloat().sinh().mulStrict(t9);
                }
            };
        });
    }
}), pu = An({
    erf_: function(t1) {
        var e15 = mn(t1, "x", "erf");
        return C("int32" === e15.dtype || "float32" === e15.dtype, function() {
            return "Input dtype must be `int32` or `float32`.";
        }), "int32" === e15.dtype && (e15 = e15.toFloat()), Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.erf(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.mul(n21.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
                }
            };
        });
    }
}), vu = An({
    exp_: function(t1) {
        var e15 = mn(t1, "x", "exp");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.exp(e15);
            return n21([
                r25
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            return {
                x: function() {
                    return t9.mulStrict(e16[0]);
                }
            };
        }, "Exp", {
        }, [], [
            !0
        ]);
    }
}), mu = An({
    expm1_: function(t1) {
        var e15 = mn(t1, "x", "expm1");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.expm1(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.mul(n21.exp());
                }
            };
        });
    }
}), gu = An({
    floor_: function(t1) {
        var e15 = mn(t1, "x", "floor");
        return Lt.runKernelFunc(function(t9) {
            return t9.floor(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), yu = An({
    log_: function(t1) {
        var e15 = mn(t1, "x", "log"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9, n23) {
            var r25 = t9.log(e15);
            return n23([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                x: function() {
                    return t9.div(n23.toFloat());
                }
            };
        }, "Log", {
        }, n21);
    }
}), xu = An({
    log1p_: function(t1) {
        var e15 = mn(t1, "x", "log1p");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.log1p(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(n21.add(1));
                }
            };
        });
    }
}), bu = An({
    logSigmoid_: function(t1) {
        var e15 = mn(t1, "x", "logSigmoid");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.softplus(e15.neg()).neg();
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.mul(n21.neg().sigmoid());
                }
            };
        });
    }
}), wu = An({
    neg_: function(t1) {
        var e15 = mn(t1, "x", "neg"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9) {
            return t9.neg(e15);
        }, {
            x: e15
        }, function(t9) {
            return {
                x: function() {
                    return t9.neg();
                }
            };
        }, "Neg", {
        }, n21);
    }
}), Cu = An({
    reciprocal_: function(t1) {
        var e15 = mn(t1, "x", "reciprocal");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.reciprocal(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(n21.square().neg());
                }
            };
        });
    }
}), Eu = An({
    round_: function(t1) {
        var e15 = mn(t1, "x", "round");
        return Lt.runKernelFunc(function(t9) {
            return t9.round(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Ru = An({
    rsqrt_: function(t1) {
        var e15 = mn(t1, "x", "rsqrt"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9, n23) {
            var r25 = t9.rsqrt(e15);
            return n23([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                x: function() {
                    return t9.div(n23.pow(1.5).mul(2)).neg();
                }
            };
        }, "Rsqrt", {
        }, n21);
    }
}), Iu = An({
    sigmoid_: function(t1) {
        var e15 = mn(t1, "x", "sigmoid");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.sigmoid(e15);
            return n21([
                r25
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                x: function() {
                    return t9.mul(n21.mul(On(1).sub(n21)));
                }
            };
        }, "Sigmoid");
    }
}), ku = An({
    sign_: function(t1) {
        var e15 = mn(t1, "x", "sign");
        return Lt.runKernelFunc(function(t9) {
            return t9.sign(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Su = An({
    isNaN_: function(t1) {
        var e15 = mn(t1, "x", "isNaN");
        return Lt.runKernelFunc(function(t9) {
            return t9.isNaN(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Au = An({
    isInf_: function(t1) {
        var e15 = mn(t1, "x", "isInf");
        return Lt.runKernelFunc(function(t9) {
            return t9.isInf(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Du = An({
    isFinite_: function(t1) {
        var e15 = mn(t1, "x", "isFinite");
        return Lt.runKernelFunc(function(t9) {
            return t9.isFinite(e15);
        }, {
            $x: e15
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Tu = An({
    sin_: function(t1) {
        var e15 = mn(t1, "x", "sin"), n21 = [
            e15
        ];
        return Lt.runKernelFunc(function(t9, n23) {
            var r25 = t9.sin(e15);
            return n23([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                x: function() {
                    return n23.toFloat().cos().mul(t9);
                }
            };
        }, "Sin", {
        }, n21);
    }
}), Nu = An({
    sinh_: function(t1) {
        var e15 = mn(t1, "x", "sinh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.sinh(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return n21.toFloat().cosh().mulStrict(t9);
                }
            };
        });
    }
}), Fu = An({
    softplus_: function(t1) {
        var e15 = mn(t1, "x", "softplus");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.softplus(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.mul(n21.sigmoid());
                }
            };
        });
    }
}), _u = An({
    sqrt_: function(t1) {
        var e15 = mn(t1, "x", "sqrt");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.sqrt(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(n21.toFloat().sqrt().mul(2));
                }
            };
        });
    }
}), Ou = An({
    step_: function(t1, e15) {
        (void 0) === e15 && (e15 = 0);
        var n21 = mn(t1, "x", "step");
        return Lt.runKernelFunc(function(t9) {
            return t9.step(n21, e15);
        }, {
            $x: n21
        }, function(t9) {
            return {
                $x: function() {
                    return Xn(t9);
                }
            };
        });
    }
}), Mu = An({
    tan_: function(t1) {
        var e15 = mn(t1, "x", "tan");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.tan(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return t9.div(n21.cos().square());
                }
            };
        });
    }
}), Bu = An({
    tanh_: function(t1) {
        var e15 = mn(t1, "x", "tanh");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.tanh(e15);
            return n21([
                r25
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                x: function() {
                    return On(1).sub(n21.square()).mulStrict(t9);
                }
            };
        }, "Tanh", {
        }, null, [
            !0
        ]);
    }
});
function Pu(t1, e15, n21, r25, o24, a27) {
    var i24, s25, u14 = mn(t1, "x", "batchNorm"), c10 = mn(e15, "mean", "batchNorm"), l12 = mn(n21, "variance", "batchNorm");
    return null != o24 && (i24 = mn(o24, "scale", "batchNorm")), null != r25 && (s25 = mn(r25, "offset", "batchNorm")), C(2 === u14.rank, function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u14.rank + ".";
    }), C(2 === c10.rank || 1 === c10.rank, function() {
        return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c10.rank + ".";
    }), C(2 === l12.rank || 1 === l12.rank, function() {
        return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l12.rank + ".";
    }), null != i24 && C(2 === i24.rank || 1 === i24.rank, function() {
        return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i24.rank + ".";
    }), null != s25 && C(2 === s25.rank || 1 === s25.rank, function() {
        return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s25.rank + ".";
    }), Uu(u14, c10, l12, s25, i24, a27);
}
function Lu(t1, e15, n21, r25, o24, a27) {
    var i24, s25, u14 = mn(t1, "x", "batchNorm"), c10 = mn(e15, "mean", "batchNorm"), l12 = mn(n21, "variance", "batchNorm");
    return null != o24 && (i24 = mn(o24, "scale", "batchNorm")), null != r25 && (s25 = mn(r25, "offset", "batchNorm")), C(3 === u14.rank, function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u14.rank + ".";
    }), C(3 === c10.rank || 1 === c10.rank, function() {
        return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c10.rank + ".";
    }), C(3 === l12.rank || 1 === l12.rank, function() {
        return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l12.rank + ".";
    }), null != i24 && C(3 === i24.rank || 1 === i24.rank, function() {
        return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i24.rank + ".";
    }), null != s25 && C(3 === s25.rank || 1 === s25.rank, function() {
        return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s25.rank + ".";
    }), Uu(u14, c10, l12, s25, i24, a27);
}
function Wu(t1, e15, n21, r25, o24, a27) {
    var i24, s25, u14 = mn(t1, "x", "batchNorm"), c10 = mn(e15, "mean", "batchNorm"), l12 = mn(n21, "variance", "batchNorm");
    return null != o24 && (i24 = mn(o24, "scale", "batchNorm")), null != r25 && (s25 = mn(r25, "offset", "batchNorm")), C(4 === u14.rank, function() {
        return "Error in batchNorm4D: x must be rank 4 but got rank " + u14.rank + ".";
    }), C(4 === c10.rank || 1 === c10.rank, function() {
        return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c10.rank + ".";
    }), C(4 === l12.rank || 1 === l12.rank, function() {
        return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l12.rank + ".";
    }), null != i24 && C(4 === i24.rank || 1 === i24.rank, function() {
        return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i24.rank + ".";
    }), null != s25 && C(4 === s25.rank || 1 === s25.rank, function() {
        return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s25.rank + ".";
    }), Uu(u14, c10, l12, s25, i24, a27);
}
function Uu(t1, e15, n21, r25, o24, a27) {
    null == a27 && (a27 = 0.001);
    var i24, s25, u14, c10 = mn(t1, "x", "batchNorm"), l12 = mn(e15, "mean", "batchNorm"), h6 = mn(n21, "variance", "batchNorm");
    null != o24 && (i24 = mn(o24, "scale", "batchNorm")), null != r25 && (s25 = mn(r25, "offset", "batchNorm")), C(l12.rank === h6.rank, function() {
        return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), C(null == s25 || l12.rank === s25.rank, function() {
        return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), C(null == i24 || l12.rank === i24.rank, function() {
        return "Batch normalization gradient requires mean and scale to have equal ranks.";
    }), u14 = 0 === c10.rank || 1 === c10.rank ? c10.as4D(1, 1, 1, c10.size) : 2 === c10.rank ? c10.as4D(1, 1, c10.shape[0], c10.shape[1]) : 3 === c10.rank ? c10.as4D(1, c10.shape[0], c10.shape[1], c10.shape[2]) : c10;
    var f7 = [
        c10,
        l12,
        h6,
        i24
    ];
    return Lt.runKernelFunc(function(t9, e16) {
        var n23 = t9.batchNormalization(u14, Vu(l12), Vu(h6), a27, Vu(i24), Vu(s25));
        return e16([
            c10,
            l12,
            h6,
            i24
        ]), n23;
    }, {
        x: c10,
        mean: l12,
        variance: h6,
        scale: i24,
        offset: s25
    }, function(t9, e16) {
        var n23 = e16, r28 = n23[0], o31 = n23[1], i25 = n23[2], s26 = n23[3], c11 = null == s26 ? On(1) : s26, l13 = Eo(o31.shape, u14.shape), h7 = [];
        if (1 === o31.rank) {
            for(var f8 = 0; f8 < u14.shape.length - 1; ++f8)h7.push(u14.shape[f8]);
            h7.push(1);
        }
        var d8 = r28.sub(o31), p9 = t9.mul(c11), v11 = Ru(i25.add(On(a27))), m11 = v11.mul(v11).mul(v11).mul(On(-0.5));
        return {
            x: function() {
                return 1 === o31.rank ? t9.mul(Lr(v11.as4D(1, 1, 1, o31.shape[0]), h7)).mul(c11).reshape(r28.shape) : t9.mul(v11).mul(c11).reshape(r28.shape);
            },
            mean: function() {
                var t10 = v11.mul(On(-1)).mul(p9);
                return 1 === o31.rank && (t10 = t10.sum(l13)), t10.reshape(o31.shape);
            },
            variance: function() {
                var t10 = m11.mul(d8).mul(p9);
                return 1 === o31.rank && (t10 = t10.sum(l13)), t10.reshape(o31.shape);
            },
            scale: function() {
                var e17 = d8.mul(v11), n24 = t9.mul(e17);
                return 1 === o31.rank && (n24 = n24.sum(l13)), n24.reshape(o31.shape);
            },
            offset: function() {
                var e17 = t9;
                return 1 === o31.rank && (e17 = e17.sum(l13)), e17.reshape(o31.shape);
            }
        };
    }, "BatchNormalization", {
        varianceEpsilon: a27
    }, f7).reshape(c10.shape);
}
function Vu(t1) {
    return null == t1 ? null : 0 === t1.rank ? t1.as1D() : 1 === t1.rank ? t1 : 2 === t1.rank ? t1.as4D(1, 1, t1.shape[0], t1.shape[1]) : 3 === t1.rank ? t1.as4D(1, t1.shape[0], t1.shape[1], t1.shape[2]) : t1;
}
function zu() {
    Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
var Gu = An({
    batchNormalization2d_: function(t1, e15, n21, r25, o24, a27) {
        return (void 0) === r25 && (r25 = 0.001), zu(), Pu(t1, e15, n21, a27, o24, r25);
    }
}), Hu = An({
    batchNormalization3d_: function(t1, e15, n21, r25, o24, a27) {
        return (void 0) === r25 && (r25 = 0.001), zu(), Lu(t1, e15, n21, a27, o24, r25);
    }
}), qu = An({
    batchNormalization4d_: function(t1, e15, n21, r25, o24, a27) {
        return (void 0) === r25 && (r25 = 0.001), zu(), Wu(t1, e15, n21, a27, o24, r25);
    }
}), Ku = An({
    batchNormalization_: function(t1, e15, n21, r25, o24, a27) {
        return (void 0) === r25 && (r25 = 0.001), zu(), Uu(t1, e15, n21, a27, o24, r25);
    }
}), ju = An({
    batchNorm_: Uu
}), Xu = An({
    batchNorm2d_: Pu
}), Yu = An({
    batchNorm3d_: Lu
}), $u = An({
    batchNorm4d_: Wu
});
var Qu = An({
    logicalAnd_: function(t1, e15) {
        var n21 = mn(t1, "a", "logicalAnd", "bool"), r25 = mn(e15, "b", "logicalAnd", "bool");
        return Ro(n21.shape, r25.shape), Lt.runKernelFunc(function(t9) {
            return t9.logicalAnd(n21, r25);
        }, {
            a: n21,
            b: r25
        }, null, "LogicalAnd");
    }
}), Ju = An({
    logicalNot_: function(t1) {
        var e15 = mn(t1, "x", "logicalNot", "bool");
        return Lt.runKernelFunc(function(t9) {
            return t9.logicalNot(e15);
        }, {
            $x: e15
        });
    }
}), Zu = An({
    logicalOr_: function(t1, e15) {
        var n21 = mn(t1, "a", "logicalOr", "bool"), r25 = mn(e15, "b", "logicalOr", "bool");
        return Ro(n21.shape, r25.shape), Lt.runKernelFunc(function(t9) {
            return t9.logicalOr(n21, r25);
        }, {
            $a: n21,
            $b: r25
        });
    }
}), tc = An({
    logicalXor_: function(t1, e15) {
        var n21 = mn(t1, "a", "logicalXor", "bool"), r25 = mn(e15, "b", "logicalXor", "bool");
        return Ro(n21.shape, r25.shape), Zu(t1, e15).logicalAnd(Qu(t1, e15).logicalNot());
    }
}), ec = An({
    where_: function(t1, e15, n21) {
        var r25 = mn(e15, "a", "where"), o24 = mn(n21, "b", "where"), a27 = mn(t1, "condition", "where", "bool");
        return E(r25.shape, o24.shape, "Error in where: "), 1 === a27.rank ? C(a27.shape[0] === r25.shape[0], function() {
            return "The first dimension of `a` must match the size of `condition`.";
        }) : E(a27.shape, o24.shape, "Error in where: "), Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.select(a27, r25, o24);
            return e16([
                a27
            ]), n23;
        }, {
            $condition: a27,
            $a: r25,
            $b: o24
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                $condition: function() {
                    return Xn(n23).toFloat();
                },
                $a: function() {
                    return t9.mul(n23.cast(t9.dtype));
                },
                $b: function() {
                    return t9.mul(n23.logicalNot().cast(t9.dtype));
                }
            };
        });
    }
}), nc = function(t1) {
    return n10(this, void 0, void 0, function() {
        var e15, n21, o24;
        return r17(this, function(r25) {
            switch(r25.label){
                case 0:
                    return [
                        4,
                        (e15 = mn(t1, "condition", "whereAsync", "bool")).data()
                    ];
                case 1:
                    return n21 = r25.sent(), o24 = na(e15.shape, n21), t1 !== e15 && e15.dispose(), [
                        2,
                        o24
                    ];
            }
        });
    });
};
var rc = An({
    add_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "add"), o24 = mn(e15, "b", "add");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9) {
            return t9.add(r25, o24);
        }, {
            a: r25,
            b: o24
        }, function(t9) {
            return {
                a: function() {
                    var e16 = t9, n23 = Eo(r25.shape, a27);
                    return n23.length > 0 && (e16 = e16.sum(n23)), e16.reshape(r25.shape);
                },
                b: function() {
                    var e16 = t9, n23 = Eo(o24.shape, a27);
                    return n23.length > 0 && (e16 = e16.sum(n23)), e16.reshape(o24.shape);
                }
            };
        }, "Add");
    }
}), oc = An({
    addN_: function(t1) {
        C(Array.isArray(t1), function() {
            return "The argument passed to tf.addN() must be a list of tensors";
        }), C(t1.length >= 1, function() {
            return "Must pass at least one tensor to tf.addN(), but got " + t1.length;
        });
        var e15 = t1.map(function(t9, e16) {
            return mn(t9, "tensors" + e16, "addN");
        }), n21 = e15[0];
        e15.forEach(function(t9) {
            if (t9.dtype !== n21.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }), e15.forEach(function(t9) {
            if (!S(t9.shape, n21.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
        });
        var r25 = e15;
        return Lt.runKernelFunc(function(t9) {
            return t9.addN(e15);
        }, r25, function(t9) {
            var n23 = {
            };
            return e15.forEach(function(e16, r28) {
                n23[r28] = function() {
                    return t9.clone();
                };
            }), n23;
        }, "AddN");
    }
}), ac = An({
    addStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "addStrict"), r25 = mn(e15, "b", "addStrict");
        return E(n21.shape, r25.shape, "Error in addStrict: "), n21.add(r25);
    }
}), ic = An({
    atan2_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "atan2"), o24 = mn(e15, "b", "atan2");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.atan2(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            $a: r25,
            $b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                $a: function() {
                    var e17 = rc(n23.square(), r28.square()), o31 = t9.mul(r28.div(e17)), i24 = Eo(n23.shape, a27);
                    return i24.length > 0 && (o31 = o31.sum(i24)), o31.reshape(n23.shape);
                },
                $b: function() {
                    var e17 = rc(n23.square(), r28.square()), o31 = wu(t9.mul(n23.div(e17))), i24 = Eo(r28.shape, a27);
                    return i24.length > 0 && (o31 = o31.sum(i24)), o31.reshape(r28.shape);
                }
            };
        });
    }
}), sc = An({
    div_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "div"), o24 = mn(e15, "b", "div");
        if (n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], "int32" === r25.dtype && "int32" === o24.dtype) return lc(r25, o24);
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.realDivide(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    var e17 = t9.div(r28.toFloat()), o31 = Eo(n23.shape, a27);
                    return o31.length > 0 ? e17.sum(o31).reshape(n23.shape) : e17;
                },
                b: function() {
                    var e17 = t9.mul(n23.toFloat()), o31 = Eo(r28.shape, a27);
                    o31.length > 0 && (e17 = e17.sum(o31).reshape(r28.shape));
                    var i24 = r28.square();
                    return e17.div(i24.toFloat()).neg();
                }
            };
        }, "Div");
    }
}), uc = An({
    divNoNan_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "div"), o24 = mn(e15, "b", "div");
        r25 = (n21 = Nt(r25, o24))[0], o24 = n21[1];
        var a27 = sc(r25, o24), i24 = Xn(a27), s25 = o24.equal(i24);
        return ec(s25, i24, a27);
    }
}), cc = An({
    divStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "div"), r25 = mn(e15, "b", "div");
        return E(n21.shape, r25.shape, "Error in divideStrict: "), n21.div(r25);
    }
}), lc = An({
    floorDiv_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "floorDiv"), o24 = mn(e15, "b", "floorDiv");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.floorDiv(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    var e17 = t9.div(r28.toFloat()), o31 = Eo(n23.shape, a27);
                    return o31.length > 0 ? e17.sum(o31).reshape(n23.shape) : e17;
                },
                b: function() {
                    var e17 = t9.mul(n23.toFloat()), o31 = Eo(r28.shape, a27);
                    o31.length > 0 && (e17 = e17.sum(o31).reshape(r28.shape));
                    var i24 = r28.square();
                    return e17.div(i24.toFloat()).neg();
                }
            };
        }, "FloorDiv");
    }
}), hc = An({
    maximum_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "maximum"), o24 = mn(e15, "b", "maximum");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], "bool" === r25.dtype && (r25 = r25.toInt(), o24 = o24.toInt()), Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.maximum(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    return t9.mul(n23.greaterEqual(r28).toFloat());
                },
                b: function() {
                    return t9.mul(n23.less(r28).toFloat());
                }
            };
        }, "Maximum");
    }
}), fc = An({
    maximumStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "maximumStrict"), r25 = mn(e15, "b", "maximumStrict");
        return E(n21.shape, r25.shape, "Error in maximumStrict: "), n21.maximum(r25);
    }
}), dc = An({
    minimum_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "minimum"), o24 = mn(e15, "b", "minimum");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], "bool" === r25.dtype && (r25 = r25.toInt(), o24 = o24.toInt()), Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.minimum(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    return t9.mul(n23.lessEqual(r28).toFloat());
                },
                b: function() {
                    return t9.mul(n23.greater(r28).toFloat());
                }
            };
        }, "Minimum");
    }
}), pc = An({
    minimumStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "minimumStrict"), r25 = mn(e15, "b", "minimumStrict");
        return E(n21.shape, r25.shape, "Error in minimumStrict: "), n21.minimum(r25);
    }
}), vc = An({
    mod_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "mod"), o24 = mn(e15, "b", "mod");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.mod(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            $a: r25,
            $b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                $a: function() {
                    var e17 = Eo(n23.shape, a27);
                    return e17.length > 0 ? t9.sum(e17).reshape(n23.shape) : t9;
                },
                $b: function() {
                    var e17 = t9.mul(n23.div(r28).floor().neg()), o31 = Eo(r28.shape, a27);
                    return o31.length > 0 ? e17.sum(o31).reshape(r28.shape) : e17;
                }
            };
        });
    }
}), mc = An({
    modStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "modStrict"), r25 = mn(e15, "b", "modStrict");
        return E(n21.shape, r25.shape, "Error in modStrict: "), n21.mod(r25);
    }
}), gc = An({
    mul_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "mul"), o24 = mn(e15, "b", "mul");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.multiply(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    var e17 = t9.mul(r28.toFloat()), o31 = Eo(n23.shape, a27);
                    return o31.length > 0 ? e17.sum(o31).reshape(n23.shape) : e17;
                },
                b: function() {
                    var e17 = t9.mul(n23.toFloat()), o31 = Eo(r28.shape, a27);
                    return o31.length > 0 ? e17.sum(o31).reshape(r28.shape) : e17;
                }
            };
        }, "Mul");
    }
}), yc = An({
    mulStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "mul"), r25 = mn(e15, "b", "mul");
        return E(n21.shape, r25.shape, "Error in multiplyStrict: "), n21.mul(r25);
    }
}), xc = An({
    pow_: function(t1, e15) {
        var n21, r25 = mn(t1, "base", "pow"), o24 = mn(e15, "exp", "pow");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape), i24 = [
            r25,
            o24
        ];
        return Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.pow(r25, o24);
            return e16([
                r25,
                o24,
                n23
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1], o31 = e16[2];
            return {
                a: function() {
                    var e17 = r28.toFloat(), o32 = t9.mul(e17.mul(n23.pow(e17.sub(On(1))))), i25 = Eo(n23.shape, a27);
                    return i25.length > 0 && (o32 = o32.sum(i25)), o32.reshape(n23.shape);
                },
                b: function() {
                    var e17 = n23.greater(0), i25 = n23.log().where(e17, Xn(n23)), s25 = t9.mul(o31.mul(i25)), u14 = Eo(r28.shape, a27);
                    return u14.length > 0 && (s25 = s25.sum(u14)), s25.reshape(r28.shape);
                }
            };
        }, "Pow", {
        }, i24, [
            !0
        ]);
    }
}), bc = An({
    powStrict_: function(t1, e15) {
        return E(t1.shape, e15.shape, "Error in powStrict: "), t1.pow(e15);
    }
}), wc = An({
    squaredDifferenceStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "squaredDifferenceStrict"), r25 = mn(e15, "b", "squaredDifferenceStrict");
        return E(n21.shape, r25.shape, "Error in squaredDifferenceStrict: "), n21.squaredDifference(r25);
    }
}), Cc = An({
    sub_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "sub"), o24 = mn(e15, "b", "sub");
        n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1];
        var a27 = Ro(r25.shape, o24.shape);
        return Lt.runKernelFunc(function(t9) {
            return t9.subtract(r25, o24);
        }, {
            a: r25,
            b: o24
        }, function(t9) {
            return {
                a: function() {
                    var e16 = t9, n23 = Eo(r25.shape, a27);
                    return n23.length > 0 && (e16 = e16.sum(n23)), e16.reshape(r25.shape);
                },
                b: function() {
                    var e16 = t9, n23 = Eo(o24.shape, a27);
                    return n23.length > 0 && (e16 = e16.sum(n23)), e16.neg().reshape(o24.shape);
                }
            };
        }, "Sub");
    }
}), Ec = An({
    subStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "subStrict"), r25 = mn(e15, "b", "subStrict");
        return E(n21.shape, r25.shape, "Error in subStrict: "), n21.sub(r25);
    }
});
var Rc = An({
    equal_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "equal"), o24 = mn(e15, "b", "equal");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9) {
            return t9.equal(r25, o24);
        }, {
            $a: r25,
            $b: o24
        });
    }
}), Ic = An({
    equalStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "equalStrict"), r25 = mn(e15, "b", "equalStrict");
        return E(n21.shape, r25.shape, "Error in equalStrict: "), n21.equal(r25);
    }
}), kc = An({
    greater_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "greater"), o24 = mn(e15, "b", "greater");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9) {
            return t9.greater(r25, o24);
        }, {
            a: r25,
            b: o24
        }, null, "Greater");
    }
}), Sc = An({
    greaterEqual_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "greaterEqual"), o24 = mn(e15, "b", "greaterEqual");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.greaterEqual(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1];
            return {
                a: function() {
                    return Xn(n23);
                },
                b: function() {
                    return Xn(r28);
                }
            };
        }, "GreaterEqual");
    }
}), Ac = An({
    greaterEqualStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "greaterEqualStrict"), r25 = mn(e15, "b", "greaterEqualStrict");
        return E(n21.shape, r25.shape, "Error in greaterEqualStrict: "), n21.greaterEqual(r25);
    }
}), Dc = An({
    greaterStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "greaterStrict"), r25 = mn(e15, "b", "greaterStrict");
        return E(n21.shape, r25.shape, "Error in greaterStrict: "), n21.greater(r25);
    }
}), Tc = An({
    less_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "less"), o24 = mn(e15, "b", "less");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9) {
            return t9.less(r25, o24);
        }, {
            a: r25,
            b: o24
        }, null, "Less");
    }
}), Nc = An({
    lessEqual_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "lessEqual"), o24 = mn(e15, "b", "lessEqual");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.lessEqual(r25, o24);
            return e16([
                r25,
                o24
            ]), n23;
        }, {
            a: r25,
            b: o24
        }, null, "LessEqual");
    }
}), Fc = An({
    lessEqualStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "lessEqualStrict"), r25 = mn(e15, "b", "lessEqualStrict");
        return E(n21.shape, r25.shape, "Error in lessEqualStrict: "), n21.lessEqual(r25);
    }
}), _c = An({
    lessStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "lessStrict"), r25 = mn(e15, "b", "lessStrict");
        return E(n21.shape, r25.shape, "Error in lessStrict: "), n21.less(r25);
    }
}), Oc = An({
    notEqual_: function(t1, e15) {
        var n21, r25 = mn(t1, "a", "notEqual"), o24 = mn(e15, "b", "notEqual");
        return n21 = Nt(r25, o24), r25 = n21[0], o24 = n21[1], Ro(r25.shape, o24.shape), Lt.runKernelFunc(function(t9) {
            return t9.notEqual(r25, o24);
        }, {
            a: r25,
            b: o24
        }, null, "NotEqual");
    }
}), Mc = An({
    notEqualStrict_: function(t1, e15) {
        var n21 = mn(t1, "a", "notEqualStrict"), r25 = mn(e15, "b", "notEqualStrict");
        return E(n21.shape, r25.shape, "Error in notEqualStrict: "), n21.notEqual(r25);
    }
});
function Bc(t1, e15) {
    for(var n21 = [], r25 = t1; r25 < e15; ++r25)n21.push(r25);
    return n21;
}
function Pc(t1) {
    for(var e15 = [], n21 = 0; n21 < t1.length; ++n21)for(var r25 = 0; r25 < t1[n21].length; ++r25)e15.push(t1[n21][r25]);
    return e15;
}
var Lc = An({
    gather_: function(t1, e15, n21) {
        (void 0) === n21 && (n21 = 0);
        var r25 = mn(t1, "x", "gather"), o24 = mn(e15, "indices", "gather", "int32");
        n21 = O(n21, r25.shape)[0];
        var a27 = function(t9, e16, n23) {
            for(var r28 = t9.shape[n23], o31 = [], a28 = 1, i24 = 1, s25 = 0; s25 < n23; s25++)o31.push(t9.shape[s25]), a28 *= t9.shape[s25];
            for(s25 = 0; s25 < e16.rank; s25++)o31.push(e16.shape[s25]);
            for(s25 = n23 + 1; s25 < t9.rank; s25++)o31.push(t9.shape[s25]), i24 *= t9.shape[s25];
            return {
                batchSize: a28,
                sliceSize: i24,
                dimSize: r28,
                outputShape: o31
            };
        }(r25, o24, n21);
        return Lt.runKernelFunc(function(t9, e16) {
            var a28 = t9.gather(r25, o24.flatten(), n21);
            return e16([
                o24
            ]), a28;
        }, {
            x: r25,
            indices: o24
        }, function(t9, e16) {
            var o31 = e16[0];
            return {
                x: function() {
                    var e17 = r25.shape, a28 = o31.size, i24 = e17.slice(0, n21), s25 = i24.length, u14 = e17.slice(n21, e17.length).slice(1), c10 = u14.length, l12 = Bc(0, s25), h6 = Bc(s25 + 1, s25 + 1 + c10), f7 = Pc([
                        i24,
                        [
                            a28
                        ],
                        u14
                    ]), d8 = t9.reshape(f7), p9 = o31.reshape([
                        a28
                    ]), v11 = Pc([
                        [
                            s25
                        ],
                        l12,
                        h6
                    ]), m11 = d8.transpose(v11), g11 = Wc(m11, p9, r25.shape[n21]), y7 = Rn(v11);
                    return g11 = g11.transpose(y7);
                },
                indices: function() {
                    return o31;
                }
            };
        }, "Gather", {
            axis: n21
        }).reshape(a27.outputShape);
    }
}), Wc = An({
    unsortedSegmentSum_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "unsortedSegmentSum"), o24 = mn(e15, "segmentIds", "unsortedSegmentSum", "int32");
        return C(A(n21), function() {
            return "numSegments must be of dtype int";
        }), Lt.runKernelFunc(function(t9, e16) {
            var a27 = t9.unsortedSegmentSum(r25, o24, n21);
            return e16([
                o24
            ]), a27;
        }, {
            $x: r25
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                $x: function() {
                    return (function(t10, e17) {
                        for(var n24 = hc(e17, Xn(e17)), r28 = Lc(t10, n24), o31 = Sc(e17, On(0, "int32")), a27 = r28.rank - o31.rank, i24 = 0; i24 < a27; ++i24)o31 = wr(o31, i24 + 1);
                        o31 = Qu(o31, zn(r28.shape, "bool"));
                        var s25 = Xn(r28);
                        return ec(o31, r28, s25);
                    })(t9, n23);
                }
            };
        });
    }
});
var Uc = function(t1, e15, o24) {
    return n10(this, void 0, void 0, function() {
        var n21, a27, i24, s25, u14, c10, l12, h6, f7, d8, p9, v11, m11;
        return r17(this, function(r25) {
            switch(r25.label){
                case 0:
                    for(n21 = mn(t1, "tensor", "boolMask"), a27 = mn(e15, "mask", "boolMask", "bool"), i24 = null == o24 ? 0 : o24, s25 = a27.rank, u14 = n21.shape, C(s25 > 0, function() {
                        return "mask cannot be scalar";
                    }), E(u14.slice(i24, i24 + s25), a27.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c10 = 1, l12 = i24; l12 < i24 + s25; l12++)c10 *= u14[l12];
                    return h6 = u14.slice(0, i24).concat([
                        c10
                    ], u14.slice(i24 + s25)), f7 = n21.reshape(h6), d8 = a27.reshape([
                        -1
                    ]), [
                        4,
                        nc(d8)
                    ];
                case 1:
                    return p9 = r25.sent(), v11 = p9.squeeze([
                        1
                    ]), m11 = Lc(f7, v11, i24), t1 !== n21 && n21.dispose(), e15 !== a27 && a27.dispose(), v11.dispose(), f7.dispose(), d8.dispose(), p9.dispose(), [
                        2,
                        m11
                    ];
            }
        });
    });
};
function Vc(t1, e15, n21, r25, o24, a27, i24) {
    (void 0) === a27 && (a27 = "NHWC"), C(t1.length === e15.rank, function() {
        return "Length of inShape (" + t1.length + ") and rank of dy (" + e15.rank + ") must match";
    });
    var s25 = t1, u14 = e15, c10 = !1;
    3 === e15.rank && (c10 = !0, u14 = e15.as4D(1, e15.shape[0], e15.shape[1], e15.shape[2]), s25 = [
        1,
        t1[0],
        t1[1],
        t1[2]
    ]), C(4 === s25.length, function() {
        return "Error in conv2dDerInput: inShape must be length 4, but got length " + s25.length + ".";
    }), C(4 === u14.rank, function() {
        return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u14.rank;
    }), C(4 === n21.rank, function() {
        return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n21.rank;
    });
    var l12 = "NHWC" === a27 ? s25[3] : s25[1], h6 = "NHWC" === a27 ? u14.shape[3] : u14.shape[1];
    C(l12 === n21.shape[2], function() {
        return "Error in conv2dDerInput: depth of input (" + l12 + ") must match input depth for filter " + n21.shape[2] + ".";
    }), C(h6 === n21.shape[3], function() {
        return "Error in conv2dDerInput: depth of output (" + h6 + ") must match output depth for filter " + n21.shape[3] + ".";
    }), null != i24 && C(A(o24), function() {
        return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i24 + " but got pad " + o24 + ".";
    });
    var f7 = Bo(a27), d8 = So(s25, n21.shape, r25, 1, o24, i24, !1, f7), p9 = Lt.runKernelFunc(function(t9, e16) {
        var r28 = t9.conv2dDerInput(u14, n21, d8);
        return e16([
            n21,
            u14
        ]), r28;
    }, {
        dy4D: u14,
        filter: n21
    }, function(t9, e16) {
        var n23 = e16[0], s26 = e16[1];
        return {
            dy4D: function() {
                return qc(t9, n23, r25, o24, a27, 1, i24);
            },
            filter: function() {
                return jc(t9, s26, n23.shape, r25, o24, a27, i24);
            }
        };
    });
    return c10 ? p9.as3D(p9.shape[1], p9.shape[2], p9.shape[3]) : p9;
}
function zc(t1) {
    var e15 = function(t9) {
        return "number" == typeof t9 ? [
            t9,
            t9,
            t9
        ] : 2 === t9.length ? [
            t9[0],
            t9[1],
            1
        ] : t9;
    }(t1), n21 = e15[0], r25 = e15[1], o24 = e15[2];
    return 1 === n21 && 1 === r25 && 1 === o24;
}
function Gc(t1, e15, n21, r25, o24) {
    C(t1.length === e15.rank, function() {
        return "Length of inShape (" + t1.length + ") and rank of dy (" + e15.rank + ") must match";
    });
    var a27 = t1, i24 = e15, s25 = !1;
    4 === e15.rank && (s25 = !0, i24 = e15.as5D(1, e15.shape[0], e15.shape[1], e15.shape[2], e15.shape[3]), a27 = [
        1,
        t1[0],
        t1[1],
        t1[2],
        t1[3]
    ]);
    var u14 = a27[4], c10 = i24.shape[4];
    C(5 === a27.length, function() {
        return "Error in conv3dDerInput: inShape must be length 5, but got length " + a27.length + ".";
    }), C(5 === i24.rank, function() {
        return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i24.rank;
    }), C(5 === n21.rank, function() {
        return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n21.rank;
    }), C(u14 === n21.shape[3], function() {
        return "Error in conv3dDerInput: depth of input (" + u14 + ") must match input depth for filter " + n21.shape[3] + ".";
    }), C(c10 === n21.shape[4], function() {
        return "Error in conv3dDerInput: depth of output (" + c10 + ") must match output depth for filter " + n21.shape[4] + ".";
    });
    var l12 = Ao(a27, n21.shape, r25, 1, o24), h6 = Lt.runKernelFunc(function(t9) {
        return t9.conv3dDerInput(i24, n21, l12);
    }, {
        dy5D: i24
    });
    return s25 ? h6.as4D(h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]) : h6;
}
var Hc = An({
    conv1d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === o24 && (o24 = "NWC"), (void 0) === a27 && (a27 = 1);
        var s25 = mn(t1, "x", "conv1d"), u14 = mn(e15, "filter", "conv1d"), c10 = s25, l12 = !1;
        2 === s25.rank && (l12 = !0, c10 = s25.as3D(1, s25.shape[0], s25.shape[1])), C(3 === c10.rank, function() {
            return "Error in conv1d: input must be rank 3, but got rank " + c10.rank + ".";
        }), C(3 === u14.rank, function() {
            return "Error in conv1d: filter must be rank 3, but got rank " + u14.rank + ".";
        }), null != i24 && C(A(r25), function() {
            return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i24 + " but got pad " + r25 + ".";
        }), C(c10.shape[2] === u14.shape[1], function() {
            return "Error in conv1d: depth of input (" + c10.shape[2] + ") must match input depth for filter " + u14.shape[1] + ".";
        }), C(Mo(n21, a27), function() {
            return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n21 + " and dilation '" + a27 + "'";
        }), C("NWC" === o24, function() {
            return "Error in conv1d: got dataFormat of " + o24 + " but only NWC is currently supported.";
        });
        var h6 = u14.as4D(1, u14.shape[0], u14.shape[1], u14.shape[2]), f7 = c10.as4D(c10.shape[0], 1, c10.shape[1], c10.shape[2]), d8 = qc(f7, h6, [
            1,
            n21
        ], r25, "NHWC", [
            1,
            a27
        ], i24);
        return l12 ? d8.as2D(d8.shape[2], d8.shape[3]) : d8.as3D(d8.shape[0], d8.shape[2], d8.shape[3]);
    }
}), qc = An({
    conv2d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === o24 && (o24 = "NHWC"), (void 0) === a27 && (a27 = [
            1,
            1
        ]);
        var s25 = mn(t1, "x", "conv2d"), u14 = mn(e15, "filter", "conv2d"), c10 = s25, l12 = !1;
        3 === s25.rank && (l12 = !0, c10 = s25.as4D(1, s25.shape[0], s25.shape[1], s25.shape[2])), C(4 === c10.rank, function() {
            return "Error in conv2d: input must be rank 4, but got rank " + c10.rank + ".";
        }), C(4 === u14.rank, function() {
            return "Error in conv2d: filter must be rank 4, but got rank " + u14.rank + ".";
        }), null != i24 && C(A(r25), function() {
            return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i24 + " but got pad " + r25 + ".";
        });
        var h6 = "NHWC" === o24 ? c10.shape[3] : c10.shape[1];
        C(h6 === u14.shape[2], function() {
            return "Error in conv2d: depth of input (" + h6 + ") must match input depth for filter " + u14.shape[2] + ".";
        }), C(Mo(n21, a27), function() {
            return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + a27 + "'";
        });
        var f7 = Bo(o24), d8 = So(c10.shape, u14.shape, n21, a27, r25, i24, !1, f7), p9 = [
            u14,
            c10
        ], v11 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.conv2d(c10, u14, d8);
            return e16([
                u14,
                c10
            ]), n23;
        }, {
            x: c10,
            filter: u14
        }, function(t9, e16) {
            var i25 = e16, s26 = i25[0], u15 = i25[1];
            return C(Oo(a27), function() {
                return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a27 + "'";
            }), {
                x: function() {
                    return Xc(u15.shape, t9, s26, n21, r25, o24);
                },
                filter: function() {
                    return jc(u15, t9, s26.shape, n21, r25, o24);
                }
            };
        }, "Conv2D", d8, p9);
        return l12 ? v11.as3D(v11.shape[1], v11.shape[2], v11.shape[3]) : v11;
    }
}), Kc = An({
    conv3d_: function(t1, e15, n21, r25, o24, a27) {
        (void 0) === o24 && (o24 = "NDHWC"), (void 0) === a27 && (a27 = [
            1,
            1,
            1
        ]);
        var i24 = mn(t1, "x", "conv3d"), s25 = mn(e15, "filter", "conv3d"), u14 = i24, c10 = !1;
        4 === i24.rank && (c10 = !0, u14 = i24.as5D(1, i24.shape[0], i24.shape[1], i24.shape[2], i24.shape[3])), C(5 === u14.rank, function() {
            return "Error in conv3d: input must be rank 5, but got rank " + u14.rank + ".";
        }), C(5 === s25.rank, function() {
            return "Error in conv3d: filter must be rank 5, but got rank " + s25.rank + ".";
        }), C(u14.shape[4] === s25.shape[3], function() {
            return "Error in conv3d: depth of input (" + u14.shape[4] + ") must match input depth for filter " + s25.shape[3] + ".";
        }), C(function(t9, e16) {
            return zc(t9) || zc(e16);
        }(n21, a27), function() {
            return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + a27 + "'";
        }), C("NDHWC" === o24, function() {
            return "Error in conv3d: got dataFormat of " + o24 + " but only NDHWC is currently supported.";
        });
        var l12 = Ao(u14.shape, s25.shape, n21, a27, r25), h6 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.conv3d(u14, s25, l12);
            return e16([
                u14,
                s25
            ]), n23;
        }, {
            x: u14,
            $filter: s25
        }, function(t9, e16) {
            C(zc(a27), function() {
                return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a27 + "'";
            });
            var o31 = e16[0], i25 = e16[1];
            return {
                x: function() {
                    return Gc(o31.shape, t9, i25, n21, r25);
                },
                $filter: function() {
                    return (function(t10, e17, n23, r28, o32) {
                        var a28 = t10;
                        4 === t10.rank && (a28 = t10.as5D(1, t10.shape[0], t10.shape[1], t10.shape[2], t10.shape[3]));
                        var i26 = e17;
                        4 === i26.rank && (i26 = e17.as5D(1, e17.shape[0], e17.shape[1], e17.shape[2], e17.shape[3]));
                        C(5 === a28.rank, function() {
                            return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a28.shape + ".";
                        }), C(5 === i26.rank, function() {
                            return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i26.shape + ".";
                        }), C(5 === n23.length, function() {
                            return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n23 + ".";
                        }), C(a28.shape[4] === n23[3], function() {
                            return "Error in conv3dDerFilter: depth of input " + a28.shape[4] + ") must match input depth in filter (" + n23[3] + ".";
                        }), C(i26.shape[4] === n23[4], function() {
                            return "Error in conv3dDerFilter: depth of dy (" + i26.shape[4] + ") must match output depth for filter (" + n23[4] + ").";
                        });
                        var s26 = Ao(a28.shape, n23, r28, 1, o32);
                        return Lt.runKernelFunc(function(t11) {
                            return t11.conv3dDerFilter(a28, i26, s26);
                        }, {
                            x5D: a28,
                            dy5D: i26
                        });
                    })(o31, t9, i25.shape, n21, r25);
                }
            };
        });
        return c10 ? h6.as4D(h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]) : h6;
    }
}), jc = An({
    conv2dDerFilter_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === a27 && (a27 = "NHWC");
        var s25 = t1;
        3 === t1.rank && (s25 = t1.as4D(1, t1.shape[0], t1.shape[1], t1.shape[2]));
        var u14 = e15;
        3 === u14.rank && (u14 = e15.as4D(1, e15.shape[0], e15.shape[1], e15.shape[2])), C(4 === s25.rank, function() {
            return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s25.shape + ".";
        }), C(4 === u14.rank, function() {
            return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u14.shape + ".";
        }), C(4 === n21.length, function() {
            return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n21 + ".";
        });
        var c10 = "NHWC" === a27 ? s25.shape[3] : s25.shape[1], l12 = "NHWC" === a27 ? u14.shape[3] : u14.shape[1];
        C(c10 === n21[2], function() {
            return "Error in conv2dDerFilter: depth of input " + c10 + ") must match input depth in filter (" + n21[2] + ".";
        }), C(l12 === n21[3], function() {
            return "Error in conv2dDerFilter: depth of dy (" + l12 + ") must match output depth for filter (" + n21[3] + ").";
        }), null != i24 && C(A(o24), function() {
            return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i24 + " but got pad " + o24 + ".";
        });
        var h6 = Bo(a27), f7 = So(s25.shape, n21, r25, 1, o24, i24, !1, h6);
        return Lt.runKernelFunc(function(t9) {
            return t9.conv2dDerFilter(s25, u14, f7);
        }, {
            x4D: s25,
            dy4D: u14
        });
    }
}), Xc = An({
    conv2dDerInput_: Vc
}), Yc = An({
    depthwiseConv2d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === o24 && (o24 = "NHWC"), (void 0) === a27 && (a27 = [
            1,
            1
        ]);
        var s25 = mn(t1, "x", "depthwiseConv2d"), u14 = mn(e15, "filter", "depthwiseConv2d"), c10 = s25, l12 = !1;
        3 === s25.rank && (l12 = !0, c10 = s25.as4D(1, s25.shape[0], s25.shape[1], s25.shape[2])), C(4 === c10.rank, function() {
            return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c10.rank + ".";
        }), C(4 === u14.rank, function() {
            return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u14.rank + ".";
        }), C(c10.shape[3] === u14.shape[2], function() {
            return "Error in depthwiseConv2d: number of input channels (" + c10.shape[3] + ") must match the inChannels dimension in filter " + u14.shape[2] + ".";
        }), null == a27 && (a27 = [
            1,
            1
        ]), C(Mo(n21, a27), function() {
            return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + a27 + "'";
        }), null != i24 && C(A(r25), function() {
            return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i24 + " but got pad " + r25 + ".";
        });
        var h6 = So(c10.shape, u14.shape, n21, a27, r25, i24, !0), f7 = [
            c10,
            u14
        ], d8 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.depthwiseConv2D(c10, u14, h6);
            return e16([
                c10,
                u14
            ]), n23;
        }, {
            x: c10,
            filter: u14
        }, function(t9, e16) {
            C(Oo(a27), function() {
                return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a27 + "'";
            });
            var n23 = e16[0], r28 = e16[1];
            return {
                x: function() {
                    return $c(n23.shape, t9, r28, h6);
                },
                filter: function() {
                    return Qc(n23, t9, r28.shape, h6);
                }
            };
        }, "DepthwiseConv2dNative", h6, f7);
        return l12 ? d8.as3D(d8.shape[1], d8.shape[2], d8.shape[3]) : d8;
    }
}), $c = An({
    depthwiseConv2dDerInput_: function(t1, e15, n21, r25) {
        var o24 = e15, a27 = !1;
        3 === e15.rank && (a27 = !0, o24 = e15.as4D(1, e15.shape[0], e15.shape[1], e15.shape[2]));
        var i24 = Lt.runKernelFunc(function(t9) {
            return t9.depthwiseConv2DDerInput(o24, n21, r25);
        }, {
            dy4D: o24
        });
        return a27 ? i24.as3D(i24.shape[1], i24.shape[2], i24.shape[3]) : i24;
    }
}), Qc = An({
    depthwiseConv2dDerFilter_: function(t1, e15, n21, r25) {
        var o24 = t1;
        3 === t1.rank && (o24 = t1.as4D(1, t1.shape[0], t1.shape[1], t1.shape[2]));
        var a27 = e15;
        return 3 === a27.rank && (a27 = e15.as4D(1, e15.shape[0], e15.shape[1], e15.shape[2])), Lt.runKernelFunc(function(t9) {
            return t9.depthwiseConv2DDerFilter(o24, a27, r25);
        }, {
            x4D: o24,
            dy4D: a27
        });
    }
}), Jc = An({
    separableConv2d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === a27 && (a27 = [
            1,
            1
        ]), (void 0) === i24 && (i24 = "NHWC");
        var s25 = mn(t1, "x", "separableConv2d"), u14 = mn(e15, "depthwiseFilter", "separableConv2d"), c10 = mn(n21, "pointwiseFilter", "separableConv2d"), l12 = s25, h6 = !1;
        if (3 === s25.rank && (h6 = !0, l12 = s25.as4D(1, s25.shape[0], s25.shape[1], s25.shape[2])), "NCHW" === i24) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        C(4 === l12.rank, function() {
            return "Error in separableConv2d: input must be rank 4, but got rank " + l12.rank + ".";
        }), C(4 === u14.rank, function() {
            return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u14.rank + ".";
        }), C(4 === c10.rank, function() {
            return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u14.rank + ".";
        }), C(1 === c10.shape[0], function() {
            return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c10.shape[0] + ".";
        }), C(1 === c10.shape[1], function() {
            return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c10.shape[1] + ".";
        });
        var f7 = u14.shape[2], d8 = u14.shape[3];
        C(c10.shape[2] === f7 * d8, function() {
            return "Error in separableConv2d: the third dimension of pointwise filter must be " + f7 * d8 + ", but got " + c10.shape[2] + ".";
        });
        var p9 = Yc(l12, u14, r25, o24, i24, a27), v11 = qc(p9, c10, 1, "valid", i24);
        return h6 ? v11.as3D(v11.shape[1], v11.shape[2], v11.shape[3]) : v11;
    }
}), Zc = An({
    conv2dTranspose_: function(t1, e15, n21, r25, o24, a27) {
        return Vc(n21, mn(t1, "x", "conv2dTranspose"), mn(e15, "filter", "conv2dTranspose"), r25, o24, "NHWC", a27);
    }
}), tl = An({
    conv3dTranspose_: function(t1, e15, n21, r25, o24) {
        return Gc(n21, mn(t1, "x", "conv3dTranspose"), mn(e15, "filter", "conv3dTranspose"), r25, o24);
    }
});
var el = An({
    matMul_: function(t1, e15, n21, r25) {
        var o24;
        (void 0) === n21 && (n21 = !1), (void 0) === r25 && (r25 = !1);
        var a27 = mn(t1, "a", "matMul"), i24 = mn(e15, "b", "matMul");
        o24 = Nt(a27, i24), a27 = o24[0], i24 = o24[1];
        var s25 = n21 ? a27.shape[a27.rank - 2] : a27.shape[a27.rank - 1], u14 = r25 ? i24.shape[i24.rank - 1] : i24.shape[i24.rank - 2], c10 = n21 ? a27.shape[a27.rank - 1] : a27.shape[a27.rank - 2], l12 = r25 ? i24.shape[i24.rank - 2] : i24.shape[i24.rank - 1], h6 = a27.shape.slice(0, -2), f7 = i24.shape.slice(0, -2), d8 = k(h6), p9 = k(f7);
        C(a27.rank >= 2 && i24.rank >= 2 && a27.rank === i24.rank, function() {
            return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a27.rank + " and " + i24.rank + ".";
        }), C(S(h6, f7), function() {
            return "Error in matMul: outer dimensions (" + h6 + ") and (" + f7 + ") of Tensors with shapes " + a27.shape + " and " + i24.shape + " must match.";
        }), C(s25 === u14, function() {
            return "Error in matMul: inner shapes (" + s25 + ") and (" + u14 + ") of Tensors with shapes " + a27.shape + " and " + i24.shape + " and transposeA=" + n21 + " and transposeB=" + r25 + " must match.";
        });
        var v11 = a27.shape.slice(0, -2).concat([
            c10,
            l12
        ]), m11 = n21 ? a27.as3D(d8, s25, c10) : a27.as3D(d8, c10, s25), g11 = r25 ? i24.as3D(p9, l12, u14) : i24.as3D(p9, u14, l12), y7 = {
            transposeA: n21,
            transposeB: r25
        };
        return Lt.runKernelFunc(function(t9, e16) {
            var o31 = t9.batchMatMul(m11, g11, n21, r25);
            return e16([
                m11,
                g11
            ]), o31;
        }, {
            a: m11,
            b: g11
        }, function(t9, e16) {
            var o31 = e16, a28 = o31[0], i25 = o31[1];
            return n21 || r25 ? !n21 && r25 ? {
                a: function() {
                    return t9.matMul(i25, !1, !1);
                },
                b: function() {
                    return t9.matMul(a28, !0, !1);
                }
            } : n21 && !r25 ? {
                a: function() {
                    return i25.matMul(t9, !1, !0);
                },
                b: function() {
                    return a28.matMul(t9, !1, !1);
                }
            } : {
                a: function() {
                    return i25.matMul(t9, !0, !0);
                },
                b: function() {
                    return t9.matMul(a28, !0, !0);
                }
            } : {
                a: function() {
                    return t9.matMul(i25, !1, !0);
                },
                b: function() {
                    return a28.matMul(t9, !0, !1);
                }
            };
        }, "BatchMatMul", y7).reshape(v11);
    }
}), nl = An({
    dot_: function(t1, e15) {
        var n21 = mn(t1, "t1", "dot"), r25 = mn(e15, "t2", "dot");
        C(!(1 !== n21.rank && 2 !== n21.rank || 1 !== r25.rank && 2 !== r25.rank), function() {
            return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n21.rank + " and " + r25.rank + ".";
        });
        var o24 = 1 === n21.rank ? n21.size : n21.shape[1], a27 = 1 === r25.rank ? r25.size : r25.shape[0];
        return C(o24 === a27, function() {
            return "Error in dot: inner dimensions of inputs must match, but got " + o24 + " and " + a27 + ".";
        }), 1 === n21.rank && 1 === r25.rank ? n21.as2D(1, -1).matMul(r25.as2D(-1, 1)).asScalar() : 1 === n21.rank && 2 === r25.rank ? n21.as2D(1, -1).matMul(r25.as2D(r25.shape[0], r25.shape[1])).as1D() : 2 === n21.rank && 1 === r25.rank ? n21.matMul(r25.as2D(-1, 1)).as1D() : n21.matMul(r25.as2D(r25.shape[0], r25.shape[1]));
    }
}), rl = An({
    outerProduct_: function(t1, e15) {
        var n21 = mn(t1, "v1", "outerProduct"), r25 = mn(e15, "v2", "outerProduct");
        return C(1 === n21.rank && 1 === r25.rank, function() {
            return "Error in outerProduct: inputs must be rank 1, but got ranks " + n21.rank + " and " + r25.rank + ".";
        }), n21.as2D(-1, 1).matMul(r25.as2D(1, -1));
    }
});
var ol = An({
    reverse_: function(t1, e15) {
        var n21 = mn(t1, "x", "reverse");
        if (0 === n21.rank) return n21.clone();
        var r25 = O(e15, n21.shape);
        return Lt.runKernelFunc(function(t9) {
            return t9.reverse(n21, r25);
        }, {
            $x: n21
        }, function(t9) {
            return {
                $x: function() {
                    return t9.reverse(r25);
                }
            };
        }).reshapeAs(n21);
    }
}), al = An({
    reverse1d_: function(t1) {
        var e15 = mn(t1, "x", "reverse");
        return C(1 === e15.rank, function() {
            return "Error in reverse1D: x must be rank 1 but got rank " + e15.rank + ".";
        }), ol(e15, 0);
    }
}), il = An({
    reverse2d_: function(t1, e15) {
        var n21 = mn(t1, "x", "reverse");
        return C(2 === n21.rank, function() {
            return "Error in reverse2D: x must be rank 2 but got rank " + n21.rank + ".";
        }), ol(n21, e15);
    }
}), sl = An({
    reverse3d_: function(t1, e15) {
        var n21 = mn(t1, "x", "reverse");
        return C(3 === n21.rank, function() {
            return "Error in reverse3D: x must be rank 3 but got rank " + n21.rank + ".";
        }), ol(n21, e15);
    }
}), ul = An({
    reverse4d_: function(t1, e15) {
        var n21 = mn(t1, "x", "reverse");
        return C(4 === n21.rank, function() {
            return "Error in reverse4D: x must be rank 4 but got rank " + n21.rank + ".";
        }), ol(n21, e15);
    }
});
function cl(t1, e15, n21, r25, o24, a27) {
    var i24 = mn(t1, "x", "maxPool"), s25 = i24, u14 = !1;
    3 === i24.rank && (u14 = !0, s25 = i24.as4D(1, i24.shape[0], i24.shape[1], i24.shape[2])), null == r25 && (r25 = [
        1,
        1
    ]), C(4 === s25.rank, function() {
        return "Error in maxPool: input must be rank 4 but got rank " + s25.rank + ".";
    }), C(Mo(n21, r25), function() {
        return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + r25 + "'";
    }), null != a27 && C(A(o24), function() {
        return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a27 + " but got pad " + o24 + ".";
    });
    var c10 = Io(s25.shape, e15, n21, r25, o24, a27);
    if (1 === c10.filterWidth && 1 === c10.filterHeight && S(c10.inShape, c10.outShape)) return i24.clone();
    var l12 = [
        s25
    ], h6 = Lt.runKernelFunc(function(t9, e16) {
        var n23 = t9.maxPool(s25, c10);
        return e16([
            s25,
            n23
        ]), n23;
    }, {
        x: s25
    }, function(t9, a28) {
        var i25 = a28[0], s26 = a28[1];
        return {
            x: function() {
                return (function(t10, e16, n23, r28, o31, a29, i26, s28) {
                    var u15 = mn(t10, "dy", "maxPoolBackprop"), c11 = mn(e16, "input", "maxPoolBackprop"), l13 = mn(n23, "output", "maxPoolBackprop");
                    C(c11.rank === u15.rank, function() {
                        return "Rank of input (" + c11.rank + ") does not match rank of dy (" + u15.rank + ")";
                    }), null == a29 && (a29 = [
                        1,
                        1
                    ]);
                    C(Mo(o31, a29), function() {
                        return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o31 + " and dilations '" + a29 + "'";
                    }), C(4 === u15.rank, function() {
                        return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u15.rank + ".";
                    }), C(4 === c11.rank, function() {
                        return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c11.rank + ".";
                    }), null != s28 && C(A(i26), function() {
                        return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s28 + " but got pad " + i26 + ".";
                    });
                    var h7 = Io(c11.shape, r28, o31, a29, i26, s28);
                    return Lt.runKernelFunc(function(t11) {
                        return t11.maxPoolBackprop(u15, c11, l13, h7);
                    }, {
                        $dy: u15,
                        $input: c11
                    });
                })(t9, i25, s26, e15, n21, r25, o24);
            }
        };
    }, "MaxPool", c10, l12);
    return u14 ? h6.as3D(h6.shape[1], h6.shape[2], h6.shape[3]) : h6;
}
function ll(t1, e15, n21, r25, o24, a27) {
    var i24 = mn(t1, "x", "avgPool", "float32");
    null == r25 && (r25 = [
        1,
        1
    ]), C(Mo(n21, r25), function() {
        return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + r25 + "'";
    });
    var s25 = i24, u14 = !1;
    3 === i24.rank && (u14 = !0, s25 = i24.as4D(1, i24.shape[0], i24.shape[1], i24.shape[2])), C(4 === s25.rank, function() {
        return "Error in avgPool: x must be rank 4 but got rank " + s25.rank + ".";
    }), null != a27 && C(A(o24), function() {
        return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a27 + " but got pad " + o24 + ".";
    });
    var c10 = Io(s25.shape, e15, n21, r25, o24, a27);
    if (1 === c10.filterWidth && 1 === c10.filterHeight && S(c10.inShape, c10.outShape)) return i24.clone();
    var l12 = Lt.runKernelFunc(function(t9) {
        return t9.avgPool(s25, c10);
    }, {
        x: s25
    }, function(t9) {
        return {
            x: function() {
                return (function(t10, e16, n23, r28, o31, a28) {
                    var i25 = mn(t10, "dy", "avgPoolBackprop"), s26 = mn(e16, "input", "avgPoolBackprop");
                    C(s26.rank === i25.rank, function() {
                        return "Rank of input (" + s26.rank + ") does not match rank of dy (" + i25.rank + ")";
                    }), null == o31 && (o31 = [
                        1,
                        1
                    ]);
                    C(Mo(r28, o31), function() {
                        return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r28 + " and dilations '" + o31 + "'";
                    });
                    var u15 = s26, c11 = i25, l13 = !1;
                    3 === s26.rank && (l13 = !0, u15 = s26.as4D(1, s26.shape[0], s26.shape[1], s26.shape[2]), c11 = i25.as4D(1, i25.shape[0], i25.shape[1], i25.shape[2]));
                    C(4 === c11.rank, function() {
                        return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c11.rank + ".";
                    }), C(4 === u15.rank, function() {
                        return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u15.rank + ".";
                    });
                    var h6 = Io(u15.shape, n23, r28, o31, a28), f7 = Lt.runKernelFunc(function(t11) {
                        return t11.avgPoolBackprop(c11, u15, h6);
                    }, {
                        dy4D: c11,
                        input4D: u15
                    });
                    if (l13) return f7.as3D(f7.shape[1], f7.shape[2], f7.shape[3]);
                    return f7;
                })(t9, s25, e15, n21, r25, o24);
            }
        };
    }, "AvgPool", c10);
    return l12 = l12.cast(i24.dtype), u14 ? l12.as3D(l12.shape[1], l12.shape[2], l12.shape[3]) : l12;
}
var hl = An({
    maxPool_: function(t1, e15, n21, r25, o24) {
        return cl(t1, e15, n21, 1, r25, o24);
    }
}), fl = An({
    avgPool_: function(t1, e15, n21, r25, o24) {
        return ll(t1, e15, n21, 1, r25, o24);
    }
}), dl = An({
    pool_: function(t1, e15, n21, r25, o24, a27) {
        null == o24 && (o24 = [
            1,
            1
        ]), null == a27 && (a27 = 1), 0 === r25 && (r25 = "valid");
        var i24 = mn(t1, "x", "maxPool"), s25 = i24, u14 = !1;
        3 === i24.rank && (u14 = !0, s25 = i24.as4D(1, i24.shape[0], i24.shape[1], i24.shape[2])), C(Mo(a27, o24), function() {
            return "Error in pool: Either strides or dilations must be 1. Got strides " + a27 + " and dilations '" + o24 + "'";
        });
        var c10, l12 = Io(s25.shape, e15, a27, o24, r25), h6 = [
            l12.dilationHeight,
            l12.dilationWidth
        ];
        c10 = "same" === r25 ? (function(t9, e16) {
            var n23 = t9.map(function(t10, n24) {
                return t10 + (t10 - 1) * (e16[n24] - 1);
            }).map(function(t10) {
                return t10 - 1;
            }), r28 = n23.map(function(t10) {
                return Math.floor(t10 / 2);
            }), o31 = n23.map(function(t10, e17) {
                return t10 - r28[e17];
            });
            return n23.map(function(t10, e17) {
                return [
                    r28[e17],
                    o31[e17]
                ];
            });
        })([
            l12.filterHeight,
            l12.filterWidth
        ], h6) : [
            [
                0,
                0
            ],
            [
                0,
                0
            ]
        ];
        var f7 = 1 === h6[0] && 1 === h6[1], d8 = function(t9, e16, n23) {
            var r28 = n23.map(function(t10) {
                return t10[0];
            }), o31 = n23.map(function(t10) {
                return t10[1];
            }), a28 = t9.concat(r28, o31), i25 = e16.map(function(t10, e17) {
                return (t10 - a28[e17] % t10) % t10;
            }), s26 = o31.map(function(t10, e17) {
                return t10 + i25[e17];
            }), u15 = e16.map(function(t10, e17) {
                return [
                    r28[e17],
                    s26[e17]
                ];
            }), c11 = e16.map(function(t10, e17) {
                return [
                    0,
                    i25[e17]
                ];
            });
            return [
                u15,
                c11
            ];
        }([
            l12.inHeight,
            l12.inWidth
        ], h6, c10), p9 = d8[0], v11 = d8[1], m11 = f7 ? r25 : "valid", g11 = f7 ? s25 : Mr(s25, h6, p9), y7 = ("avg" === n21 ? function() {
            return ll(g11, e15, a27, 1, m11);
        } : function() {
            return cl(g11, e15, a27, 1, m11);
        })(), x7 = f7 ? y7 : vr(y7, h6, v11);
        return u14 ? x7.as3D(x7.shape[1], x7.shape[2], x7.shape[3]) : x7;
    }
}), pl = An({
    maxPool3d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === a27 && (a27 = "NDHWC");
        var s25 = mn(t1, "x", "maxPool3d"), u14 = s25, c10 = !1;
        4 === s25.rank && (c10 = !0, u14 = s25.as5D(1, s25.shape[0], s25.shape[1], s25.shape[2], s25.shape[3])), null == i24 && (i24 = [
            1,
            1,
            1
        ]), C(5 === u14.rank, function() {
            return "Error in maxPool3d: x must be rank 5 but got rank " + u14.rank + ".";
        }), C("NDHWC" === a27, function() {
            return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a27;
        }), C(Mo(n21, i24), function() {
            return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + i24 + "'";
        }), null != o24 && C(A(r25), function() {
            return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o24 + " but got pad " + r25 + ".";
        });
        var l12 = ko(u14.shape, e15, n21, i24, r25, o24, a27), h6 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.maxPool3d(u14, l12);
            return e16([
                u14,
                n23
            ]), n23;
        }, {
            x: u14
        }, function(t9, a28) {
            var s26 = a28[0], u15 = a28[1];
            return {
                x: function() {
                    return (function(t10, e16, n23, r28, o31, a29, i25, s28) {
                        var u16 = mn(t10, "dy", "maxPool3dBackprop"), c11 = mn(e16, "input", "maxPool3dBackprop"), l13 = mn(n23, "output", "maxPool3dBackprop"), h7 = u16, f7 = c11, d8 = l13, p9 = !1;
                        4 === c11.rank && (p9 = !0, h7 = u16.as5D(1, u16.shape[0], u16.shape[1], u16.shape[2], u16.shape[3]), f7 = c11.as5D(1, c11.shape[0], c11.shape[1], c11.shape[2], c11.shape[3]), d8 = l13.as5D(1, l13.shape[0], l13.shape[1], l13.shape[2], l13.shape[3]));
                        C(5 === h7.rank, function() {
                            return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h7.rank + ".";
                        }), C(5 === f7.rank, function() {
                            return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f7.rank + ".";
                        }), C(5 === d8.rank, function() {
                            return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + d8.rank + ".";
                        }), null == a29 && (a29 = [
                            1,
                            1,
                            1
                        ]);
                        C(Mo(o31, a29), function() {
                            return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o31 + " and dilations '" + a29 + "'";
                        }), null != s28 && C(A(i25), function() {
                            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s28 + " but got pad " + i25 + ".";
                        });
                        var v11 = ko(f7.shape, r28, o31, a29, i25, s28), m11 = Lt.runKernelFunc(function(t11) {
                            return t11.maxPool3dBackprop(h7, f7, d8, v11);
                        }, {
                            dy5D: h7,
                            input5D: f7
                        });
                        if (p9) return m11.as4D(m11.shape[1], m11.shape[2], m11.shape[3], m11.shape[4]);
                        return m11;
                    })(t9, s26, u15, e15, n21, i24, r25, o24);
                }
            };
        });
        return c10 ? h6.as4D(h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]) : h6;
    }
}), vl = An({
    avgPool3d_: function(t1, e15, n21, r25, o24, a27, i24) {
        (void 0) === a27 && (a27 = "NDHWC");
        var s25 = mn(t1, "x", "avgPool3d", "float32"), u14 = s25, c10 = !1;
        4 === s25.rank && (c10 = !0, u14 = s25.as5D(1, s25.shape[0], s25.shape[1], s25.shape[2], s25.shape[3])), null == i24 && (i24 = [
            1,
            1,
            1
        ]), C(5 === u14.rank, function() {
            return "Error in avgPool3d: x must be rank 5 but got rank " + u14.rank + ".";
        }), C("NDHWC" === a27, function() {
            return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a27;
        }), C(Mo(n21, i24), function() {
            return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n21 + " and dilations '" + i24 + "'";
        }), null != o24 && C(A(r25), function() {
            return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o24 + " but got pad " + r25 + ".";
        });
        var l12 = ko(u14.shape, e15, n21, i24, r25, o24, a27), h6 = Lt.runKernelFunc(function(t9) {
            return t9.avgPool3d(u14, l12);
        }, {
            x: u14
        }, function(t9) {
            return {
                x: function() {
                    return (function(t10, e16, n23, r28, o31, a28, i25) {
                        var s26 = mn(t10, "dy", "avgPool3dBackprop"), u15 = mn(e16, "input", "avgPool3dBackprop"), c11 = s26, l13 = u15, h7 = !1;
                        4 === u15.rank && (h7 = !0, c11 = s26.as5D(1, s26.shape[0], s26.shape[1], s26.shape[2], s26.shape[3]), l13 = u15.as5D(1, u15.shape[0], u15.shape[1], u15.shape[2], u15.shape[3]));
                        C(5 === c11.rank, function() {
                            return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c11.rank + ".";
                        }), C(5 === l13.rank, function() {
                            return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l13.rank + ".";
                        }), null == o31 && (o31 = [
                            1,
                            1,
                            1
                        ]);
                        C(Mo(r28, o31), function() {
                            return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r28 + " and dilations '" + o31 + "'";
                        }), null != i25 && C(A(a28), function() {
                            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i25 + " but got pad " + a28 + ".";
                        });
                        var f7 = ko(l13.shape, n23, r28, o31, a28, i25), d8 = Lt.runKernelFunc(function(t11) {
                            return t11.avgPool3dBackprop(c11, l13, f7);
                        }, {
                            dy5D: c11,
                            input5D: l13
                        });
                        if (h7) return d8.as4D(d8.shape[1], d8.shape[2], d8.shape[3], d8.shape[4]);
                        return d8;
                    })(t9, u14, e15, n21, i24, r25, o24);
                }
            };
        });
        return h6 = h6.cast(u14.dtype), c10 ? h6.as4D(h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]) : h6;
    }
});
var ml = An({
    slice_: function(t1, e15, n21) {
        var r25, o24, a27 = mn(t1, "x", "slice");
        if (0 === a27.rank) throw new Error("Slicing scalar is not possible");
        (r25 = "number" == typeof e15 ? [
            e15
        ].concat(new Array(a27.rank - 1).fill(0)) : e15.length < a27.rank ? e15.concat(new Array(a27.rank - e15.length).fill(0)) : e15.slice()).forEach(function(t9) {
            C(-1 !== t9, function() {
                return "slice() does not support negative begin indexing.";
            });
        }), o24 = (o24 = null == n21 ? new Array(a27.rank).fill(-1) : "number" == typeof n21 ? [
            n21
        ].concat(new Array(a27.rank - 1).fill(-1)) : n21.length < a27.rank ? n21.concat(new Array(a27.rank - n21.length).fill(-1)) : n21).map(function(t9, e16) {
            return t9 >= 0 ? t9 : (C(-1 === t9, function() {
                return "Negative size values should be exactly -1 but got " + t9 + " for the slice() size at index " + e16 + ".";
            }), a27.shape[e16] - r25[e16]);
        }), eo(a27, r25, o24);
        var i24 = a27.shape, s25 = {
            begin: r25,
            size: o24
        };
        return Lt.runKernelFunc(function(t9) {
            return t9.slice(a27, r25, o24);
        }, {
            x: a27
        }, function(t9) {
            for(var e16 = [], n23 = 0; n23 < t9.rank; n23++)e16.push([
                r25[n23],
                i24[n23] - r25[n23] - o24[n23]
            ]);
            return {
                x: function() {
                    return t9.pad(e16);
                }
            };
        }, "Slice", s25);
    }
}), gl = An({
    slice1d_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "slice1d");
        return C(1 === r25.rank, function() {
            return "slice1d expects a rank-1 tensor, but got a rank-" + r25.rank + " tensor";
        }), ml(r25, [
            e15
        ], [
            n21
        ]);
    }
}), yl = An({
    slice2d_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "slice2d");
        return C(2 === r25.rank, function() {
            return "slice2d expects a rank-2 tensor, but got a rank-" + r25.rank + " tensor";
        }), ml(r25, e15, n21);
    }
}), xl = An({
    slice3d_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "slice3d");
        return C(3 === r25.rank, function() {
            return "slice3d expects a rank-3 tensor, but got a rank-" + r25.rank + " tensor";
        }), ml(r25, e15, n21);
    }
}), bl = An({
    slice4d_: function(t1, e15, n21) {
        var r25 = mn(t1, "x", "slice4d");
        return C(4 === r25.rank, function() {
            return "slice4d expects a rank-4 tensor, but got a rank-" + r25.rank + " tensor";
        }), ml(r25, e15, n21);
    }
});
function wl(t1, e15, n21, r25, o24) {
    return e15.rank < n21.rank && (e15 = e15.reshape(wn(e15.shape, r25))), t1.rank < n21.rank && (t1 = t1.reshape(wn(t1.shape, r25))), {
        x: function() {
            var r28 = t1.mul(n21.equal(e15).cast(t1.dtype));
            return null == o24 ? r28 : r28.transpose(o24);
        }
    };
}
var Cl = An({
    all_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "all", "bool"), o24 = O(e15, r25.shape), a27 = o24, i24 = En(a27, r25.rank);
        null != i24 && (r25 = r25.transpose(i24), a27 = In(a27.length, r25.rank));
        var s25 = Lt.runKernelFunc(function(t9) {
            return t9.all(r25, a27);
        }, {
            $x: r25
        });
        if (n21) {
            var u14 = wn(s25.shape, o24);
            return s25.reshape(u14);
        }
        return s25;
    }
}), El = An({
    any_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "any", "bool"), o24 = O(e15, r25.shape), a27 = o24, i24 = En(a27, r25.rank);
        null != i24 && (r25 = r25.transpose(i24), a27 = In(a27.length, r25.rank));
        var s25 = Lt.runKernelFunc(function(t9) {
            return t9.any(r25, a27);
        }, {
            $x: r25
        });
        if (n21) {
            var u15 = wn(s25.shape, o24);
            return s25.reshape(u15);
        }
        return s25;
    }
}), Rl = An({
    argMax_: function(t1, e15) {
        (void 0) === e15 && (e15 = 0);
        var n21 = mn(t1, "x", "argMax");
        null == e15 && (e15 = 0);
        var r25 = O(e15, n21.shape), o24 = En(r25, n21.rank);
        null != o24 && (n21 = n21.transpose(o24), r25 = In(r25.length, n21.rank));
        var a27 = {
            axis: r25[0]
        }, i24 = [
            n21
        ];
        return Lt.runKernelFunc(function(t9, e16) {
            var o31 = t9.argMax(n21, r25[0]);
            return e16([
                n21
            ]), o31;
        }, {
            x: n21
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                x: function() {
                    return Xn(n23);
                }
            };
        }, "ArgMax", a27, i24);
    }
}), Il = An({
    argMin_: function(t1, e15) {
        (void 0) === e15 && (e15 = 0);
        var n21 = mn(t1, "x", "argMin");
        null == e15 && (e15 = 0);
        var r25 = O(e15, n21.shape), o24 = En(r25, n21.rank);
        return null != o24 && (n21 = n21.transpose(o24), r25 = In(r25.length, n21.rank)), Lt.runKernelFunc(function(t9, e16) {
            var o31 = t9.argMin(n21, r25[0]);
            return e16([
                n21
            ]), o31;
        }, {
            $x: n21
        }, function(t9, e16) {
            var n23 = e16[0];
            return {
                $x: function() {
                    return Xn(n23);
                }
            };
        });
    }
}), kl = An({
    logSumExp_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "logSumExp"), o24 = O(e15, r25.shape), a27 = r25.max(o24, !0), i24 = r25.sub(a27).exp().sum(o24).log(), s25 = a27.reshape(i24.shape).add(i24);
        if (n21) {
            var u16 = wn(s25.shape, o24);
            return s25.reshape(u16);
        }
        return s25;
    }
}), Sl = An({
    max_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "max"), o24 = r25, a27 = O(e15, r25.shape), i24 = a27, s25 = En(i24, r25.rank);
        null != s25 && (r25 = r25.transpose(s25), i24 = In(i24.length, r25.rank));
        var u17 = [
            r25
        ], c10 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.max(r25, i24);
            return e16([
                o24,
                n23
            ]), n23;
        }, {
            x: r25
        }, function(t9, e16) {
            return wl(t9, e16[1], e16[0], a27, s25);
        }, "Max", {
            axes: i24
        }, u17, [
            !0
        ]);
        if (n21) {
            var l12 = wn(c10.shape, a27);
            c10 = c10.reshape(l12);
        }
        return c10;
    }
}), Al = An({
    mean_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "mean"), o24 = O(e15, r25.shape), a27 = k(bn(r25.shape, o24)[1]);
        return vo(function(t9) {
            var r28 = On(a27);
            return {
                value: (r28.dtype === t9.dtype ? t9 : t9.cast(r28.dtype)).div(r28).sum(e15, n21),
                gradFunc: function(e16) {
                    var n23 = t9.shape.slice();
                    return o24.forEach(function(t10) {
                        n23[t10] = 1;
                    }), e16.reshape(n23).mul(zn(t9.shape, "float32")).div(a27);
                }
            };
        })(r25);
    }
}), Dl = An({
    min_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "min"), o24 = r25, a27 = O(e15, r25.shape), i24 = a27, s25 = En(i24, r25.rank);
        null != s25 && (r25 = r25.transpose(s25), i24 = In(i24.length, r25.rank));
        var u17 = [
            r25
        ], c10 = Lt.runKernelFunc(function(t9, e16) {
            var n23 = t9.min(r25, i24);
            return e16([
                o24,
                n23
            ]), n23;
        }, {
            x: r25
        }, function(t9, e16) {
            return wl(t9, e16[1], e16[0], a27, s25);
        }, "Min", {
            axes: i24
        }, u17, [
            !0
        ]);
        if (n21) {
            var l13 = wn(c10.shape, a27);
            c10 = c10.reshape(l13);
        }
        return c10;
    }
}), Tl = An({
    moments_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = O(e15, (t1 = mn(t1, "x", "moments")).shape), o24 = t1.mean(r25, n21), a27 = o24.shape;
        n21 || (a27 = wn(o24.shape, r25));
        var i24 = t1.toFloat().sub(o24.reshape(a27)).square();
        return {
            mean: o24,
            variance: i24.mean(r25, n21)
        };
    }
}), Nl = An({
    sum_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "sum");
        "bool" === r25.dtype && (r25 = r25.toInt());
        var o24 = O(e15, r25.shape);
        return vo(function(t9) {
            var e16 = En(o24, t9.rank), r28 = o24, a27 = t9;
            null != e16 && (a27 = t9.transpose(e16), r28 = In(r28.length, t9.rank));
            var i24 = function(e17) {
                var n23 = t9.shape.slice();
                return o24.forEach(function(t10) {
                    n23[t10] = 1;
                }), e17.reshape(n23).mul(zn(t9.shape, "float32"));
            }, s25 = {
                axes: r28
            }, u17 = Lt.runKernelFunc(function(t10) {
                return t10.sum(a27, r28);
            }, {
                x: a27
            }, function(t10) {
                return {
                    x: function() {
                        return i24(t10);
                    }
                };
            }, "Sum", s25);
            if (n21) {
                var c10 = wn(u17.shape, o24);
                u17 = u17.reshape(c10);
            }
            return {
                value: u17,
                gradFunc: i24
            };
        })(r25);
    }
}), Fl = An({
    prod_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = null), (void 0) === n21 && (n21 = !1);
        var r25 = mn(t1, "x", "prod");
        "bool" === r25.dtype && (r25 = r25.toInt());
        var o24 = O(e15, r25.shape), a27 = En(o24, r25.rank), i24 = o24, s25 = r25;
        null != a27 && (s25 = r25.transpose(a27), i24 = In(i24.length, r25.rank));
        var u17 = Lt.runKernelFunc(function(t9) {
            return t9.prod(s25, i24);
        }, {
            permutedX: s25
        });
        if (n21) {
            var c11 = wn(u17.shape, o24);
            u17 = u17.reshape(c11);
        }
        return u17;
    }
});
var _l = An({
    elu_: function(t1) {
        var e15 = mn(t1, "x", "elu");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.elu(e15);
            return n21([
                r25
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    return Lt.runKernelFunc(function(e17) {
                        return e17.eluDer(t9, n21);
                    }, {
                        dy: t9,
                        y: n21
                    });
                }
            };
        });
    }
}), Ol = An({
    leakyRelu_: function(t1, e15) {
        (void 0) === e15 && (e15 = 0.2);
        var n21 = mn(t1, "x", "leakyRelu");
        return hc(On(e15).mul(n21), n21);
    }
}), Ml = An({
    prelu_: function(t1, e15) {
        var n21 = mn(t1, "x", "prelu"), r25 = mn(e15, "alpha", "prelu");
        return Lt.runKernelFunc(function(t9, e16) {
            var o24 = t9.prelu(n21, r25);
            return e16([
                n21,
                r25
            ]), o24;
        }, {
            x: n21,
            alpha: r25
        }, function(t9, e16) {
            var n23 = e16[0], r28 = e16[1], o24 = n23.greater(0);
            return {
                x: function() {
                    return ec(o24, t9, t9.mul(r28));
                },
                alpha: function() {
                    var e17 = ec(o24, Xn(t9), t9.mul(n23)), a27 = Eo(r28.shape, t9.shape);
                    return a27.length > 0 && (e17 = e17.sum(a27)), e17.reshape(r28.shape);
                }
            };
        }, "Prelu");
    }
}), Bl = An({
    relu_: function(t1) {
        var e15 = mn(t1, "x", "relu");
        return "bool" === e15.dtype ? e15.toInt() : Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.relu(e15);
            return n21([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                x: function() {
                    return t9.mulStrict(n21.step().toFloat());
                }
            };
        }, "Relu");
    }
}), Pl = An({
    relu6_: function(t1) {
        var e15 = mn(t1, "x", "relu6");
        return "bool" === e15.dtype ? e15.toInt() : Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.relu6(e15);
            return n21([
                e15
            ]), r25;
        }, {
            x: e15
        }, function(t9, e16) {
            var n21 = e16[0], r25 = n21.lessEqual(6).mul(n21.step());
            return {
                x: function() {
                    return t9.mulStrict(r25.toFloat());
                }
            };
        }, "Relu6");
    }
}), Ll = An({
    selu_: function(t1) {
        var e15 = mn(t1, "x", "selu");
        return Lt.runKernelFunc(function(t9, n21) {
            var r25 = t9.selu(e15);
            return n21([
                e15
            ]), r25;
        }, {
            $x: e15
        }, function(t9, e16) {
            var n21 = e16[0];
            return {
                $x: function() {
                    var e17 = n21.greater(On(0)), r25 = On(bs), o24 = On(ws), a27 = t9.mul(o24), i24 = t9.mul(r25).mul(n21.toFloat().exp());
                    return ec(e17, a27, i24);
                }
            };
        });
    }
});
var Wl = An({
    transpose_: function(t1, e15) {
        var n21 = mn(t1, "x", "transpose");
        if (null == e15 && (e15 = n21.shape.map(function(t9, e16) {
            return e16;
        }).reverse()), C(n21.rank === e15.length, function() {
            return "Error in transpose: rank of input " + n21.rank + " must match length of perm " + e15 + ".";
        }), e15.forEach(function(t9) {
            C(t9 >= 0 && t9 < n21.rank, function() {
                return "All entries in 'perm' must be between 0 and " + (n21.rank - 1) + " but got " + e15;
            });
        }), n21.rank <= 1) return n21.clone();
        var r25 = {
            perm: e15
        };
        return Lt.runKernelFunc(function(t9) {
            return t9.transpose(n21, e15);
        }, {
            x: n21
        }, function(t9) {
            var n23 = Rn(e15);
            return {
                x: function() {
                    return t9.transpose(n23);
                }
            };
        }, "Transpose", r25);
    }
});
var Ul = An({
    localResponseNormalization_: function(t1, e15, n21, r25, o24) {
        (void 0) === e15 && (e15 = 5), (void 0) === n21 && (n21 = 1), (void 0) === r25 && (r25 = 1), (void 0) === o24 && (o24 = 0.5);
        var a27 = mn(t1, "x", "localResponseNormalization");
        C(4 === a27.rank || 3 === a27.rank, function() {
            return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a27.rank + ".";
        }), C(A(e15), function() {
            return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e15 + ".";
        });
        var i24 = a27, s25 = !1;
        3 === a27.rank && (s25 = !0, i24 = a27.as4D(1, a27.shape[0], a27.shape[1], a27.shape[2]));
        var u17 = Lt.runKernelFunc(function(t9, a28) {
            var s26 = t9.localResponseNormalization4D(i24, e15, n21, r25, o24);
            return a28([
                i24,
                s26
            ]), s26;
        }, {
            x4D: i24
        }, function(t9, a28) {
            var i25 = a28[0], s26 = a28[1];
            return {
                x4D: function() {
                    return Lt.runKernelFunc(function(a29) {
                        return a29.LRNGrad(t9, i25, s26, e15, n21, r25, o24);
                    }, {
                    });
                }
            };
        });
        return s25 ? u17.as3D(u17.shape[1], u17.shape[2], u17.shape[3]) : u17;
    }
});
var Vl = An({
    norm_: function(t1, e15, n21, r25) {
        (void 0) === e15 && (e15 = "euclidean"), (void 0) === n21 && (n21 = null), (void 0) === r25 && (r25 = !1);
        var o24 = function t9(e16, n23, r28) {
            (void 0) === r28 && (r28 = null);
            if (0 === e16.rank) return e16.abs();
            if (1 !== e16.rank && null === r28) return t9(e16.reshape([
                -1
            ]), n23, r28);
            if (1 === e16.rank || "number" == typeof r28 || Array.isArray(r28) && 1 === r28.length) {
                if (1 === n23) return e16.abs().sum(r28);
                if (n23 === 1 / 0) return e16.abs().max(r28);
                if (n23 === -1 / 0) return e16.abs().min(r28);
                if ("euclidean" === n23 || 2 === n23) return e16.abs().pow(On(2, "int32")).sum(r28).sqrt();
                throw new Error("Error in norm: invalid ord value: " + n23);
            }
            if (Array.isArray(r28) && 2 === r28.length) {
                if (1 === n23) return e16.abs().sum(r28[0]).max(r28[1] - 1);
                if (n23 === 1 / 0) return e16.abs().sum(r28[1]).max(r28[0]);
                if (n23 === -1 / 0) return e16.abs().sum(r28[1]).min(r28[0]);
                if ("fro" === n23 || "euclidean" === n23) return e16.square().sum(r28).sqrt();
                throw new Error("Error in norm: invalid ord value: " + n23);
            }
            throw new Error("Error in norm: invalid axis: " + r28);
        }(t1 = mn(t1, "x", "norm"), e15, n21), a27 = o24.shape;
        if (r25) {
            var i24 = O(n21, t1.shape);
            a27 = wn(o24.shape, i24);
        }
        return o24.reshape(a27);
    }
});
var zl = An({
    basicLSTMCell_: function(t1, e15, n21, r25, o24, a27) {
        var i25 = mn(t1, "forgetBias", "basicLSTMCell"), s25 = mn(e15, "lstmKernel", "basicLSTMCell"), u17 = mn(n21, "lstmBias", "basicLSTMCell"), c12 = mn(r25, "data", "basicLSTMCell"), l14 = mn(o24, "c", "basicLSTMCell"), h6 = mn(a27, "h", "basicLSTMCell"), f7 = c12.concat(h6, 1).matMul(s25).add(u17), d8 = f7.shape[0], p9 = f7.shape[1] / 4, v11 = [
            d8,
            p9
        ], m11 = f7.slice([
            0,
            0
        ], v11), g11 = f7.slice([
            0,
            p9
        ], v11), y7 = f7.slice([
            0,
            2 * p9
        ], v11), x7 = f7.slice([
            0,
            3 * p9
        ], v11), b4 = m11.sigmoid().mulStrict(g11.tanh()).addStrict(l14.mulStrict(i25.add(y7).sigmoid())), w3 = b4.tanh().mulStrict(x7.sigmoid());
        return [
            b4,
            w3
        ];
    }
}), Gl = An({
    multiRNNCell_: function(t1, e15, n21, r25) {
        for(var o24 = mn(e15, "data", "multiRNNCell"), a27 = gn(n21, "c", "multiRNNCell"), i25 = gn(r25, "h", "multiRNNCell"), s25 = o24, u17 = [], c12 = 0; c12 < t1.length; c12++){
            var l14 = t1[c12](s25, a27[c12], i25[c12]);
            u17.push(l14[0]), u17.push(l14[1]), s25 = l14[1];
        }
        var h6 = [], f7 = [];
        for(c12 = 0; c12 < u17.length; c12 += 2)h6.push(u17[c12]), f7.push(u17[c12 + 1]);
        return [
            h6,
            f7
        ];
    }
});
var Hl = An({
    movingAverage_: function(t1, e15, n21, r25, o24) {
        (void 0) === o24 && (o24 = !0);
        var a27 = mn(t1, "v", "movingAverage"), i25 = mn(e15, "x", "movingAverage"), s25 = mn(n21, "decay", "movingAverage");
        Ft(a27, i25), C(S(a27.shape, i25.shape), function() {
            return "Shape mismatch in v and x";
        });
        var u17 = On(1), c12 = u17.sub(s25), l15 = i25.sub(a27).mul(c12);
        if (o24) {
            C(null != r25, function() {
                return "When using zeroDebias: true, step is required.";
            });
            var h6 = mn(r25, "step", "movingAverage");
            l15 = l15.div(u17.sub(xc(s25, h6)));
        }
        return a27.add(l15);
    }
});
var ql = An({
    stridedSlice_: function(t1, e15, n21, r25, o24, a27, i25, s25, u17) {
        if ((void 0) === o24 && (o24 = 0), (void 0) === a27 && (a27 = 0), (void 0) === i25 && (i25 = 0), (void 0) === s25 && (s25 = 0), (void 0) === u17 && (u17 = 0), null == r25 && (r25 = new Array(e15.length)), 0 !== i25) throw new Error("ellipsis mask is not yet supported");
        var c12 = mn(t1, "x", "stridedSlice"), l15 = no(s25), h7 = c12.shape.slice();
        l15.forEach(function(t9) {
            e15[t9] = 0, n21[t9] = 1, h7.splice(t9, 0, 1);
        }), c12 = c12.reshape(h7);
        for(var f7 = 0; f7 < c12.rank; f7++)e15[f7] = oo(o24, e15, r25, c12.shape, f7), n21[f7] = ao(a27, n21, r25, c12.shape, f7), r25[f7] = r25[f7] || 1;
        var d8 = no(u17);
        d8.forEach(function(t9) {
            n21[t9] = e15[t9] + 1, r25[t9] = 1;
        });
        var p9 = ro(e15, n21, r25), v11 = p9.filter(function(t9, e16) {
            return -1 === d8.indexOf(e16);
        });
        return r25.every(function(t9) {
            return 1 === t9;
        }) ? ml(c12, e15, p9).reshape(v11) : Lt.runKernelFunc(function(t9) {
            return t9.stridedSlice(c12, e15, n21, r25);
        }, {
            $x: c12
        }).reshape(v11);
    }
});
var Kl = An({
    topk_: function(t1, e15, n21) {
        (void 0) === e15 && (e15 = 1), (void 0) === n21 && (n21 = !0);
        var r25 = mn(t1, "x", "topk");
        if (0 === r25.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
        var o24 = r25.shape[r25.shape.length - 1];
        if (e15 > o24) throw new Error("'k' passed to topk() must be <= the last dimension (" + o24 + ") but got " + e15);
        var a27 = Lt.runKernelFunc(function(t9) {
            return t9.topk(r25, e15, n21);
        }, {
            $x: r25
        });
        return {
            values: a27[0],
            indices: a27[1]
        };
    }
});
var jl = An({
    scatterND_: function(t1, e15, n21) {
        var r25 = mn(t1, "indices", "scatterND", "int32"), o24 = mn(e15, "updates", "scatterND");
        return Jr(o24, r25, n21), Lt.runKernelFunc(function(t9) {
            return t9.scatterND(r25, o24, n21);
        }, {
            indices: r25,
            updates: o24
        }, null, "ScatterNd", {
            shape: n21
        });
    }
});
var Xl = An({
    fft_: function(t1) {
        C("complex64" === t1.dtype, function() {
            return "The dtype for tf.spectral.fft() must be complex64 but got " + t1.dtype + ".";
        });
        var e15 = t1.shape[t1.shape.length - 1], n21 = t1.size / e15, r25 = t1.as2D(n21, e15);
        return Lt.runKernelFunc(function(t9) {
            return t9.fft(r25);
        }, {
            input: t1
        }).reshape(t1.shape);
    }
}), Yl = An({
    ifft_: function(t1) {
        C("complex64" === t1.dtype, function() {
            return "The dtype for tf.spectral.ifft() must be complex64 but got " + t1.dtype + ".";
        });
        var e15 = t1.shape[t1.shape.length - 1], n21 = t1.size / e15, r25 = t1.as2D(n21, e15);
        return Lt.runKernelFunc(function(t9) {
            return t9.ifft(r25);
        }, {
            input: t1
        }).reshape(t1.shape);
    }
}), $l = An({
    rfft_: function(t1, e15) {
        C("float32" === t1.dtype, function() {
            return "The dtype for rfft() must be real value but got " + t1.dtype;
        });
        var n21, r25 = t1.shape[t1.shape.length - 1], o24 = t1.size / r25;
        if (null != e15 && e15 < r25) {
            var a27 = t1.shape.map(function(t9) {
                return 0;
            }), i25 = t1.shape.map(function(t9) {
                return t9;
            });
            i25[t1.shape.length - 1] = e15, n21 = t1.slice(a27, i25), r25 = e15;
        } else if (null != e15 && e15 > r25) {
            var s25 = t1.shape.map(function(t9) {
                return t9;
            });
            s25[t1.shape.length - 1] = e15 - r25, n21 = t1.concat(Gn(s25), t1.shape.length - 1), r25 = e15;
        } else n21 = t1;
        var u17 = n21.zerosLike(), c12 = Dn(n21, u17).as2D(o24, r25), l15 = Xl(c12), h7 = Math.floor(r25 / 2) + 1, f7 = Tn(l15), d8 = Nn(l15), p9 = f7.split([
            h7,
            r25 - h7
        ], f7.shape.length - 1), v11 = d8.split([
            h7,
            r25 - h7
        ], d8.shape.length - 1), m11 = n21.shape.slice();
        return m11[n21.shape.length - 1] = h7, Dn(p9[0], v11[0]).reshape(m11);
    }
}), Ql = An({
    irfft_: function(t1) {
        var e15 = t1.shape[t1.shape.length - 1], n21 = t1.size / e15;
        if (e15 <= 2) {
            var r25 = t1.as2D(n21, e15), o24 = Yl(r25);
            return Tn(o24);
        }
        var a28 = [
            n21,
            2 * (e15 - 1)
        ], i26 = Tn(t1).as2D(n21, e15), s26 = Nn(t1).as2D(n21, e15), u17 = i26.slice([
            0,
            1
        ], [
            n21,
            e15 - 2
        ]).reverse(1), c12 = s26.slice([
            0,
            1
        ], [
            n21,
            e15 - 2
        ]).reverse(1).mul(On(-1)), l15 = i26.concat(u17, 1), h7 = s26.concat(c12, 1);
        return r25 = Dn(l15, h7).as2D(a28[0], a28[1]), o24 = Yl(r25), Tn(o24);
    }
}), Jl = Object.freeze({
    fft: Xl,
    ifft: Yl,
    rfft: $l,
    irfft: Ql
});
var Zl = An({
    sparseToDense_: function(t1, e15, n21, r28) {
        (void 0) === r28 && (r28 = 0);
        var o31 = mn(t1, "sparseIndices", "sparseToDense", "int32"), a28 = mn(e15, "sparseValues", "sparseToDense"), i26 = mn(r28, "defaultValue", "sparseToDense", a28.dtype);
        return (function(t9, e16, n23, r29) {
            if ("int32" !== t9.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t9.dtype + ".");
            if (t9.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t9.shape + ".");
            var o32 = t9.rank > 0 ? t9.shape[0] : 1, a29 = t9.rank > 1 ? t9.shape[1] : 1;
            if (n23.length !== a29) throw new Error("outputShape has incorrect number of elements:, " + n23.length + ", should be: " + a29 + ".");
            var i27 = e16.size;
            if (0 !== e16.rank && (1 !== e16.rank || i27 !== o32)) throw new Error("sparseValues has incorrect shape " + e16.shape + ", should be [] or [" + o32 + "]");
            if (e16.dtype !== r29.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
        })(o31, a28, n21, i26), Lt.runKernelFunc(function(t9) {
            return t9.sparseToDense(o31, a28, n21, i26);
        }, {
            $sparseIndices: o31,
            $sparseValues: a28,
            $defaultValue: i26
        });
    }
});
var th = An({
    gatherND_: function(t1, e15) {
        var n21 = mn(e15, "indices", "gatherND", "int32"), r28 = mn(t1, "x", "gatherND");
        return Lt.runKernelFunc(function(t9) {
            return t9.gatherND(r28, n21);
        }, {
            x: r28,
            indices: n21
        }, null, "GatherNd");
    }
});
var eh = An({
    diag_: function(t1) {
        var e15 = mn(t1, "x", "diag").flatten(), n21 = t1.shape.concat(t1.shape);
        return Lt.runKernelFunc(function(t9) {
            return t9.diag(e15);
        }, {
            $x: e15
        }).reshape(n21);
    }
});
var nh = An({
    dropout_: function(t1, e15, n21, r28) {
        var o31 = mn(t1, "x", "dropout");
        if (C("float32" === o31.dtype, function() {
            return "x has to be a floating point tensor since it's going to be scaled, but got a " + o31.dtype + " tensor instead.";
        }), C(e15 >= 0 && e15 < 1, function() {
            return "rate must be a float in the range [0, 1), but got " + e15 + ".";
        }), 0 === e15) return t1 instanceof wt ? o31.clone() : o31;
        var a28 = function(t9, e16) {
            if (null == e16) return t9.shape.slice();
            if (S(t9.shape, e16)) return e16;
            if (t9.shape.length === e16.length) {
                for(var n23 = [], r29 = 0; r29 < t9.shape.length; r29++)null == e16[r29] && null != t9.shape[r29] ? n23.push(t9.shape[r29]) : n23.push(e16[r29]);
                return n23;
            }
            return e16;
        }(o31, n21), i26 = 1 - e15, s26 = _r(a28, 0, 1, "float32", r28).add(i26).floor().div(i26);
        return o31.mul(s26);
    }
});
function rh(t1, e15, n21) {
    for(var r28 = 1 - t1 % 2, o31 = new Float32Array(t1), a28 = 0; a28 < t1; ++a28){
        var i26 = 2 * Math.PI * a28 / (t1 + r28 - 1);
        o31[a28] = e15 - n21 * Math.cos(i26);
    }
    return Mn(o31, "float32");
}
var oh = An({
    hannWindow_: function(t1) {
        return rh(t1, 0.5, 0.5);
    }
}), ah = An({
    hammingWindow_: function(t1) {
        return rh(t1, 0.54, 0.46);
    }
}), ih = An({
    frame_: function(t1, e15, n21, r28, o31) {
        (void 0) === r28 && (r28 = !1), (void 0) === o31 && (o31 = 0);
        for(var a28 = 0, i27 = []; a28 + e15 <= t1.size;)i27.push(ml(t1, a28, e15)), a28 += n21;
        if (r28) for(; a28 < t1.size;){
            var s26 = a28 + e15 - t1.size, u17 = Yn([
                ml(t1, a28, e15 - s26),
                Hn([
                    s26
                ], o31)
            ]);
            i27.push(u17), a28 += n21;
        }
        return 0 === i27.length ? Bn([], [
            0,
            e15
        ]) : Yn(i27).as2D(i27.length, e15);
    }
}), sh = An({
    stft_: function(t1, e15, n21, r28, o31) {
        var a28;
        (void 0) === o31 && (o31 = oh), null == r28 && (a28 = e15, r28 = Math.floor(Math.pow(2, Math.ceil(Math.log(a28) / Math.log(2)))));
        for(var i27 = ih(t1, e15, n21), s28 = gc(i27, o31(e15)), u18 = [], c12 = 0; c12 < i27.shape[0]; c12++)u18.push($l(s28.slice([
            c12,
            0
        ], [
            1,
            e15
        ]), r28));
        return Yn(u18);
    }
}), uh = Object.freeze({
    hannWindow: oh,
    hammingWindow: ah,
    frame: ih,
    stft: sh
});
var ch, lh = function(t1, e15, o31) {
    return (void 0) === o31 && (o31 = 1), n10(this, void 0, void 0, function() {
        var n21, a28, i27, s28, u18, c12, l15, h7, f7, d8, p9, v11, m11, g11;
        return r17(this, function(r28) {
            switch(r28.label){
                case 0:
                    return n21 = mn(t1, "predictions", "inTopK"), a28 = mn(e15, "targets", "inTopK"), C(n21.rank > 1, function() {
                        return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n21.rank;
                    }), C(n21.rank - 1 === a28.rank, function() {
                        return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n21.rank + " and targets rank " + a28.rank;
                    }), E(n21.shape.slice(0, n21.shape.length - 1), a28.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i27 = n21.shape[n21.shape.length - 1], C(o31 > 0 && o31 <= i27, function() {
                        return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i27 + "), but got " + o31;
                    }), [
                        4,
                        n21.data()
                    ];
                case 1:
                    return s28 = r28.sent(), [
                        4,
                        a28.data()
                    ];
                case 2:
                    for(u18 = r28.sent(), c12 = [
                        s28.length / i27,
                        i27
                    ], h7 = c12[1], f7 = B("bool", l15 = c12[0]), d8 = 0; d8 < l15; d8++){
                        for(p9 = d8 * h7, v11 = s28.subarray(p9, p9 + h7), m11 = [], g11 = 0; g11 < v11.length; g11++)m11.push({
                            value: v11[g11],
                            index: g11
                        });
                        for(m11.sort(function(t9, e16) {
                            return e16.value - t9.value;
                        }), f7[d8] = 0, g11 = 0; g11 < o31; g11++)if (m11[g11].index === u18[d8]) {
                            f7[d8] = 1;
                            break;
                        }
                    }
                    return t1 !== n21 && n21.dispose(), e15 !== a28 && a28.dispose(), [
                        2,
                        Fn(f7, a28.shape, "bool")
                    ];
            }
        });
    });
};
!function(t1) {
    t1[t1.NONE = 0] = "NONE", t1[t1.MEAN = 1] = "MEAN", t1[t1.SUM = 2] = "SUM", t1[t1.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(ch || (ch = {
}));
var hh = An({
    absoluteDifference_: function(t1, e15, n21, r28) {
        (void 0) === r28 && (r28 = ch.SUM_BY_NONZERO_WEIGHTS);
        var o31 = mn(t1, "labels", "absoluteDifference"), a28 = mn(e15, "predictions", "absoluteDifference"), i27 = null;
        null != n21 && (i27 = mn(n21, "weights", "absoluteDifference")), E(o31.shape, a28.shape, "Error in absoluteDifference: ");
        var s28 = o31.sub(a28).abs();
        return fh(s28, i27, r28);
    }
}), fh = An({
    computeWeightedLoss_: function(t1, e15, n21) {
        (void 0) === n21 && (n21 = ch.SUM_BY_NONZERO_WEIGHTS);
        var r28 = mn(t1, "losses", "computeWeightedLoss"), o31 = null;
        null != e15 && (o31 = mn(e15, "weights", "computeWeightedLoss"));
        var a28 = null == o31 ? r28 : r28.mul(o31);
        if (n21 === ch.NONE) return a28;
        if (n21 === ch.SUM) return a28.sum();
        if (n21 === ch.MEAN) {
            if (null == o31) return a28.mean();
            var i27 = r28.size / o31.size, s28 = a28.sum().div(o31.sum());
            return i27 > 1 ? s28.div(On(i27)) : s28;
        }
        if (n21 === ch.SUM_BY_NONZERO_WEIGHTS) {
            if (null == o31) return a28.sum().div(On(r28.size));
            var u18 = o31.mul(zn(r28.shape)).notEqual(On(0)).sum().toFloat();
            return a28.sum().div(u18);
        }
        throw Error("Unknown reduction: " + n21);
    }
}), dh = An({
    cosineDistance_: function(t1, e15, n21, r28, o31) {
        (void 0) === o31 && (o31 = ch.SUM_BY_NONZERO_WEIGHTS);
        var a28 = mn(t1, "labels", "cosineDistance"), i28 = mn(e15, "predictions", "cosineDistance"), s29 = null;
        null != r28 && (s29 = mn(r28, "weights", "cosineDistance")), E(a28.shape, i28.shape, "Error in cosineDistance: ");
        var u19 = On(1).sub(a28.mul(i28).sum(n21, !0));
        return fh(u19, s29, o31);
    }
}), ph = An({
    hingeLoss_: function(t1, e15, n21, r28) {
        (void 0) === r28 && (r28 = ch.SUM_BY_NONZERO_WEIGHTS);
        var o31 = mn(t1, "labels", "hingeLoss"), a28 = mn(e15, "predictions", "hingeLoss"), i28 = null;
        null != n21 && (i28 = mn(n21, "weights", "hingeLoss")), E(o31.shape, a28.shape, "Error in hingeLoss: ");
        var s29 = On(1);
        o31 = On(2).mul(o31).sub(s29);
        var u19 = s29.sub(o31.mul(a28)).relu();
        return fh(u19, i28, r28);
    }
}), vh = An({
    huberLoss_: function(t1, e15, n21, r28, o31) {
        (void 0) === r28 && (r28 = 1), (void 0) === o31 && (o31 = ch.SUM_BY_NONZERO_WEIGHTS);
        var a28 = mn(t1, "labels", "huberLoss"), i28 = mn(e15, "predictions", "huberLoss"), s29 = null;
        null != n21 && (s29 = mn(n21, "weights", "huberLoss")), E(a28.shape, i28.shape, "Error in huberLoss: ");
        var u19 = On(r28), c12 = i28.sub(a28).abs(), l15 = dc(c12, u19), h7 = c12.sub(l15), f7 = On(0.5).mul(l15.square()).add(u19.mul(h7));
        return fh(f7, s29, o31);
    }
}), mh = An({
    logLoss_: function(t1, e15, n21, r28, o31) {
        (void 0) === r28 && (r28 = 0.0000001), (void 0) === o31 && (o31 = ch.SUM_BY_NONZERO_WEIGHTS);
        var a28 = mn(t1, "labels", "logLoss"), i28 = mn(e15, "predictions", "logLoss"), s29 = null;
        null != n21 && (s29 = mn(n21, "weights", "logLoss")), E(a28.shape, i28.shape, "Error in logLoss: ");
        var u19 = On(1), c12 = On(r28), l15 = a28.mul(i28.add(c12).log()).neg().sub(u19.sub(a28).mul(u19.sub(i28).add(c12).log()));
        return fh(l15, s29, o31);
    }
}), gh = An({
    meanSquaredError_: function(t1, e15, n21, r28) {
        (void 0) === r28 && (r28 = ch.SUM_BY_NONZERO_WEIGHTS);
        var o31 = mn(t1, "labels", "meanSquaredError"), a28 = mn(e15, "predictions", "meanSquaredError"), i28 = null;
        null != n21 && (i28 = mn(n21, "weights", "meanSquaredError")), E(o31.shape, a28.shape, "Error in meanSquaredError: ");
        var s29 = o31.squaredDifference(a28);
        return fh(s29, i28, r28);
    }
}), yh = An({
    sigmoidCrossEntropy_: function(t1, e15, n21, r28, o31) {
        (void 0) === r28 && (r28 = 0), (void 0) === o31 && (o31 = ch.SUM_BY_NONZERO_WEIGHTS);
        var a28 = mn(t1, "multiClassLabels", "sigmoidCrossEntropy"), i28 = mn(e15, "logits", "sigmoidCrossEntropy"), s29 = null;
        if (null != n21 && (s29 = mn(n21, "weights", "sigmoidCrossEntropy")), E(a28.shape, i28.shape, "Error in sigmoidCrossEntropy: "), r28 > 0) {
            var u19 = On(r28), c12 = On(1), l15 = On(0.5);
            a28 = a28.mul(c12.sub(u19)).add(l15.mul(u19));
        }
        var h7 = function(t9, e16) {
            var n24 = mn(t9, "labels", "sigmoidCrossEntropyWithLogits"), r30 = mn(e16, "logits", "sigmoidCrossEntropyWithLogits");
            E(n24.shape, r30.shape, "Error in sigmoidCrossEntropyWithLogits: ");
            var o32 = r30.relu(), a29 = r30.mul(n24), i29 = r30.abs().neg().exp().log1p();
            return o32.sub(a29).add(i29);
        }(a28, i28);
        return fh(h7, s29, o31);
    }
}), xh = An({
    softmaxCrossEntropy_: function(t1, e15, n21, r28, o31) {
        (void 0) === r28 && (r28 = 0), (void 0) === o31 && (o31 = ch.SUM_BY_NONZERO_WEIGHTS);
        var a28 = mn(t1, "onehotLabels", "softmaxCrossEntropy"), i28 = mn(e15, "logits", "softmaxCrossEntropy"), s29 = null;
        if (null != n21 && (s29 = mn(n21, "weights", "softmaxCrossEntropy")), E(a28.shape, i28.shape, "Error in softmaxCrossEntropy: "), r28 > 0) {
            var u20 = On(r28), c13 = On(1), l16 = On(a28.shape[1]);
            a28 = a28.mul(c13.sub(u20)).add(u20.div(l16));
        }
        var h7 = function(t9, e16, n24) {
            if ((void 0) === n24 && (n24 = -1), -1 === n24 && (n24 = e16.rank - 1), n24 !== e16.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e16.rank + " and dim was " + n24);
            return vo(function(t10, e17, r30) {
                var o32 = e17.logSumExp([
                    n24
                ], !0), a29 = e17.toFloat().sub(o32);
                r30([
                    t10,
                    a29
                ]);
                return {
                    value: a29.mul(t10).neg().sum([
                        n24
                    ]),
                    gradFunc: function(t11, e18) {
                        var r31 = e18[0], o33 = e18[1], a30 = wn(t11.shape, [
                            n24
                        ]);
                        return [
                            t11.reshape(a30).mul(r31.toFloat().sub(o33.exp())),
                            t11.reshape(a30).mul(o33.exp().sub(r31.toFloat()))
                        ];
                    }
                };
            })(t9, e16);
        }(a28, i28);
        return fh(h7, s29, o31);
    }
}), bh = Object.freeze({
    get Reduction () {
        return ch;
    },
    absoluteDifference: hh,
    computeWeightedLoss: fh,
    cosineDistance: dh,
    hingeLoss: ph,
    huberLoss: vh,
    logLoss: mh,
    meanSquaredError: gh,
    sigmoidCrossEntropy: yh,
    softmaxCrossEntropy: xh
});
function wh(t1, e15) {
    return (void 0) === e15 && (e15 = !1), Lt.tidy(function() {
        if (2 !== t1.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t1.shape.length + "D Tensor.");
        for(var n21 = t1.shape[0], r28 = t1.shape[1], o31 = Cr(n21), a28 = t1.clone(), i28 = Bn([
            [
                1
            ]
        ], [
            1,
            1
        ]), s29 = i28.clone(), u21 = n21 >= r28 ? r28 : n21, c14 = function(t9) {
            var e16, u22 = a28, c15 = s29, l17 = o31;
            e16 = Lt.tidy(function() {
                var e17 = a28.slice([
                    t9,
                    t9
                ], [
                    n21 - t9,
                    1
                ]), u23 = e17.norm(), c16 = a28.slice([
                    t9,
                    t9
                ], [
                    1,
                    1
                ]), l18 = Bn([
                    [
                        -1
                    ]
                ]).where(c16.greater(0), Bn([
                    [
                        1
                    ]
                ])), h7 = c16.sub(l18.mul(u23)), f7 = e17.div(h7);
                s29 = 1 === f7.shape[0] ? i28.clone() : i28.concat(f7.slice([
                    1,
                    0
                ], [
                    f7.shape[0] - 1,
                    f7.shape[1]
                ]), 0);
                var d8 = l18.matMul(h7).div(u23).neg(), p9 = a28.slice([
                    t9,
                    0
                ], [
                    n21 - t9,
                    r28
                ]), v11 = d8.mul(s29);
                if (0 === t9) a28 = p9.sub(v11.matMul(s29.transpose().matMul(p9)));
                else {
                    var m11 = p9.sub(v11.matMul(s29.transpose().matMul(p9)));
                    a28 = a28.slice([
                        0,
                        0
                    ], [
                        t9,
                        r28
                    ]).concat(m11, 0);
                }
                var g11 = o31.slice([
                    0,
                    t9
                ], [
                    n21,
                    o31.shape[1] - t9
                ]);
                if (0 === t9) o31 = g11.sub(g11.matMul(s29).matMul(v11.transpose()));
                else {
                    var y7 = g11.sub(g11.matMul(s29).matMul(v11.transpose()));
                    o31 = o31.slice([
                        0,
                        0
                    ], [
                        n21,
                        t9
                    ]).concat(y7, 1);
                }
                return [
                    s29,
                    a28,
                    o31
                ];
            }), s29 = e16[0], a28 = e16[1], o31 = e16[2], tn([
                u22,
                c15,
                l17
            ]);
        }, l17 = 0; l17 < u21; ++l17)c14(l17);
        return !e15 && n21 > r28 && (o31 = o31.slice([
            0,
            0
        ], [
            n21,
            r28
        ]), a28 = a28.slice([
            0,
            0
        ], [
            r28,
            r28
        ])), [
            o31,
            a28
        ];
    });
}
var Ch = An({
    bandPart_: function(t1, e15, n21) {
        if (e15 % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e15 + ".");
        if (n21 % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n21 + ".");
        var r28 = mn(t1, "a", "bandPart");
        if (r28.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r28.rank + ".");
        var o31 = r28.shape, a28 = r28.shape.slice(-2), i28 = a28[0], s29 = a28[1];
        if (!(e15 <= i28)) throw new Error("bandPart(): numLower (" + e15 + ") must not be greater than the number of rows (" + i28 + ").");
        if (!(n21 <= s29)) throw new Error("bandPart(): numUpper (" + n21 + ") must not be greater than the number of columns (" + s29 + ").");
        e15 < 0 && (e15 = i28), n21 < 0 && (n21 = s29);
        var u21 = Kn(0, i28, 1, "int32").reshape([
            -1,
            1
        ]), c14 = Kn(0, s29, 1, "int32"), l17 = Cc(u21, c14), h7 = Qu(l17.lessEqual(On(+e15, "int32")), l17.greaterEqual(On(-n21, "int32"))), f7 = Gn([
            i28,
            s29
        ], r28.dtype);
        return Pr(Ur(r28.reshape([
            -1,
            i28,
            s29
        ])).map(function(t9) {
            return ec(h7, t9, f7);
        })).reshape(o31);
    }
}), Eh = An({
    gramSchmidt_: function(t1) {
        var e15;
        if (Array.isArray(t1)) {
            e15 = !1, C(null != t1 && t1.length > 0, function() {
                return "Gram-Schmidt process: input must not be null, undefined, or empty";
            });
            for(var n21 = t1[0].shape[0], r28 = function(e16) {
                C(t1[e16].shape[0] === n21, function() {
                    return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t1[e16].shape[0] + " vs. " + n21 + ")";
                });
            }, o31 = 1; o31 < t1.length; ++o31)r28(o31);
        } else e15 = !0, t1 = tr(t1, t1.shape[0], 0).map(function(t9) {
            return Br(t9, [
                0
            ]);
        });
        C(t1.length <= t1[0].shape[0], function() {
            return "Gram-Schmidt: Number of vectors (" + t1.length + ") exceeds number of dimensions (" + t1[0].shape[0] + ").";
        });
        var a28 = [], i28 = t1, s29 = function(t9) {
            a28.push(Lt.tidy(function() {
                var e16 = i28[t9];
                if (t9 > 0) for(var n24 = 0; n24 < t9; ++n24){
                    var r30 = Nl(a28[n24].mulStrict(e16)).mul(a28[n24]);
                    e16 = e16.sub(r30);
                }
                return e16.div(Vl(e16, "euclidean"));
            }));
        };
        for(o31 = 0; o31 < t1.length; ++o31)s29(o31);
        return e15 ? Pr(a28, 0) : a28;
    }
}), Rh = An({
    qr_: function(t1, e15) {
        if ((void 0) === e15 && (e15 = !1), t1.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t1.rank);
        if (2 === t1.rank) return wh(t1, e15);
        var n24 = t1.shape.slice(0, t1.shape.length - 2).reduce(function(t9, e16) {
            return t9 * e16;
        }), r31 = Ur(t1.reshape([
            n24,
            t1.shape[t1.shape.length - 2],
            t1.shape[t1.shape.length - 1]
        ]), 0), o32 = [], a28 = [];
        return r31.forEach(function(t9) {
            var n25 = wh(t9, e15), r32 = n25[0], i28 = n25[1];
            o32.push(r32), a28.push(i28);
        }), [
            Pr(o32, 0).reshape(t1.shape),
            Pr(a28, 0).reshape(t1.shape)
        ];
    }
}), Ih = Object.freeze({
    bandPart: Ch,
    gramSchmidt: Eh,
    qr: Rh
});
function kh(t1, e15, n24, r31, o32, a28) {
    null == r31 && (r31 = 0.5), null == o32 && (o32 = Number.NEGATIVE_INFINITY), null == a28 && (a28 = 0);
    var i28 = t1.shape[0];
    return n24 = Math.min(n24, i28), C(0 <= r31 && r31 <= 1, function() {
        return "iouThreshold must be in [0, 1], but was '" + r31 + "'";
    }), C(2 === t1.rank, function() {
        return "boxes must be a 2D tensor, but was of rank '" + t1.rank + "'";
    }), C(4 === t1.shape[1], function() {
        return "boxes must have 4 columns, but 2nd dimension was " + t1.shape[1];
    }), C(1 === e15.rank, function() {
        return "scores must be a 1D tensor";
    }), C(e15.shape[0] === i28, function() {
        return "scores has incompatible shape with boxes. Expected " + i28 + ", but was " + e15.shape[0];
    }), C(0 <= a28 && a28 <= 1, function() {
        return "softNmsSigma must be in [0, 1], but was '" + a28 + "'";
    }), {
        maxOutputSize: n24,
        iouThreshold: r31,
        scoreThreshold: o32,
        softNmsSigma: a28
    };
}
var Sh = An({
    resizeBilinear_: function(t1, e15, n24) {
        (void 0) === n24 && (n24 = !1);
        var r31 = mn(t1, "images", "resizeBilinear");
        C(3 === r31.rank || 4 === r31.rank, function() {
            return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r31.rank + ".";
        }), C(2 === e15.length, function() {
            return "Error in resizeBilinear: new shape must 2D, but got shape " + e15 + ".";
        });
        var o32 = r31, a28 = !1;
        3 === r31.rank && (a28 = !0, o32 = r31.as4D(1, r31.shape[0], r31.shape[1], r31.shape[2]));
        var i28 = e15[0], s29 = e15[1], u21 = Lt.runKernelFunc(function(t9, e16) {
            return e16([
                o32
            ]), t9.resizeBilinear(o32, i28, s29, n24);
        }, {
            x: o32
        }, function(t9, e16) {
            return {
                x: function() {
                    return Lt.runKernelFunc(function(r32) {
                        return r32.resizeBilinearBackprop(t9, e16[0], n24);
                    }, {
                    });
                }
            };
        }, "ResizeBilinear", {
            alignCorners: n24,
            newHeight: i28,
            newWidth: s29
        });
        return a28 ? u21.as3D(u21.shape[1], u21.shape[2], u21.shape[3]) : u21;
    }
}), Ah = An({
    resizeNearestNeighbor_: function(t1, e15, n24) {
        (void 0) === n24 && (n24 = !1);
        var r31 = mn(t1, "images", "resizeNearestNeighbor");
        C(3 === r31.rank || 4 === r31.rank, function() {
            return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r31.rank + ".";
        }), C(2 === e15.length, function() {
            return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e15 + ".";
        }), C("float32" === r31.dtype || "int32" === r31.dtype, function() {
            return "`images` must have `int32` or `float32` as dtype";
        });
        var o32 = r31, a28 = !1;
        3 === r31.rank && (a28 = !0, o32 = r31.as4D(1, r31.shape[0], r31.shape[1], r31.shape[2]));
        var i28 = e15[0], s29 = e15[1], u21 = Lt.runKernelFunc(function(t9, e16) {
            return e16([
                o32
            ]), t9.resizeNearestNeighbor(o32, i28, s29, n24);
        }, {
            batchImages: o32
        }, function(t9, e16) {
            return {
                batchImages: function() {
                    return Lt.runKernelFunc(function(r32) {
                        return r32.resizeNearestNeighborBackprop(t9, e16[0], n24);
                    }, {
                    });
                }
            };
        });
        return a28 ? u21.as3D(u21.shape[1], u21.shape[2], u21.shape[3]) : u21;
    }
}), Dh = An({
    nonMaxSuppression_: function(t1, e15, n24, r31, o32) {
        (void 0) === r31 && (r31 = 0.5), (void 0) === o32 && (o32 = Number.NEGATIVE_INFINITY);
        var a28 = mn(t1, "boxes", "nonMaxSuppression"), i28 = mn(e15, "scores", "nonMaxSuppression"), s29 = kh(a28, i28, n24, r31, o32);
        n24 = s29.maxOutputSize, r31 = s29.iouThreshold, o32 = s29.scoreThreshold;
        var u21 = {
            maxOutputSize: n24,
            iouThreshold: r31,
            scoreThreshold: o32
        };
        return Lt.runKernelFunc(function(t9) {
            return t9.nonMaxSuppression(a28, i28, n24, r31, o32);
        }, {
            boxes: a28,
            scores: i28
        }, null, "NonMaxSuppressionV3", u21);
    }
}), Th = function(t1, e15, o32, a28, i28) {
    return (void 0) === a28 && (a28 = 0.5), (void 0) === i28 && (i28 = Number.NEGATIVE_INFINITY), n10(this, void 0, void 0, function() {
        var n24, s29, u21, c14, l17, h7, f7;
        return r17(this, function(r31) {
            switch(r31.label){
                case 0:
                    return n24 = mn(t1, "boxes", "nonMaxSuppressionAsync"), s29 = mn(e15, "scores", "nonMaxSuppressionAsync"), u21 = kh(n24, s29, o32, a28, i28), o32 = u21.maxOutputSize, a28 = u21.iouThreshold, i28 = u21.scoreThreshold, [
                        4,
                        Promise.all([
                            n24.data(),
                            s29.data()
                        ])
                    ];
                case 1:
                    return c14 = r31.sent(), l17 = c14[0], h7 = c14[1], f7 = jo(l17, h7, o32, a28, i28), n24 !== t1 && n24.dispose(), s29 !== e15 && s29.dispose(), [
                        2,
                        f7
                    ];
            }
        });
    });
}, Nh = An({
    nonMaxSuppressionWithScore_: function(t1, e15, n24, r31, o32, a28) {
        (void 0) === r31 && (r31 = 0.5), (void 0) === o32 && (o32 = Number.NEGATIVE_INFINITY), (void 0) === a28 && (a28 = 0);
        var i28 = mn(t1, "boxes", "nonMaxSuppression"), s29 = mn(e15, "scores", "nonMaxSuppression"), u21 = kh(i28, s29, n24, r31, o32, a28), c14 = {
            maxOutputSize: n24 = u21.maxOutputSize,
            iouThreshold: r31 = u21.iouThreshold,
            scoreThreshold: o32 = u21.scoreThreshold,
            softNmsSigma: a28 = u21.softNmsSigma
        }, l17 = Lt.runKernel("NonMaxSuppressionV5", {
            boxes: i28,
            scores: s29
        }, c14);
        return {
            selectedIndices: l17[0],
            selectedScores: l17[1]
        };
    }
}), Fh = function(t1, e15, o32, a28, i28, s29) {
    return (void 0) === a28 && (a28 = 0.5), (void 0) === i28 && (i28 = Number.NEGATIVE_INFINITY), (void 0) === s29 && (s29 = 0), n10(this, void 0, void 0, function() {
        var n24, u21, c14, l17, h7, f7, d8;
        return r17(this, function(r31) {
            switch(r31.label){
                case 0:
                    return n24 = mn(t1, "boxes", "nonMaxSuppressionAsync"), u21 = mn(e15, "scores", "nonMaxSuppressionAsync"), c14 = kh(n24, u21, o32, a28, i28, s29), o32 = c14.maxOutputSize, a28 = c14.iouThreshold, i28 = c14.scoreThreshold, s29 = c14.softNmsSigma, [
                        4,
                        Promise.all([
                            n24.data(),
                            u21.data()
                        ])
                    ];
                case 1:
                    return l17 = r31.sent(), h7 = l17[0], f7 = l17[1], d8 = Xo(h7, f7, o32, a28, i28, s29), n24 !== t1 && n24.dispose(), u21 !== e15 && u21.dispose(), [
                        2,
                        d8
                    ];
            }
        });
    });
}, _h = An({
    cropAndResize_: function(t1, e15, n24, r31, o32, a28) {
        var i28 = mn(t1, "image", "cropAndResize"), s29 = mn(e15, "boxes", "cropAndResize", "float32"), u21 = mn(n24, "boxInd", "cropAndResize", "int32");
        o32 = o32 || "bilinear", a28 = a28 || 0;
        var c14 = s29.shape[0];
        return C(4 === i28.rank, function() {
            return "Error in cropAndResize: image must be rank 4,but got rank " + i28.rank + ".";
        }), C(2 === s29.rank && 4 === s29.shape[1], function() {
            return "Error in cropAndResize: boxes must be have size [" + c14 + ",4] but had shape " + s29.shape + ".";
        }), C(1 === u21.rank && u21.shape[0] === c14, function() {
            return "Error in cropAndResize: boxInd must be have size [" + c14 + "] but had shape " + s29.shape + ".";
        }), C(2 === r31.length, function() {
            return "Error in cropAndResize: cropSize must be of length 2, but got length " + r31.length + ".";
        }), C(r31[0] >= 1 && r31[1] >= 1, function() {
            return "cropSize must be atleast [1,1], but was " + r31;
        }), C("bilinear" === o32 || "nearest" === o32, function() {
            return "method must be bilinear or nearest, but was " + o32;
        }), Lt.runKernelFunc(function(t9, e16) {
            return t9.cropAndResize(i28, s29, u21, r31, o32, a28);
        }, {
            images: i28,
            boxes: s29,
            boxInd: u21
        }, null, "CropAndResize", {
            method: o32,
            extrapolationValue: a28,
            cropSize: r31
        });
    }
}), Oh = Object.freeze({
    resizeBilinear: Sh,
    resizeNearestNeighbor: Ah,
    nonMaxSuppression: Dh,
    nonMaxSuppressionAsync: Th,
    nonMaxSuppressionWithScore: Nh,
    nonMaxSuppressionWithScoreAsync: Fh,
    cropAndResize: _h
}), Mh = function(t1, e15) {
    return !(t1 > 0) || "linear" === e15;
}, Bh = function(t1, e15, n24) {
    if (null == n24 || "linear" === n24) return t1;
    if ("relu" === n24) return t1.mul(e15.step());
    throw new Error("Gradient for activation " + n24 + " has not been implemented yet.");
}, Ph = function(t1, e15) {
    var n24 = e15, r31 = Eo(t1.shape, e15.shape);
    return r31.length > 0 && (n24 = n24.sum(r31)), n24.reshape(t1.shape);
}, Lh = function(t1, e15, n24) {
    if ("linear" === e15) return t1;
    if ("relu" === e15) return Bl(t1);
    if ("elu" === e15) return _l(t1);
    if ("relu6" === e15) return Pl(t1);
    if ("prelu" === e15) return Ml(t1, n24);
    throw new Error("Unknown fused activation " + e15 + ".");
};
var Wh = An({
    fusedMatMul_: function(t1) {
        var e15, n24 = t1.a, r31 = t1.b, o32 = t1.transposeA, a28 = (void 0) !== o32 && o32, i28 = t1.transposeB, s29 = (void 0) !== i28 && i28, u21 = t1.bias, c14 = t1.activation, l17 = (void 0) === c14 ? "linear" : c14, h7 = t1.preluActivationWeights;
        if (!1 === Mh(Lt.state.gradientDepth, l17)) {
            var f7 = el(n24, r31, a28, s29);
            return null != u21 && (f7 = rc(f7, u21)), Lh(f7, l17, h7);
        }
        var d8 = mn(n24, "a", "fused matMul"), p9 = mn(r31, "b", "fused matMul");
        e15 = Nt(d8, p9), d8 = e15[0], p9 = e15[1];
        var v11 = a28 ? d8.shape[d8.rank - 2] : d8.shape[d8.rank - 1], m12 = s29 ? p9.shape[p9.rank - 1] : p9.shape[p9.rank - 2], g11 = a28 ? d8.shape[d8.rank - 1] : d8.shape[d8.rank - 2], y8 = s29 ? p9.shape[p9.rank - 2] : p9.shape[p9.rank - 1], x7 = d8.shape.slice(0, -2), b4 = p9.shape.slice(0, -2), w3 = k(x7), E1 = k(b4);
        C(d8.rank >= 2 && p9.rank >= 2 && d8.rank === p9.rank, function() {
            return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + d8.rank + " and " + p9.rank + ".";
        }), C(S(x7, b4), function() {
            return "Error in fused matMul: outer dimensions (" + x7 + ") and (" + b4 + ") of Tensors with shapes " + d8.shape + " and " + p9.shape + " must match.";
        }), C(v11 === m12, function() {
            return "Error in fused matMul: inner shapes (" + v11 + ") and (" + m12 + ") of Tensors with shapes " + d8.shape + " and " + p9.shape + " and transposeA=" + a28 + " and transposeB=" + s29 + " must match.";
        });
        var R1, I1, A1 = d8.shape.slice(0, -2).concat([
            g11,
            y8
        ]), D1 = a28 ? d8.as3D(w3, v11, g11) : d8.as3D(w3, g11, v11), T1 = s29 ? p9.as3D(E1, y8, m12) : p9.as3D(E1, m12, y8);
        null != u21 && Ro(A1, (R1 = Nt(R1 = mn(u21, "bias", "fused matMul"), d8)[0]).shape), null != h7 && (I1 = mn(h7, "prelu weights", "fused matMul"));
        var N1 = {
            a: D1,
            b: T1
        };
        null != u21 && (N1.bias = R1), null != h7 && (N1.preluActivationWeights = I1);
        var F1 = [
            D1,
            T1
        ];
        return Lt.runKernelFunc(function(t9, e16) {
            var n25 = t9.fusedBatchMatMul({
                a: D1,
                b: T1,
                transposeA: a28,
                transposeB: s29,
                bias: R1,
                activation: l17,
                preluActivationWeights: I1
            });
            return e16([
                D1,
                T1,
                n25
            ]), n25;
        }, N1, function(t9, e16) {
            var n25 = e16[0], r32 = e16[1], o33 = e16[2], i29 = Bh(t9, o33, l17), c15 = {
            };
            return null != u21 && (c15 = {
                bias: function() {
                    return Ph(R1, i29);
                }
            }), a28 || s29 ? !a28 && s29 ? Object.assign({
                a: function() {
                    return i29.matMul(r32, !1, !1);
                },
                b: function() {
                    return i29.matMul(n25, !0, !1);
                }
            }, c15) : a28 && !s29 ? Object.assign({
                a: function() {
                    return r32.matMul(i29, !1, !0);
                },
                b: function() {
                    return n25.matMul(i29, !1, !1);
                }
            }, c15) : Object.assign({
                a: function() {
                    return r32.matMul(i29, !0, !0);
                },
                b: function() {
                    return i29.matMul(n25, !0, !0);
                }
            }, c15) : Object.assign({
                a: function() {
                    return i29.matMul(r32, !1, !0);
                },
                b: function() {
                    return n25.matMul(i29, !0, !1);
                }
            }, c15);
        }, "_FusedMatMul", {
            transposeA: a28,
            transposeB: s29,
            activation: l17
        }, F1, [
            !0
        ]).reshape(A1);
    }
}), Uh = An({
    fusedConv2d_: function(t1) {
        var e15 = t1.x, n24 = t1.filter, r31 = t1.strides, o32 = t1.pad, a28 = t1.dataFormat, i28 = (void 0) === a28 ? "NHWC" : a28, s29 = t1.dilations, u21 = (void 0) === s29 ? [
            1,
            1
        ] : s29, c14 = t1.dimRoundingMode, l17 = t1.bias, h7 = t1.activation, f9 = (void 0) === h7 ? "linear" : h7, d8 = t1.preluActivationWeights;
        if (f9 = f9 || "linear", !1 === Mh(Lt.state.gradientDepth, f9)) {
            var p9 = qc(e15, n24, r31, o32, i28, u21, c14);
            return null != l17 && (p9 = rc(p9, l17)), Lh(p9, f9, d8);
        }
        var v11 = mn(e15, "x", "conv2d"), m12 = mn(n24, "filter", "conv2d"), g11 = v11, y8 = !1;
        3 === v11.rank && (y8 = !0, g11 = v11.as4D(1, v11.shape[0], v11.shape[1], v11.shape[2])), C(4 === g11.rank, function() {
            return "Error in fused conv2d: input must be rank 4, but got rank " + g11.rank + ".";
        }), C(4 === m12.rank, function() {
            return "Error in fused conv2d: filter must be rank 4, but got rank " + m12.rank + ".";
        }), null != c14 && C(A(o32), function() {
            return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c14 + " but got pad " + o32 + ".";
        }), C(g11.shape[3] === m12.shape[2], function() {
            return "Error in conv2d: depth of input (" + g11.shape[3] + ") must match input depth for filter " + m12.shape[2] + ".";
        }), C(Mo(r31, u21), function() {
            return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r31 + " and dilations '" + u21 + "'";
        }), C("NHWC" === i28, function() {
            return "Error in conv2d: got dataFormat of " + i28 + " but only NHWC is currently supported.";
        });
        var x7, b4, w3 = So(g11.shape, m12.shape, r31, u21, o32, c14);
        null != l17 && (x7 = Nt(x7 = mn(l17, "bias", "fused conv2d"), v11)[0], Ro(w3.outShape, x7.shape)), null != d8 && (b4 = mn(d8, "prelu weights", "fused conv2d"));
        var E1 = {
            x: g11,
            filter: m12
        };
        null != l17 && (E1.bias = x7), null != d8 && (E1.preluActivationWeights = b4);
        var R1 = [
            m12,
            g11
        ], I1 = Lt.runKernelFunc(function(t9, e16) {
            var n25 = t9.fusedConv2d({
                input: g11,
                filter: m12,
                convInfo: w3,
                bias: x7,
                activation: f9,
                preluActivationWeights: b4
            });
            return e16([
                m12,
                g11,
                n25
            ]), n25;
        }, E1, function(t9, e16) {
            var n25 = e16, a29 = n25[0], i29 = n25[1], s30 = n25[2], c15 = Bh(t9, s30, f9);
            C(Oo(u21), function() {
                return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u21 + "'";
            });
            var h8 = {
            };
            return null != l17 && (h8 = {
                bias: function() {
                    return Ph(x7, c15);
                }
            }), Object.assign({
                x: function() {
                    return Xc(i29.shape, c15, a29, r31, o32);
                },
                filter: function() {
                    return jc(i29, c15, a29.shape, r31, o32);
                }
            }, h8);
        }, "FusedConv2D", {
            convInfo: w3,
            activation: f9
        }, R1, [
            !0
        ]);
        return y8 ? I1.as3D(I1.shape[1], I1.shape[2], I1.shape[3]) : I1;
    }
}), Vh = An({
    fusedDepthwiseConv2d_: function(t1) {
        var e15 = t1.x, n24 = t1.filter, r31 = t1.strides, o32 = t1.pad, a28 = t1.dataFormat, i28 = (void 0) === a28 ? "NHWC" : a28, s29 = t1.dilations, u21 = (void 0) === s29 ? [
            1,
            1
        ] : s29, c14 = t1.dimRoundingMode, l17 = t1.bias, h7 = t1.activation, f9 = (void 0) === h7 ? "linear" : h7, d8 = t1.preluActivationWeights;
        if (!1 === Mh(Lt.state.gradientDepth, f9)) {
            var p10 = Yc(e15, n24, r31, o32, i28, u21, c14);
            return null != l17 && (p10 = rc(p10, l17)), Lh(p10, f9, d8);
        }
        var v11 = mn(e15, "x", "depthwiseConv2d"), m12 = mn(n24, "filter", "depthwiseConv2d"), g11 = v11, y8 = !1;
        3 === v11.rank && (y8 = !0, g11 = v11.as4D(1, v11.shape[0], v11.shape[1], v11.shape[2])), C(4 === g11.rank, function() {
            return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g11.rank + ".";
        }), C(4 === m12.rank, function() {
            return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m12.rank + ".";
        }), C(g11.shape[3] === m12.shape[2], function() {
            return "Error in fused depthwiseConv2d: number of input channels (" + g11.shape[3] + ") must match the inChannels dimension in filter " + m12.shape[2] + ".";
        }), null == u21 && (u21 = [
            1,
            1
        ]), C(Mo(r31, u21), function() {
            return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r31 + " and dilations '" + u21 + "'";
        }), null != c14 && C(A(o32), function() {
            return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c14 + " but got pad " + o32 + ".";
        });
        var x7, b4, w3 = So(g11.shape, m12.shape, r31, u21, o32, c14, !0);
        null != l17 && (x7 = Nt(x7 = mn(l17, "bias", "fused conv2d"), v11)[0], Ro(w3.outShape, x7.shape)), null != d8 && (b4 = mn(d8, "prelu weights", "fused depthwiseConv2d"));
        var E1 = {
            x: g11,
            filter: m12
        };
        null != l17 && (E1.bias = x7), null != d8 && (E1.preluActivationWeights = b4);
        var R1 = [
            m12,
            g11
        ], I1 = Lt.runKernelFunc(function(t9, e16) {
            var n25 = t9.fusedDepthwiseConv2D({
                input: g11,
                filter: m12,
                convInfo: w3,
                bias: x7,
                activation: f9,
                preluActivationWeights: b4
            });
            return e16([
                m12,
                g11,
                n25
            ]), n25;
        }, E1, function(t9, e16) {
            C(Oo(u21), function() {
                return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u21 + "'";
            });
            var n25 = e16[0], r32 = e16[1], o33 = e16[2], a29 = Bh(t9, o33, f9), i29 = {
            };
            return null != l17 && (i29 = {
                bias: function() {
                    return Ph(x7, a29);
                }
            }), Object.assign({
                x: function() {
                    return $c(r32.shape, a29, n25, w3);
                },
                filter: function() {
                    return Qc(r32, a29, n25.shape, w3);
                }
            }, i29);
        }, "FusedDepthwiseConv2D", {
            convInfo: w3,
            activation: f9
        }, R1, [
            !0
        ]);
        return y8 ? I1.as3D(I1.shape[1], I1.shape[2], I1.shape[3]) : I1;
    }
}), zh = Object.freeze({
    matMul: Wh,
    conv2d: Uh,
    depthwiseConv2d: Vh
}), Gh = Object.freeze({
    image: Oh,
    linalg: Ih,
    losses: bh,
    spectral: Jl,
    fused: zh,
    signal: uh,
    square: tu,
    squaredDifference: nu,
    conv1d: Hc,
    conv2d: qc,
    conv3d: Kc,
    depthwiseConv2d: Yc,
    separableConv2d: Jc,
    conv2dTranspose: Zc,
    conv3dTranspose: tl,
    op: An,
    batchNormalization2d: Gu,
    batchNormalization3d: Hu,
    batchNormalization4d: qu,
    batchNormalization: Ku,
    batchNorm: ju,
    batchNorm2d: Xu,
    batchNorm3d: Yu,
    batchNorm4d: $u,
    booleanMaskAsync: Uc,
    complex: Dn,
    real: Tn,
    imag: Nn,
    concat: Yn,
    concat1d: $n,
    concat2d: Qn,
    concat3d: Jn,
    concat4d: Zn,
    split: tr,
    matMul: el,
    dot: nl,
    outerProduct: rl,
    reverse: ol,
    reverse1d: al,
    reverse2d: il,
    reverse3d: sl,
    reverse4d: ul,
    maxPool: hl,
    avgPool: fl,
    pool: dl,
    maxPool3d: pl,
    avgPool3d: vl,
    slice: ml,
    slice1d: gl,
    slice2d: yl,
    slice3d: xl,
    slice4d: bl,
    abs: ru,
    acos: ou,
    acosh: au,
    asin: iu,
    asinh: su,
    atan: uu,
    atanh: cu,
    ceil: lu,
    clipByValue: hu,
    cos: fu,
    cosh: du,
    erf: pu,
    exp: vu,
    expm1: mu,
    floor: gu,
    log: yu,
    log1p: xu,
    logSigmoid: bu,
    neg: wu,
    reciprocal: Cu,
    round: Eu,
    rsqrt: Ru,
    sigmoid: Iu,
    sign: ku,
    isNaN: Su,
    isInf: Au,
    isFinite: Du,
    sin: Tu,
    sinh: Nu,
    softplus: Fu,
    sqrt: _u,
    step: Ou,
    tan: Mu,
    tanh: Bu,
    all: Cl,
    any: El,
    argMax: Rl,
    argMin: Il,
    logSumExp: kl,
    max: Sl,
    mean: Al,
    min: Dl,
    moments: Tl,
    sum: Nl,
    prod: Fl,
    equal: Rc,
    equalStrict: Ic,
    greater: kc,
    greaterEqual: Sc,
    greaterEqualStrict: Ac,
    greaterStrict: Dc,
    less: Tc,
    lessEqual: Nc,
    lessEqualStrict: Fc,
    lessStrict: _c,
    notEqual: Oc,
    notEqualStrict: Mc,
    add: rc,
    addN: oc,
    addStrict: ac,
    atan2: ic,
    div: sc,
    divNoNan: uc,
    divStrict: cc,
    floorDiv: lc,
    maximum: hc,
    maximumStrict: fc,
    minimum: dc,
    minimumStrict: pc,
    mod: vc,
    modStrict: mc,
    mul: gc,
    mulStrict: yc,
    pow: xc,
    powStrict: bc,
    squaredDifferenceStrict: wc,
    sub: Cc,
    subStrict: Ec,
    elu: _l,
    leakyRelu: Ol,
    prelu: Ml,
    relu: Bl,
    relu6: Pl,
    selu: Ll,
    logicalAnd: Qu,
    logicalNot: Ju,
    logicalOr: Zu,
    logicalXor: tc,
    where: ec,
    whereAsync: nc,
    buffer: dr,
    print: pr,
    batchToSpaceND: vr,
    broadcastTo: mr,
    cast: gr,
    clone: yr,
    cumsum: xr,
    depthToSpace: br,
    expandDims: wr,
    eye: Cr,
    multinomial: Er,
    oneHot: Rr,
    pad: Ir,
    pad1d: kr,
    pad2d: Sr,
    pad3d: Ar,
    pad4d: Dr,
    rand: Tr,
    randomNormal: Nr,
    randomGamma: Fr,
    randomUniform: _r,
    reshape: Or,
    spaceToBatchND: Mr,
    squeeze: Br,
    stack: Pr,
    tile: Lr,
    truncatedNormal: Wr,
    unstack: Ur,
    setdiff1dAsync: Vr,
    fill: Hn,
    linspace: qn,
    ones: zn,
    range: Kn,
    scalar: On,
    tensor: Fn,
    tensor1d: Mn,
    tensor2d: Bn,
    tensor3d: Pn,
    tensor4d: Ln,
    tensor5d: Wn,
    tensor6d: Un,
    variable: Vn,
    zeros: Gn,
    onesLike: jn,
    zerosLike: Xn,
    transpose: Wl,
    softmax: go,
    logSoftmax: yo,
    localResponseNormalization: Ul,
    norm: Vl,
    gather: Lc,
    unsortedSegmentSum: Wc,
    basicLSTMCell: zl,
    multiRNNCell: Gl,
    movingAverage: Hl,
    stridedSlice: ql,
    topk: Kl,
    scatterND: jl,
    fft: Xl,
    ifft: Yl,
    rfft: $l,
    irfft: Ql,
    sparseToDense: Zl,
    gatherND: th,
    diag: eh,
    dropout: nh,
    hannWindow: oh,
    hammingWindow: ah,
    frame: ih,
    stft: sh,
    inTopKAsync: lh
});
function Hh(t1, e15) {
    Array.isArray(t1) || (t1 = [
        t1
    ]), t1.forEach(function(t9) {
        null != t9 && C("complex64" !== t9.dtype, function() {
            return e15 + " does not support complex64 tensors.";
        });
    });
}
function qh(t1, e15, n24, r31) {
    if ("linear" === n24) return t1.linear(e15);
    if ("relu" === n24) return t1.relu(e15);
    if ("elu" === n24) return t1.elu(e15);
    if ("relu6" === n24) return t1.relu6(e15);
    if ("prelu" === n24) return t1.prelu(e15, r31);
    throw new Error("Activation " + n24 + " has not been implemented for the CPU backend.");
}
var Kh = function(t1) {
    function o32() {
        var e15 = t1.call(this) || this;
        return e15.blockSize = 48, e15.firstUse = !0, e15.data = new xo(e15, Lt), e15;
    }
    return e(o32, t1), o32.prototype.write = function(t9, e15, n24) {
        this.firstUse && (this.firstUse = !1, i15().get("IS_NODE") && dn("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
        var r31 = {
        };
        return this.data.set(r31, {
            values: t9,
            dtype: n24
        }), r31;
    }, o32.prototype.move = function(t9, e15, n24, r31) {
        this.data.set(t9, {
            values: e15,
            dtype: r31
        });
    }, o32.prototype.numDataIds = function() {
        return this.data.numDataIds();
    }, o32.prototype.read = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e15) {
                return [
                    2,
                    this.readSync(t9)
                ];
            });
        });
    }, o32.prototype.readSync = function(t9) {
        var e15 = this.data.get(t9), n24 = e15.dtype, r31 = e15.complexTensors;
        return "complex64" === n24 ? Vo(this.readSync(r31.real.dataId), this.readSync(r31.imag.dataId)) : this.data.get(t9).values;
    }, o32.prototype.bufferSync = function(t9) {
        var e15 = this.readSync(t9.dataId), n24 = e15;
        if ("string" === t9.dtype) try {
            n24 = e15.map(function(t10) {
                return ot(t10);
            });
        } catch (t10) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return dr(t9.shape, t9.dtype, n24);
    }, o32.prototype.makeOutput = function(t9, e15, n24) {
        var r31 = this.write(t9, e15, n24);
        return Lt.makeTensorFromDataId(r31, e15, n24, this);
    }, o32.prototype.disposeData = function(t9) {
        if (this.data.has(t9)) {
            var e15 = this.data.get(t9).complexTensors;
            null != e15 && (e15.real.dispose(), e15.imag.dispose()), this.data.delete(t9);
        }
    }, o32.prototype.time = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16;
            return r17(this, function(n24) {
                return e16 = et(), t9(), [
                    2,
                    {
                        kernelMs: et() - e16
                    }
                ];
            });
        });
    }, o32.prototype.memory = function() {
        return {
            unreliable: !0,
            reasons: [
                "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."
            ]
        };
    }, o32.prototype.complex = function(t9, e16) {
        var n24 = this.makeOutput(null, t9.shape, "complex64");
        return this.data.get(n24.dataId).complexTensors = {
            real: Lt.keep(t9.clone()),
            imag: Lt.keep(e16.clone())
        }, n24;
    }, o32.prototype.real = function(t9) {
        return this.data.get(t9.dataId).complexTensors.real.clone();
    }, o32.prototype.imag = function(t9) {
        return this.data.get(t9.dataId).complexTensors.imag.clone();
    }, o32.prototype.slice = function(t9, e16, n24) {
        if (Hh(t9, "slice"), io(t9.shape, e16, n24)) {
            var r31 = so(e16, t9.strides), o33 = k(n24);
            return Fn(this.readSync(t9.dataId).subarray(r31, r31 + o33), n24, t9.dtype);
        }
        for(var a28 = dr(n24, t9.dtype), i28 = this.bufferSync(t9), s29 = 0; s29 < a28.size; ++s29){
            var u21 = a28.indexToLoc(s29).map(function(t10, n25) {
                return t10 + e16[n25];
            });
            a28.values[s29] = i28.get.apply(i28, u21);
        }
        return a28.toTensor();
    }, o32.prototype.stridedSlice = function(t9, e16, n24, r32) {
        Hh(t9, "stridedSlice");
        var o34 = ro(e16, n24, r32);
        if (o34.some(function(t10) {
            return 0 === t10;
        })) return Fn([], o34);
        for(var a28 = dr(o34, t9.dtype), i28 = this.bufferSync(t9), s29 = 0; s29 < a28.size; s29++){
            for(var u22 = a28.indexToLoc(s29), c14 = new Array(u22.length), l17 = 0; l17 < c14.length; l17++)c14[l17] = u22[l17] * r32[l17] + e16[l17];
            a28.set.apply(a28, [
                i28.get.apply(i28, c14)
            ].concat(u22));
        }
        return a28.toTensor();
    }, o32.prototype.diag = function(t9) {
        for(var e16 = this.readSync(t9.dataId), n24 = dr([
            t9.size,
            t9.size
        ], t9.dtype), r32 = n24.values, o34 = 0; o34 < e16.length; o34++)r32[o34 * t9.size + o34] = e16[o34];
        return n24.toTensor();
    }, o32.prototype.unstack = function(t9, e16) {
        for(var n24 = t9.shape[e16], r32 = new Array(t9.rank - 1), o34 = 0, a28 = 0; a28 < t9.rank; a28++)a28 !== e16 && (r32[o34++] = t9.shape[a28]);
        var i28 = new Array(t9.rank).fill(0), s29 = t9.shape.slice();
        s29[e16] = 1;
        var u23 = new Array(n24);
        for(a28 = 0; a28 < u23.length; a28++)i28[e16] = a28, u23[a28] = this.slice(t9, i28, s29).reshape(r32);
        return u23;
    }, o32.prototype.reverse = function(t9, e16) {
        Hh(t9, "reverse");
        for(var n24 = dr(t9.shape, t9.dtype), r32 = this.bufferSync(t9), o34 = function(o35) {
            var a28 = n24.indexToLoc(o35), i28 = a28.slice();
            e16.forEach(function(e17) {
                return i28[e17] = t9.shape[e17] - 1 - i28[e17];
            }), n24.set.apply(n24, [
                r32.get.apply(r32, i28)
            ].concat(a28));
        }, a28 = 0; a28 < n24.size; a28++)o34(a28);
        return n24.toTensor();
    }, o32.prototype.concat = function(t9, e16) {
        var n24 = this;
        if ("complex64" === t9[0].dtype) {
            var r32 = t9.map(function(t10) {
                return Tn(t10);
            }), o34 = t9.map(function(t10) {
                return Nn(t10);
            });
            return Dn(this.concat(r32, e16), this.concat(o34, e16));
        }
        var a28 = t9.map(function(t10) {
            var n25 = k(t10.shape.slice(e16));
            return t10.as2D(-1, n25);
        }), i28 = Sn(a28.map(function(t10) {
            return t10.shape;
        }), 1), s29 = dr(i28, t9[0].dtype).values;
        if (1 === a28[0].shape[0]) {
            var u23 = 0;
            a28.forEach(function(t10) {
                s29.set(n24.readSync(t10.dataId), u23), u23 += t10.size;
            });
        } else {
            var c15 = 0;
            a28.forEach(function(t10) {
                for(var e17 = n24.readSync(t10.dataId), r33 = 0, o35 = 0; o35 < t10.shape[0]; ++o35)for(var a29 = o35 * i28[1] + c15, u24 = 0; u24 < t10.shape[1]; ++u24)s29[a29 + u24] = e17[r33++];
                c15 += t10.shape[1];
            });
        }
        var l18 = Sn(t9.map(function(t10) {
            return t10.shape;
        }), e16);
        return Fn(s29, l18, t9[0].dtype);
    }, o32.prototype.neg = function(t9) {
        return Hh(t9, "neg"), this.multiply(On(-1), t9);
    }, o32.prototype.add = function(t9, e16) {
        return "complex64" === t9.dtype || "complex64" === e16.dtype ? this.broadcastedBinaryComplexOp(t9.cast("complex64"), e16.cast("complex64"), function(t10, e17, n24, r33) {
            return {
                real: t10 + n24,
                imag: e17 + r33
            };
        }) : this.broadcastedBinaryOp(t9, e16, Dt(t9.dtype, e16.dtype), function(t10, e17) {
            return t10 + e17;
        });
    }, o32.prototype.addN = function(t9) {
        var e16 = this;
        Hh(t9, "addN");
        for(var n24 = t9.map(function(t10) {
            return e16.readSync(t10.dataId);
        }), r33 = dr(t9[0].shape, t9[0].dtype), o35 = r33.values, a28 = 0; a28 < t9.length; a28++)for(var i28 = n24[a28], s29 = 0; s29 < o35.length; s29++)o35[s29] += i28[s29];
        return r33.toTensor();
    }, o32.prototype.softmax = function(t9, e16) {
        var n24 = O([
            e16
        ], t9.shape), r33 = this.max(t9, n24), o35 = wn(r33.shape, n24), a28 = this.subtract(t9, r33.reshape(o35)), i28 = this.exp(a28), s29 = this.sum(i28, n24).reshape(o35);
        return this.realDivide(i28, s29);
    }, o32.prototype.subtract = function(t9, e16) {
        return "complex64" === t9.dtype || "complex64" === e16.dtype ? this.broadcastedBinaryComplexOp(t9.cast("complex64"), e16.cast("complex64"), function(t10, e17, n24, r33) {
            return {
                real: t10 - n24,
                imag: e17 - r33
            };
        }) : this.broadcastedBinaryOp(t9, e16, Dt(t9.dtype, e16.dtype), function(t10, e17) {
            return t10 - e17;
        });
    }, o32.prototype.pow = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "pow"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            return Math.pow(t10, e17);
        });
    }, o32.prototype.batchMatMul = function(t9, e16, n24, r33) {
        Hh([
            t9,
            e16
        ], "matMul");
        for(var o35 = n24 ? t9.shape[1] : t9.shape[2], a28 = n24 ? t9.shape[2] : t9.shape[1], i28 = r33 ? e16.shape[1] : e16.shape[2], s29 = t9.shape[0], u24 = this.readSync(t9.dataId), c16 = this.readSync(e16.dataId), l18 = n24 ? [
            t9.strides[0],
            1,
            t9.strides[1]
        ] : [
            t9.strides[0],
            t9.strides[1],
            1
        ], h7 = l18[0], f9 = l18[1], d8 = l18[2], p11 = r33 ? [
            1,
            e16.strides[1],
            e16.strides[0]
        ] : [
            e16.strides[1],
            1,
            e16.strides[0]
        ], v11 = p11[0], m12 = p11[1], g11 = p11[2], y8 = a28 * i28, x7 = dr([
            s29,
            a28,
            i28
        ], t9.dtype), b4 = x7.values, w3 = this.blockSize, C1 = 0; C1 < s29; C1++)for(var E1 = 0; E1 < a28; E1 += w3)for(var R1 = 0; R1 < i28; R1 += w3)for(var I1 = 0; I1 < o35; I1 += w3)for(var k1 = Math.min(E1 + w3, a28), S1 = Math.min(R1 + w3, i28), A1 = Math.min(I1 + w3, o35), D1 = E1; D1 < k1; D1++)for(var T1 = R1; T1 < S1; T1++){
            for(var N1 = 0, F1 = I1; F1 < A1; F1++)N1 += u24[C1 * h7 + D1 * f9 + F1 * d8] * c16[F1 * v11 + T1 * m12 + C1 * g11];
            b4[C1 * y8 + (D1 * i28 + T1)] += N1;
        }
        return x7.toTensor();
    }, o32.prototype.fusedBatchMatMul = function(t9) {
        var e16 = t9.a, n24 = t9.b, r33 = t9.transposeA, o35 = t9.transposeB, a28 = t9.bias, i28 = t9.activation, s29 = t9.preluActivationWeights, u24 = this.batchMatMul(e16, n24, r33, o35);
        return a28 && (u24 = this.add(u24, a28)), i28 && (u24 = qh(this, u24, i28, s29)), u24;
    }, o32.prototype.multiply = function(t9, e16) {
        return "complex64" === t9.dtype || "complex64" === e16.dtype ? this.broadcastedBinaryComplexOp(t9.cast("complex64"), e16.cast("complex64"), function(t10, e17, n24, r33) {
            return {
                real: t10 * n24 - e17 * r33,
                imag: t10 * r33 + e17 * n24
            };
        }) : this.broadcastedBinaryOp(t9, e16, Dt(t9.dtype, e16.dtype), function(t10, e17) {
            return t10 * e17;
        });
    }, o32.prototype.realDivide = function(t9, e16) {
        Hh([
            t9,
            e16
        ], "realDivide");
        return this.broadcastedBinaryOp(t9, e16, "float32", function(t10, e17) {
            return t10 / e17;
        });
    }, o32.prototype.floorDiv = function(t9, e16) {
        Hh([
            t9,
            e16
        ], "floorDiv");
        return this.broadcastedBinaryOp(t9, e16, "int32", function(t10, e17) {
            return Math.floor(t10 / e17);
        });
    }, o32.prototype.sum = function(t9, e16) {
        Hh(t9, "sum"), Cn("sum", e16, t9.rank);
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, Dt(t9.dtype, "int32")), i28 = k(o35), s29 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s29.length; ++c16){
            for(var l18 = c16 * i28, h7 = 0, f9 = 0; f9 < i28; ++f9)h7 += u24[l18 + f9];
            s29[c16] = h7;
        }
        return a28;
    }, o32.prototype.prod = function(t9, e16) {
        Hh(t9, "sum");
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, Dt(t9.dtype, "int32")), i28 = k(o35), s29 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s29.length; ++c16){
            for(var l19 = c16 * i28, h8 = 1, f10 = 0; f10 < i28; ++f10)h8 *= u24[l19 + f10];
            s29[c16] = h8;
        }
        return a28;
    }, o32.prototype.unsortedSegmentSum = function(t9, e16, n24) {
        Hh(t9, "unsortedSegmentSum");
        for(var r33 = [], o35 = t9.rank - e16.rank, a28 = 0; a28 < o35; ++a28)e16 = e16.expandDims(a28 + 1);
        for(a28 = 0; a28 < n24; ++a28){
            var i28 = On(a28, "int32"), s29 = Rc(i28, e16).asType("float32").mul(t9).sum(0);
            r33.push(s29);
        }
        return Pr(r33);
    }, o32.prototype.argMin = function(t9, e16) {
        Hh(t9, "argMin");
        var n24 = [
            e16
        ];
        Cn("argMin", n24, t9.rank);
        for(var r33 = bn(t9.shape, n24), o35 = r33[0], a28 = r33[1], i29 = Gn(o35, "int32"), s30 = k(a28), u24 = this.readSync(i29.dataId), c16 = this.readSync(t9.dataId), l20 = 0; l20 < u24.length; ++l20){
            for(var h9 = l20 * s30, f11 = c16[h9], d8 = 0, p11 = 0; p11 < s30; ++p11){
                var v11 = c16[h9 + p11];
                v11 < f11 && (f11 = v11, d8 = p11);
            }
            u24[l20] = d8;
        }
        return i29;
    }, o32.prototype.argMax = function(t9, e16) {
        Hh(t9, "argMax");
        var n24 = [
            e16
        ];
        Cn("argMax", n24, t9.rank);
        for(var r33 = bn(t9.shape, n24), o35 = r33[0], a28 = r33[1], i29 = Gn(o35, "int32"), s30 = k(a28), u24 = this.readSync(i29.dataId), c16 = this.readSync(t9.dataId), l20 = 0; l20 < u24.length; ++l20){
            for(var h10 = l20 * s30, f12 = c16[h10], d9 = 0, p12 = 0; p12 < s30; ++p12){
                var v12 = c16[h10 + p12];
                v12 > f12 && (f12 = v12, d9 = p12);
            }
            u24[l20] = d9;
        }
        return i29;
    }, o32.prototype.cumsum = function(t9, e16, n24, r33) {
        if (Hh(t9, "cumsum"), e16 !== t9.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t9.rank - 1) + " but got axis=" + e16);
        for(var o35 = Dt(t9.dtype, "int32"), a28 = Gn(t9.shape, o35), i29 = this.readSync(a28.dataId), s30 = this.readSync(t9.dataId), u24 = t9.shape[t9.rank - 1], c16 = r33 ? function(t10, e17) {
            return t10 + u24 - e17 - 1;
        } : function(t10, e17) {
            return t10 + e17;
        }, l20 = 0; l20 < s30.length; l20 += u24)for(var h11 = 0; h11 < u24; h11++){
            var f13 = c16(l20, h11);
            if (0 === h11) i29[f13] = n24 ? 0 : s30[f13];
            else {
                var d10 = c16(l20, h11 - 1);
                i29[f13] = n24 ? s30[d10] + i29[d10] : s30[f13] + i29[d10];
            }
        }
        return a28;
    }, o32.prototype.equal = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "equal"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 === e17 ? 1 : 0;
        });
    }, o32.prototype.notEqual = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "notEqual"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 !== e17 ? 1 : 0;
        });
    }, o32.prototype.less = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "less"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 < e17 ? 1 : 0;
        });
    }, o32.prototype.lessEqual = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "lessEqual"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 <= e17 ? 1 : 0;
        });
    }, o32.prototype.greater = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "greater"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 > e17 ? 1 : 0;
        });
    }, o32.prototype.greaterEqual = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "greaterEqual"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 >= e17 ? 1 : 0;
        });
    }, o32.prototype.logicalNot = function(t9) {
        Hh(t9, "logicalNot");
        for(var e16 = this.readSync(t9.dataId), n24 = new Uint8Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = e16[r33] ? 0 : 1;
        return this.makeOutput(n24, t9.shape, "bool");
    }, o32.prototype.logicalAnd = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "logicalAnd"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 && e17;
        });
    }, o32.prototype.logicalOr = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "logicalOr"), this.broadcastedBinaryOp(t9, e16, "bool", function(t10, e17) {
            return t10 || e17;
        });
    }, o32.prototype.select = function(t9, e16, n24) {
        Hh([
            t9,
            e16,
            n24
        ], "select");
        for(var r33 = this.readSync(t9.dataId), o35 = this.readSync(e16.dataId), a28 = this.readSync(n24.dataId), i29 = Gn(e16.shape, Dt(e16.dtype, n24.dtype)), s30 = this.readSync(i29.dataId), u24 = 0, c16 = 0 === t9.rank || t9.rank > 1 || 1 === e16.rank ? 1 : k(e16.shape.slice(1)), l20 = 0; l20 < r33.length; l20++)for(var h11 = 0; h11 < c16; h11++)1 === r33[l20] ? s30[u24++] = o35[l20] : s30[u24++] = a28[l20];
        return i29;
    }, o32.prototype.where = function(t9) {
        Hh([
            t9
        ], "where");
        var e16 = this.readSync(t9.dataId);
        return na(t9.shape, e16);
    }, o32.prototype.topk = function(t9, e16, n24) {
        return Hh(t9, "topk"), ea(this.readSync(t9.dataId), t9.shape, t9.dtype, e16);
    }, o32.prototype.min = function(t9, e16) {
        Hh(t9, "min"), Cn("min", e16, t9.rank);
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, t9.dtype), i29 = k(o35), s30 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s30.length; ++c16){
            for(var l20 = c16 * i29, h11 = u24[l20], f14 = 0; f14 < i29; ++f14){
                var d11 = u24[l20 + f14];
                d11 < h11 && (h11 = d11);
            }
            s30[c16] = h11;
        }
        return a28;
    }, o32.prototype.minimum = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "minimum"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            return Math.min(t10, e17);
        });
    }, o32.prototype.mod = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "mod"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            var n24 = t10 % e17;
            return t10 < 0 && e17 < 0 || t10 >= 0 && e17 >= 0 ? n24 : (n24 + e17) % e17;
        });
    }, o32.prototype.max = function(t9, e16) {
        Hh(t9, "max"), Cn("max", e16, t9.rank);
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, t9.dtype), i29 = k(o35), s30 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s30.length; ++c16){
            for(var l21 = c16 * i29, h12 = u24[l21], f15 = 0; f15 < i29; ++f15){
                var d12 = u24[l21 + f15];
                d12 > h12 && (h12 = d12);
            }
            s30[c16] = h12;
        }
        return a28;
    }, o32.prototype.maximum = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "maximum"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            return Math.max(t10, e17);
        });
    }, o32.prototype.all = function(t9, e16) {
        Hh(t9, "all"), Cn("all", e16, t9.rank);
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, t9.dtype), i29 = k(o35), s30 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s30.length; ++c16){
            for(var l22 = c16 * i29, h13 = u24[l22], f16 = 0; f16 < i29; ++f16){
                var d13 = u24[l22 + f16];
                h13 = h13 && d13;
            }
            s30[c16] = h13;
        }
        return a28;
    }, o32.prototype.any = function(t9, e16) {
        Hh(t9, "any"), Cn("any", e16, t9.rank);
        for(var n24 = bn(t9.shape, e16), r33 = n24[0], o35 = n24[1], a28 = Gn(r33, t9.dtype), i29 = k(o35), s30 = this.readSync(a28.dataId), u24 = this.readSync(t9.dataId), c16 = 0; c16 < s30.length; ++c16){
            for(var l23 = c16 * i29, h14 = u24[l23], f17 = 0; f17 < i29; ++f17){
                var d14 = u24[l23 + f17];
                h14 = h14 || d14;
            }
            s30[c16] = h14;
        }
        return a28;
    }, o32.prototype.squaredDifference = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "squaredDifference"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            var n24 = t10 - e17;
            return n24 * n24;
        });
    }, o32.prototype.ceil = function(t9) {
        Hh(t9, "ceil");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = Math.ceil(e16[r33]);
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.floor = function(t9) {
        Hh(t9, "floor");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = Math.floor(e16[r33]);
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.sign = function(t9) {
        Hh(t9, "x");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)e16[r33] < 0 ? n24[r33] = -1 : e16[r33] > 0 ? n24[r33] = 1 : n24[r33] = 0;
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.isNaN = function(t9) {
        Hh(t9, "x");
        for(var e16 = this.readSync(t9.dataId), n24 = new Uint8Array(e16.length), r33 = 0; r33 < e16.length; ++r33)Number.isNaN(e16[r33]) && (n24[r33] = 1);
        return this.makeOutput(n24, t9.shape, "bool");
    }, o32.prototype.isInf = function(t9) {
        Hh(t9, "x");
        for(var e16 = this.readSync(t9.dataId), n24 = new Uint8Array(e16.length), r33 = 0; r33 < e16.length; ++r33)Math.abs(e16[r33]) === 1 / 0 && (n24[r33] = 1);
        return this.makeOutput(n24, t9.shape, "bool");
    }, o32.prototype.isFinite = function(t9) {
        Hh(t9, "x");
        for(var e16 = this.readSync(t9.dataId), n24 = new Uint8Array(e16.length), r33 = 0; r33 < e16.length; ++r33)Number.isFinite(e16[r33]) && (n24[r33] = 1);
        return this.makeOutput(n24, t9.shape, "bool");
    }, o32.prototype.round = function(t9) {
        Hh(t9, "round");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33){
            var o35 = Math.floor(e16[r33]);
            e16[r33] - o35 < 0.5 ? n24[r33] = Math.floor(e16[r33]) : e16[r33] - o35 > 0.5 ? n24[r33] = Math.ceil(e16[r33]) : n24[r33] = o35 % 2 == 0 ? o35 : o35 + 1;
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.exp = function(t9) {
        Hh(t9, "exp");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = Math.exp(e16[r33]);
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.expm1 = function(t9) {
        Hh(t9, "expm1");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = Math.expm1(e16[r33]);
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.log = function(t9) {
        Hh(t9, "log");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33){
            var o36 = e16[r33];
            n24[r33] = Math.log(o36);
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.log1p = function(t9) {
        Hh(t9, "log1p");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33){
            var o37 = e16[r33];
            n24[r33] = Math.log1p(o37);
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.sqrt = function(t9) {
        Hh(t9, "sqrt");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33){
            var o38 = e16[r33];
            n24[r33] = Math.sqrt(o38);
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.rsqrt = function(t9) {
        Hh(t9, "rsqrt");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33){
            var o39 = e16[r33];
            n24[r33] = 1 / Math.sqrt(o39);
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.reciprocal = function(t9) {
        Hh(t9, "reciprocal");
        for(var e16 = this.readSync(t9.dataId), n24 = new Float32Array(e16.length), r33 = 0; r33 < e16.length; ++r33)n24[r33] = 1 / e16[r33];
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.linear = function(t9) {
        return t9;
    }, o32.prototype.relu = function(t9) {
        Hh(t9, "relu");
        for(var e16 = Gn(t9.shape, t9.dtype), n24 = this.readSync(e16.dataId), r33 = this.readSync(t9.dataId), o40 = 0; o40 < r33.length; ++o40)n24[o40] = Math.max(0, r33[o40]);
        return e16;
    }, o32.prototype.relu6 = function(t9) {
        Hh(t9, "relu");
        for(var e16 = Gn(t9.shape, t9.dtype), n24 = this.readSync(e16.dataId), r33 = this.readSync(t9.dataId), o40 = 0; o40 < r33.length; ++o40)n24[o40] = Math.min(Math.max(0, r33[o40]), 6);
        return e16;
    }, o32.prototype.prelu = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "prelu"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            return t10 < 0 ? e17 * t10 : t10;
        });
    }, o32.prototype.elu = function(t9) {
        Hh(t9, "elu");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33){
            var o40 = n24[r33];
            e16[r33] = o40 >= 0 ? o40 : Math.exp(o40) - 1;
        }
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.eluDer = function(t9, e16) {
        Hh([
            t9,
            e16
        ], "eluDer");
        for(var n24 = new Float32Array(e16.size), r33 = this.readSync(e16.dataId), o41 = this.readSync(t9.dataId), a28 = 0; a28 < r33.length; ++a28){
            var i29 = r33[a28];
            n24[a28] = i29 >= 1 ? o41[a28] : o41[a28] * (i29 + 1);
        }
        return this.makeOutput(n24, e16.shape, "float32");
    }, o32.prototype.selu = function(t9) {
        Hh(t9, "selu");
        for(var e16 = bs, n24 = ws, r33 = new Float32Array(t9.size), o41 = this.readSync(t9.dataId), a28 = 0; a28 < o41.length; ++a28){
            var i30 = o41[a28];
            r33[a28] = i30 >= 0 ? n24 * i30 : e16 * (Math.exp(i30) - 1);
        }
        return this.makeOutput(r33, t9.shape, "float32");
    }, o32.prototype.clip = function(t9, e16, n24) {
        Hh(t9, "clip");
        for(var r33 = new Float32Array(t9.size), o41 = this.readSync(t9.dataId), a28 = 0; a28 < o41.length; ++a28){
            var i31 = o41[a28];
            r33[a28] = i31 > n24 ? n24 : i31 < e16 ? e16 : i31;
        }
        return this.makeOutput(r33, t9.shape, "float32");
    }, o32.prototype.abs = function(t9) {
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.abs(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.complexAbs = function(t9) {
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < t9.size; ++r33){
            var o41 = n24[2 * r33], a28 = n24[2 * r33 + 1];
            e16[r33] = Math.hypot(o41, a28);
        }
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.int = function(t9) {
        Hh(t9, "int");
        for(var e16 = new Int32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = n24[r33];
        return this.makeOutput(e16, t9.shape, "int32");
    }, o32.prototype.sigmoid = function(t9) {
        Hh(t9, "sigmoid");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = 1 / (1 + Math.exp(-n24[r33]));
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.softplus = function(t9) {
        Hh(t9, "softplus");
        for(var e16 = Math.log(0.00000011920928955078125) + 2, n24 = new Float32Array(t9.size), r33 = this.readSync(t9.dataId), o42 = 0; o42 < r33.length; ++o42){
            var a29 = r33[o42] > -e16, i32 = r33[o42] < e16, s30 = Math.exp(r33[o42]), u24 = void 0;
            u24 = i32 ? s30 : a29 ? r33[o42] : Math.log(1 + s30), n24[o42] = u24;
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.sin = function(t9) {
        Hh(t9, "sin");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.sin(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.cos = function(t9) {
        Hh(t9, "cos");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.cos(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.tan = function(t9) {
        Hh(t9, "tan");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.tan(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.asin = function(t9) {
        Hh(t9, "asin");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.asin(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.acos = function(t9) {
        Hh(t9, "acos");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.acos(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.atan = function(t9) {
        Hh(t9, "atan");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.atan(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.atan2 = function(t9, e16) {
        return Hh([
            t9,
            e16
        ], "atan2"), this.broadcastedBinaryOp(t9, e16, t9.dtype, function(t10, e17) {
            return Math.atan2(t10, e17);
        });
    }, o32.prototype.sinh = function(t9) {
        Hh(t9, "sinh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.sinh(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.cosh = function(t9) {
        Hh(t9, "cosh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.cosh(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.tanh = function(t9) {
        Hh(t9, "tanh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = D(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.asinh = function(t9) {
        Hh(t9, "asinh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.asinh(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.acosh = function(t9) {
        Hh(t9, "acosh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.acosh(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.atanh = function(t9) {
        Hh(t9, "atanh");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33)e16[r33] = Math.atanh(n24[r33]);
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.erf = function(t9) {
        Hh(t9, "erf");
        for(var e16 = new Float32Array(t9.size), n24 = this.readSync(t9.dataId), r33 = 0; r33 < n24.length; ++r33){
            var o42 = Math.sign(n24[r33]), a30 = Math.abs(n24[r33]), i33 = 1 / (1 + 0.3275911 * a30);
            e16[r33] = o42 * (1 - ((((1.061405429 * i33 - 1.453152027) * i33 + 1.421413741) * i33 - 0.284496736) * i33 + 0.254829592) * i33 * Math.exp(-a30 * a30));
        }
        return this.makeOutput(e16, t9.shape, "float32");
    }, o32.prototype.step = function(t9, e16) {
        (void 0) === e16 && (e16 = 0), Hh(t9, "step");
        for(var n24 = new Float32Array(t9.size), r33 = this.readSync(t9.dataId), o43 = 0; o43 < r33.length; ++o43){
            var a31 = r33[o43];
            isNaN(a31) ? n24[o43] = NaN : n24[o43] = a31 > 0 ? 1 : e16;
        }
        return this.makeOutput(n24, t9.shape, "float32");
    }, o32.prototype.fusedConv2d = function(t9) {
        var e16 = t9.input, n24 = t9.filter, r33 = t9.convInfo, o43 = t9.bias, a32 = t9.activation, i34 = t9.preluActivationWeights, s31 = this.conv2d(e16, n24, r33);
        return o43 && (s31 = this.add(s31, o43)), a32 && (s31 = qh(this, s31, a32, i34)), s31;
    }, o32.prototype.conv2d = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "conv2d");
        for(var r33 = n24.filterHeight, o43 = n24.filterWidth, a32 = n24.dilationHeight, i34 = n24.dilationWidth, s31 = n24.padInfo.left, u25 = n24.padInfo.top, c16 = "channelsLast" === n24.dataFormat, l24 = dr(n24.outShape, t9.dtype), h15 = t9.strides[0], f18 = c16 ? t9.strides[1] : t9.strides[2], d15 = c16 ? t9.strides[2] : 1, p13 = c16 ? 1 : t9.strides[1], v13 = l24.strides[0], m12 = c16 ? l24.strides[1] : l24.strides[2], g11 = c16 ? l24.strides[2] : 1, y8 = c16 ? 1 : l24.strides[1], x7 = this.readSync(t9.dataId), b4 = this.readSync(e16.dataId), w3 = l24.values, C1 = 0; C1 < n24.batchSize; ++C1)for(var E1 = C1 * h15, R1 = C1 * v13, I1 = 0; I1 < n24.outHeight; ++I1)for(var k1 = R1 + I1 * m12, S1 = I1 * n24.strideHeight - u25, A1 = 0; A1 < r33; A1++){
            var D1 = S1 + A1 * a32;
            if (!(D1 < 0 || D1 >= n24.inHeight)) for(var T1 = A1 * e16.strides[0], N2 = E1 + D1 * f18, F2 = 0; F2 < n24.outWidth; ++F2)for(var _1 = k1 + F2 * g11, O1 = F2 * n24.strideWidth - s31, M1 = 0; M1 < o43; M1++){
                var B1 = O1 + M1 * i34;
                if (!(B1 < 0 || B1 >= n24.inWidth)) for(var P1 = N2 + B1 * d15, L1 = T1 + M1 * e16.strides[1], W1 = 0; W1 < n24.inChannels; ++W1){
                    for(var U1 = x7[P1 + W1 * p13], V1 = 0; V1 < n24.outChannels; ++V1)w3[_1 + V1 * y8] += U1 * b4[L1 + V1];
                    L1 += n24.outChannels;
                }
            }
        }
        return l24.toTensor();
    }, o32.prototype.conv3d = function(t9, e16, n24) {
        for(var r33 = n24.filterDepth, o43 = n24.filterHeight, a32 = n24.filterWidth, i34 = n24.dilationDepth, s31 = n24.dilationHeight, u25 = n24.dilationWidth, c16 = n24.padInfo.front, l24 = n24.padInfo.left, h15 = n24.padInfo.top, f18 = dr(n24.outShape, t9.dtype), d15 = this.readSync(t9.dataId), p13 = this.readSync(e16.dataId), v13 = f18.values, m12 = 0; m12 < n24.batchSize; ++m12)for(var g11 = m12 * t9.strides[0], y8 = m12 * f18.strides[0], x7 = 0; x7 < n24.outDepth; ++x7)for(var b4 = y8 + x7 * f18.strides[1], w3 = x7 * n24.strideDepth - c16, C1 = 0; C1 < r33; C1++){
            var E1 = w3 + C1 * i34;
            if (!(E1 < 0 || E1 >= n24.inDepth)) for(var R1 = C1 * e16.strides[0], I1 = g11 + E1 * t9.strides[1], k1 = 0; k1 < n24.outHeight; ++k1)for(var S1 = b4 + k1 * f18.strides[2], A1 = k1 * n24.strideHeight - h15, D2 = 0; D2 < o43; D2++){
                var T2 = A1 + D2 * s31;
                if (!(T2 < 0 || T2 >= n24.inHeight)) for(var N3 = R1 + D2 * e16.strides[1], F3 = I1 + T2 * t9.strides[2], _2 = 0; _2 < n24.outWidth; ++_2)for(var O2 = S1 + _2 * n24.outChannels, M2 = _2 * n24.strideWidth - l24, B2 = 0; B2 < a32; B2++){
                    var P2 = M2 + B2 * u25;
                    if (!(P2 < 0 || P2 >= n24.inWidth)) for(var L2 = N3 + B2 * e16.strides[2], W2 = F3 + P2 * n24.inChannels, U2 = L2, V2 = 0; V2 < n24.inChannels; ++V2){
                        for(var z1 = d15[W2 + V2], G1 = 0; G1 < n24.outChannels; ++G1)v13[O2 + G1] += z1 * p13[U2 + G1];
                        U2 += n24.outChannels;
                    }
                }
            }
        }
        return f18.toTensor();
    }, o32.prototype.conv2dDerInput = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "conv2dDerInput");
        for(var r33 = dr(n24.inShape, "float32"), o43 = r33.values, a32 = this.readSync(t9.dataId), i34 = this.readSync(e16.dataId), s31 = e16.strides, u25 = s31[0], c16 = s31[1], l24 = s31[2], h15 = n24.batchSize, f18 = n24.filterHeight, d15 = n24.filterWidth, p13 = n24.inChannels, v13 = n24.inHeight, m12 = n24.inWidth, g11 = n24.outChannels, y8 = n24.outHeight, x7 = n24.outWidth, b4 = n24.strideHeight, w3 = n24.strideWidth, C1 = n24.dataFormat, E3 = f18 - 1 - n24.padInfo.top, R3 = d15 - 1 - n24.padInfo.left, I2 = "channelsLast" === C1, k2 = r33.strides[0], S2 = I2 ? r33.strides[1] : r33.strides[2], A2 = I2 ? r33.strides[2] : 1, D3 = I2 ? 1 : r33.strides[1], T3 = t9.strides[0], N4 = I2 ? t9.strides[1] : t9.strides[2], F4 = I2 ? t9.strides[2] : 1, _3 = I2 ? 1 : t9.strides[1], O3 = 0; O3 < h15; ++O3)for(var M3 = 0; M3 < p13; ++M3)for(var B3 = 0; B3 < v13; ++B3)for(var P3 = B3 - E3, L3 = Math.max(0, Math.ceil(P3 / b4)), W3 = Math.min(y8, (f18 + P3) / b4), U3 = 0; U3 < m12; ++U3){
            for(var V3 = U3 - R3, z2 = Math.max(0, Math.ceil(V3 / w3)), G2 = Math.min(x7, (d15 + V3) / w3), H1 = 0, q1 = L3; q1 < W3; ++q1)for(var K1 = q1 * b4 - P3, j1 = z2; j1 < G2; ++j1)for(var X1 = T3 * O3 + N4 * q1 + F4 * j1, Y1 = u25 * (f18 - 1 - K1) + c16 * (d15 - 1 - (j1 * w3 - V3)) + l24 * M3, $1 = 0; $1 < g11; ++$1)H1 += a32[X1 + _3 * $1] * i34[Y1 + $1];
            o43[k2 * O3 + S2 * B3 + A2 * U3 + D3 * M3] = H1;
        }
        return r33.toTensor();
    }, o32.prototype.conv3dDerInput = function(t9, e16, n24) {
        for(var r33 = dr(n24.inShape, "float32"), o43 = r33.values, a32 = r33.strides, i34 = a32[0], s31 = a32[1], u25 = a32[2], c16 = a32[3], l24 = this.readSync(t9.dataId), h15 = t9.strides, f18 = h15[0], d15 = h15[1], p13 = h15[2], v13 = h15[3], m12 = this.readSync(e16.dataId), g11 = e16.strides, y8 = g11[0], x7 = g11[1], b4 = g11[2], w3 = g11[3], C1 = n24.batchSize, E3 = n24.filterDepth, R3 = n24.filterHeight, I2 = n24.filterWidth, k2 = n24.inChannels, S2 = n24.inDepth, A2 = n24.inHeight, D3 = n24.inWidth, T3 = n24.outChannels, N4 = n24.outDepth, F4 = n24.outHeight, _3 = n24.outWidth, O3 = n24.strideDepth, M3 = n24.strideHeight, B3 = n24.strideWidth, P3 = E3 - 1 - n24.padInfo.front, L3 = R3 - 1 - n24.padInfo.top, W3 = I2 - 1 - n24.padInfo.left, U3 = 0; U3 < C1; ++U3)for(var V4 = 0; V4 < k2; ++V4)for(var z3 = 0; z3 < S2; ++z3)for(var G3 = z3 - P3, H2 = Math.max(0, Math.ceil(G3 / O3)), q2 = Math.min(N4, (E3 + G3) / O3), K2 = 0; K2 < A2; ++K2)for(var j2 = K2 - L3, X2 = Math.max(0, Math.ceil(j2 / M3)), Y2 = Math.min(F4, (R3 + j2) / M3), $2 = 0; $2 < D3; ++$2){
            for(var Q1 = $2 - W3, J1 = Math.max(0, Math.ceil(Q1 / B3)), Z1 = Math.min(_3, (I2 + Q1) / B3), tt1 = 0, et1 = H2; et1 < q2; ++et1)for(var nt1 = et1 * O3 - G3, rt1 = X2; rt1 < Y2; ++rt1)for(var ot1 = rt1 * M3 - j2, at1 = J1; at1 < Z1; ++at1)for(var it1 = f18 * U3 + d15 * et1 + p13 * rt1 + v13 * at1, st1 = y8 * (E3 - 1 - nt1) + x7 * (R3 - 1 - ot1) + b4 * (I2 - 1 - (at1 * B3 - Q1)) + w3 * V4, ut1 = 0; ut1 < T3; ++ut1)tt1 += l24[it1 + ut1] * m12[st1 + ut1];
            o43[i34 * U3 + s31 * z3 + u25 * K2 + c16 * $2 + V4] = tt1;
        }
        return r33.toTensor();
    }, o32.prototype.conv2dDerFilter = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "conv2dDerFilter");
        for(var r33 = n24.strideHeight, o43 = n24.strideWidth, a32 = n24.filterHeight, i34 = n24.filterWidth, s31 = "channelsLast" === n24.dataFormat, u25 = dr(n24.filterShape, "float32"), c16 = n24.padInfo.left, l24 = n24.padInfo.top, h15 = this.bufferSync(t9), f18 = this.bufferSync(e16), d15 = 0; d15 < a32; ++d15)for(var p13 = Math.max(0, Math.ceil((l24 - d15) / r33)), v13 = Math.min(n24.outHeight, (n24.inHeight + l24 - d15) / r33), m12 = 0; m12 < i34; ++m12)for(var g11 = Math.max(0, Math.ceil((c16 - m12) / o43)), y8 = Math.min(n24.outWidth, (n24.inWidth + c16 - m12) / o43), x7 = 0; x7 < n24.inChannels; ++x7)for(var b4 = 0; b4 < n24.outChannels; ++b4){
            for(var w3 = 0, C1 = 0; C1 < n24.batchSize; ++C1)for(var E3 = p13; E3 < v13; ++E3)for(var R3 = d15 + E3 * r33 - l24, I2 = g11; I2 < y8; ++I2){
                var k2 = m12 + I2 * o43 - c16;
                w3 += s31 ? h15.get(C1, R3, k2, x7) * f18.get(C1, E3, I2, b4) : h15.get(C1, x7, R3, k2) * f18.get(C1, b4, E3, I2);
            }
            u25.set(w3, d15, m12, x7, b4);
        }
        return u25.toTensor();
    }, o32.prototype.conv3dDerFilter = function(t9, e16, n24) {
        for(var r33 = n24.strideDepth, o43 = n24.strideHeight, a32 = n24.strideWidth, i34 = n24.filterDepth, s31 = n24.filterHeight, u25 = n24.filterWidth, c16 = dr(n24.filterShape, "float32"), l24 = c16.values, h15 = c16.strides, f18 = h15[0], d15 = h15[1], p13 = h15[2], v13 = h15[3], m12 = this.readSync(e16.dataId), g11 = e16.strides, y8 = g11[0], x7 = g11[1], b4 = g11[2], w4 = g11[3], C2 = this.readSync(t9.dataId), E4 = t9.strides, R4 = E4[0], I3 = E4[1], k3 = E4[2], S2 = E4[3], A2 = n24.padInfo.front, D3 = n24.padInfo.left, T3 = n24.padInfo.top, N4 = 0; N4 < i34; ++N4)for(var F4 = Math.max(0, Math.ceil((A2 - N4) / r33)), _3 = Math.min(n24.outDepth, (n24.inDepth + A2 - N4) / r33), O3 = N4 * f18, M3 = 0; M3 < s31; ++M3)for(var B3 = Math.max(0, Math.ceil((T3 - M3) / o43)), P3 = Math.min(n24.outHeight, (n24.inHeight + T3 - M3) / o43), L3 = M3 * d15 + O3, W3 = 0; W3 < u25; ++W3)for(var U3 = Math.max(0, Math.ceil((D3 - W3) / a32)), V4 = Math.min(n24.outWidth, (n24.inWidth + D3 - W3) / a32), z3 = W3 * p13 + L3, G3 = 0; G3 < n24.inChannels; ++G3)for(var H2 = G3 * v13 + z3, q2 = 0; q2 < n24.outChannels; ++q2){
            for(var K2 = 0, j2 = 0; j2 < n24.batchSize; ++j2)for(var X2 = j2 * R4, Y2 = j2 * y8, $2 = F4; $2 < _3; ++$2)for(var Q2 = (N4 + $2 * r33 - A2) * I3 + X2, J2 = $2 * x7 + Y2, Z2 = B3; Z2 < P3; ++Z2)for(var tt2 = (M3 + Z2 * o43 - T3) * k3 + Q2, et2 = Z2 * b4 + J2, nt2 = U3; nt2 < V4; ++nt2){
                var rt2 = nt2 * w4 + et2;
                K2 += C2[(W3 + nt2 * a32 - D3) * S2 + tt2 + G3] * m12[rt2 + q2];
            }
            l24[H2 + q2] = K2;
        }
        return c16.toTensor();
    }, o32.prototype.fusedDepthwiseConv2D = function(t9) {
        var e16 = t9.input, n24 = t9.filter, r33 = t9.convInfo, o43 = t9.bias, a32 = t9.activation, i34 = t9.preluActivationWeights, s31 = this.depthwiseConv2D(e16, n24, r33);
        return o43 && (s31 = this.add(s31, o43)), a32 && (s31 = qh(this, s31, a32, i34)), s31;
    }, o32.prototype.depthwiseConv2D = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "depthwiseConv2D");
        for(var r33 = n24.filterHeight, o43 = n24.filterWidth, a32 = n24.dilationHeight, i34 = n24.dilationWidth, s31 = n24.padInfo.left, u25 = n24.padInfo.top, c16 = n24.outChannels / n24.inChannels, l24 = dr(n24.outShape, t9.dtype), h15 = this.readSync(t9.dataId), f18 = this.readSync(e16.dataId), d15 = l24.values, p13 = 0; p13 < n24.batchSize; ++p13)for(var v13 = p13 * t9.strides[0], m12 = p13 * l24.strides[0], g11 = 0; g11 < n24.outHeight; ++g11)for(var y8 = m12 + g11 * l24.strides[1], x7 = g11 * n24.strideHeight - s31, b4 = 0; b4 < r33; ++b4){
            var w4 = x7 + b4 * a32;
            if (!(w4 < 0 || w4 >= n24.inHeight)) for(var C2 = b4 * e16.strides[0], E4 = v13 + w4 * t9.strides[1], R4 = 0; R4 < n24.outWidth; ++R4)for(var I3 = y8 + R4 * l24.strides[2], k3 = R4 * n24.strideWidth - u25, S2 = 0; S2 < o43; ++S2){
                var A2 = k3 + S2 * i34;
                if (!(A2 < 0 || A2 >= n24.inWidth)) for(var D3 = C2 + S2 * e16.strides[1], T3 = E4 + A2 * n24.inChannels, N4 = I3, F4 = D3, _3 = 0; _3 < n24.inChannels; ++_3){
                    for(var O3 = h15[T3 + _3], M3 = 0; M3 < c16; ++M3)d15[N4 + M3] += O3 * f18[F4 + M3];
                    N4 += c16, F4 += c16;
                }
            }
        }
        return l24.toTensor();
    }, o32.prototype.depthwiseConv2DDerInput = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "depthwiseConv2DDerInput");
        for(var r33 = dr(n24.inShape, "float32"), o43 = r33.values, a32 = r33.strides, i34 = a32[0], s31 = a32[1], u25 = a32[2], c16 = this.readSync(t9.dataId), l24 = t9.strides, h15 = l24[0], f18 = l24[1], d15 = l24[2], p13 = this.readSync(e16.dataId), v13 = e16.strides, m12 = v13[0], g11 = v13[1], y8 = v13[2], x7 = n24.batchSize, b4 = n24.filterHeight, w5 = n24.filterWidth, C3 = n24.inChannels, E5 = n24.inHeight, R5 = n24.inWidth, I4 = n24.outChannels, k4 = n24.outHeight, S3 = n24.outWidth, A3 = n24.strideHeight, D4 = n24.strideWidth, T4 = b4 - 1 - n24.padInfo.top, N5 = w5 - 1 - n24.padInfo.left, F5 = I4 / C3, _4 = 0; _4 < x7; ++_4)for(var O4 = 0; O4 < C3; ++O4)for(var M4 = 0; M4 < E5; ++M4)for(var B3 = M4 - T4, P3 = Math.max(0, Math.ceil(B3 / A3)), L3 = Math.min(k4, (b4 + B3) / A3), W3 = 0; W3 < R5; ++W3){
            for(var U3 = W3 - N5, V4 = Math.max(0, Math.ceil(U3 / D4)), z3 = Math.min(S3, (w5 + U3) / D4), G3 = 0, H2 = P3; H2 < L3; ++H2)for(var q2 = H2 * A3 - B3, K3 = V4; K3 < z3; ++K3)for(var j3 = h15 * _4 + f18 * H2 + d15 * K3, X3 = m12 * (b4 - 1 - q2) + g11 * (w5 - 1 - (K3 * D4 - U3)) + y8 * O4, Y3 = 0; Y3 < F5; ++Y3)G3 += c16[j3 + (O4 * F5 + Y3)] * p13[X3 + Y3];
            o43[i34 * _4 + s31 * M4 + u25 * W3 + O4] = G3;
        }
        return r33.toTensor();
    }, o32.prototype.depthwiseConv2DDerFilter = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "depthwiseConv2DDerFilter");
        for(var r33 = n24.strideHeight, o43 = n24.strideWidth, a32 = n24.filterHeight, i34 = n24.filterWidth, s31 = dr(n24.filterShape, "float32"), u25 = n24.padInfo.left, c16 = n24.padInfo.top, l24 = n24.outChannels / n24.inChannels, h15 = this.bufferSync(t9), f18 = this.bufferSync(e16), d15 = 0; d15 < a32; ++d15)for(var p13 = Math.max(0, Math.ceil((c16 - d15) / r33)), v13 = Math.min(n24.outHeight, (n24.inHeight + c16 - d15) / r33), m12 = 0; m12 < i34; ++m12)for(var g11 = Math.max(0, Math.ceil((u25 - m12) / o43)), y8 = Math.min(n24.outWidth, (n24.inWidth + u25 - m12) / o43), x7 = 0; x7 < n24.outChannels; ++x7){
            for(var b4 = Math.trunc(x7 / l24), w5 = x7 % l24, C3 = 0, E5 = 0; E5 < n24.batchSize; ++E5)for(var R5 = p13; R5 < v13; ++R5)for(var I4 = d15 + R5 * r33 - c16, k4 = g11; k4 < y8; ++k4){
                var S3 = m12 + k4 * o43 - u25;
                C3 += h15.get(E5, I4, S3, b4) * f18.get(E5, R5, k4, x7);
            }
            s31.set(C3, d15, m12, b4, w5);
        }
        return s31.toTensor();
    }, o32.prototype.tile = function(t9, e16) {
        return Hh(t9, "tile"), ta(this.bufferSync(t9), e16);
    }, o32.prototype.pad = function(t9, e16, n24) {
        Hh(t9, "pad");
        var r33 = e16.map(function(e17, n25) {
            return e17[0] + t9.shape[n25] + e17[1];
        }), o43 = e16.map(function(t10) {
            return t10[0];
        }), a32 = this.bufferSync(t9), i34 = dr(r33, t9.dtype);
        0 !== n24 && i34.values.fill(n24);
        for(var s31 = 0; s31 < t9.size; s31++){
            var u25 = a32.indexToLoc(s31), c16 = u25.map(function(t10, e17) {
                return t10 + o43[e17];
            });
            i34.set.apply(i34, [
                a32.get.apply(a32, u25)
            ].concat(c16));
        }
        return i34.toTensor();
    }, o32.prototype.transpose = function(t9, e16) {
        Hh(t9, "transpose");
        for(var n24 = new Array(t9.rank), r33 = 0; r33 < n24.length; r33++)n24[r33] = t9.shape[e16[r33]];
        var o43 = this.readSync(t9.dataId), a32 = dr(n24, t9.dtype), i34 = this.bufferSync(t9);
        for(r33 = 0; r33 < t9.size; ++r33){
            for(var s31 = i34.indexToLoc(r33), u26 = new Array(s31.length), c17 = 0; c17 < u26.length; c17++)u26[c17] = s31[e16[c17]];
            var l24 = a32.locToIndex(u26);
            a32.values[l24] = o43[r33];
        }
        return a32.toTensor();
    }, o32.prototype.gather = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "gather");
        var r33 = t9.shape.slice(), o43 = this.readSync(e16.dataId);
        r33[n24] = o43.length;
        for(var a32 = dr(r33, t9.dtype), i34 = this.bufferSync(t9), s32 = 0; s32 < a32.size; ++s32){
            var u27 = a32.indexToLoc(s32), c18 = u27.slice();
            c18[n24] = o43[u27[n24]];
            var l25 = i34.locToIndex(c18);
            a32.values[s32] = i34.values[l25];
        }
        return a32.toTensor();
    }, o32.prototype.batchToSpaceND = function(t9, e16, n24) {
        Hh([
            t9
        ], "batchToSpaceND");
        var r33 = e16.reduce(function(t10, e17) {
            return t10 * e17;
        }), o43 = zr(t9.shape, e16, r33), a32 = Gr(o43.length, e16.length), i34 = Hr(t9.shape, e16, r33), s32 = qr(n24, e16.length), u28 = Kr(i34, n24, e16.length);
        return t9.reshape(o43).transpose(a32).reshape(i34).slice(s32, u28);
    }, o32.prototype.spaceToBatchND = function(t9, e16, n24) {
        Hh([
            t9
        ], "spaceToBatchND");
        var r33 = e16.reduce(function(t10, e17) {
            return t10 * e17;
        }), o43 = [
            [
                0,
                0
            ]
        ];
        o43.push.apply(o43, n24);
        for(var a32 = 1 + e16.length; a32 < t9.shape.length; ++a32)o43.push([
            0,
            0
        ]);
        var i34 = t9.pad(o43), s32 = zr(i34.shape, e16, r33, !1), u28 = Gr(s32.length, e16.length, !1), c19 = Hr(i34.shape, e16, r33, !1);
        return i34.reshape(s32).transpose(u28).reshape(c19);
    }, o32.prototype.pool = function(t9, e16, n24) {
        Hh(t9, "pool");
        for(var r33 = e16.strideHeight, o43 = e16.strideWidth, a32 = e16.dilationHeight, i34 = e16.dilationWidth, s32 = e16.effectiveFilterHeight, u28 = e16.effectiveFilterWidth, c19 = e16.padInfo.top, l26 = e16.padInfo.left, h15 = "max" === n24 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f18 = this.readSync(t9.dataId), d15 = dr(e16.outShape, t9.dtype), p13 = d15.values, v13 = e16.outShape[1] * e16.outShape[2] * e16.outShape[3], m12 = e16.outShape[2] * e16.outShape[3], g11 = e16.outShape[3], y8 = 0; y8 < e16.batchSize; ++y8)for(var x7 = y8 * v13, b5 = y8 * t9.strides[0], w6 = 0; w6 < e16.inChannels; ++w6)for(var C4 = 0; C4 < e16.outHeight; ++C4)for(var E6 = C4 * r33 - c19, R6 = Math.max(0, E6), I5 = Math.min(e16.inHeight, s32 + E6), k5 = x7 + C4 * m12, S4 = 0; S4 < e16.outWidth; ++S4){
            for(var A3 = S4 * o43 - l26, D4 = Math.max(0, A3), T4 = Math.min(e16.inWidth, u28 + A3), N5 = h15, F5 = 0, _4 = 0, O4 = R6; O4 < I5; O4 += a32){
                for(var M4 = b5 + O4 * t9.strides[1], B3 = D4; B3 < T4; B3 += i34){
                    var P3 = f18[M4 + B3 * t9.strides[2] + w6];
                    "max" === n24 && P3 > N5 ? N5 = P3 : "avg" === n24 && (F5 += P3, _4++);
                }
                if (isNaN(N5)) break;
            }
            p13[k5 + S4 * g11 + w6] = "avg" === n24 ? F5 / _4 : N5;
        }
        return d15.toTensor();
    }, o32.prototype.maxPool = function(t9, e16) {
        return this.pool(t9, e16, "max");
    }, o32.prototype.maxPoolPositions = function(t9, e16) {
        for(var n24 = dr(e16.outShape, "int32"), r33 = e16.strideHeight, o43 = e16.strideWidth, a32 = e16.dilationHeight, i34 = e16.dilationWidth, s32 = e16.effectiveFilterHeight, u28 = e16.effectiveFilterWidth, c19 = e16.padInfo.top, l26 = e16.padInfo.left, h15 = this.bufferSync(t9), f18 = 0; f18 < e16.batchSize; ++f18)for(var d15 = 0; d15 < e16.inChannels; ++d15)for(var p13 = 0; p13 < e16.outHeight; ++p13){
            for(var v13 = p13 * r33 - c19, m12 = v13; m12 < 0;)m12 += a32;
            for(var g11 = Math.min(e16.inHeight, s32 + v13), y8 = 0; y8 < e16.outWidth; ++y8){
                for(var x7 = y8 * o43 - l26, b5 = x7; b5 < 0;)b5 += i34;
                for(var w6 = Math.min(e16.inWidth, u28 + x7), C4 = Number.NEGATIVE_INFINITY, E6 = -1, R6 = m12; R6 < g11; R6 += a32)for(var I5 = R6 - v13, k5 = b5; k5 < w6; k5 += i34){
                    var S4 = k5 - x7, A4 = h15.get(f18, R6, k5, d15);
                    A4 > C4 && (C4 = A4, E6 = I5 * u28 + S4);
                }
                n24.set(E6, f18, p13, y8, d15);
            }
        }
        return n24.toTensor();
    }, o32.prototype.maxPoolBackprop = function(t9, e16, n24, r33) {
        Hh([
            e16,
            n24
        ], "maxPoolBackprop");
        for(var o43 = this.maxPoolPositions(e16, r33), a32 = r33.strideHeight, i34 = r33.strideWidth, s32 = r33.dilationHeight, u28 = r33.dilationWidth, c19 = r33.effectiveFilterHeight, l26 = r33.effectiveFilterWidth, h15 = l26 - 1 - r33.padInfo.left, f18 = c19 - 1 - r33.padInfo.top, d15 = dr(e16.shape, "float32"), p13 = this.bufferSync(o43), v14 = this.bufferSync(t9), m13 = 0; m13 < r33.batchSize; ++m13)for(var g12 = 0; g12 < r33.inChannels; ++g12)for(var y9 = 0; y9 < r33.inHeight; ++y9)for(var x8 = 0; x8 < r33.inWidth; ++x8){
            for(var b6 = y9 - f18, w7 = x8 - h15, C5 = 0, E7 = 0; E7 < c19; E7 += s32){
                var R7 = (b6 + E7) / a32;
                if (!(R7 < 0 || R7 >= r33.outHeight || Math.floor(R7) !== R7)) for(var I6 = 0; I6 < l26; I6 += u28){
                    var k6 = (w7 + I6) / i34;
                    if (!(k6 < 0 || k6 >= r33.outWidth || Math.floor(k6) !== k6)) {
                        var S5 = c19 * l26 - 1 - p13.get(m13, R7, k6, g12) === E7 * l26 + I6 ? 1 : 0;
                        if (0 !== S5) C5 += v14.get(m13, R7, k6, g12) * S5;
                    }
                }
            }
            d15.set(C5, m13, y9, x8, g12);
        }
        return d15.toTensor();
    }, o32.prototype.avgPoolBackprop = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "avgPoolBackprop");
        for(var r33 = n24.strideHeight, o43 = n24.strideWidth, a32 = n24.filterHeight, i34 = n24.filterWidth, s32 = n24.dilationHeight, u28 = n24.dilationWidth, c19 = n24.effectiveFilterHeight, l26 = n24.effectiveFilterWidth, h15 = l26 - 1 - n24.padInfo.left, f18 = c19 - 1 - n24.padInfo.top, d15 = dr(e16.shape, "float32"), p13 = 1 / (a32 * i34), v14 = this.bufferSync(t9), m13 = 0; m13 < n24.batchSize; ++m13)for(var g12 = 0; g12 < n24.inChannels; ++g12)for(var y9 = 0; y9 < n24.inHeight; ++y9)for(var x8 = 0; x8 < n24.inWidth; ++x8){
            for(var b7 = y9 - f18, w8 = x8 - h15, C6 = 0, E8 = 0; E8 < c19; E8 += s32){
                var R8 = (b7 + E8) / r33;
                if (!(R8 < 0 || R8 >= n24.outHeight || Math.floor(R8) !== R8)) for(var I7 = 0; I7 < l26; I7 += u28){
                    var k7 = (w8 + I7) / o43;
                    if (!(k7 < 0 || k7 >= n24.outWidth || Math.floor(k7) !== k7)) C6 += v14.get(m13, R8, k7, g12);
                }
            }
            d15.set(C6 * p13, m13, y9, x8, g12);
        }
        return d15.toTensor();
    }, o32.prototype.pool3d = function(t9, e16, n24) {
        Hh(t9, "pool3d");
        for(var r33 = e16.strideDepth, o43 = e16.strideHeight, a32 = e16.strideWidth, i34 = e16.dilationDepth, s32 = e16.dilationHeight, u28 = e16.dilationWidth, c19 = e16.effectiveFilterDepth, l26 = e16.effectiveFilterHeight, h15 = e16.effectiveFilterWidth, f18 = e16.padInfo.front, d15 = e16.padInfo.top, p13 = e16.padInfo.left, v14 = "max" === n24 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m13 = this.readSync(t9.dataId), g12 = dr(e16.outShape, t9.dtype), y9 = g12.values, x8 = e16.outShape[1] * e16.outShape[2] * e16.outShape[3] * e16.outShape[4], b8 = e16.outShape[2] * e16.outShape[3] * e16.outShape[4], w9 = e16.outShape[3] * e16.outShape[4], C7 = e16.outShape[4], E9 = 0; E9 < e16.batchSize; ++E9)for(var R9 = E9 * x8, I8 = E9 * t9.strides[0], k8 = 0; k8 < e16.inChannels; ++k8)for(var S6 = 0; S6 < e16.outDepth; ++S6){
            for(var A5 = S6 * r33 - f18, D5 = A5; D5 < 0;)D5 += i34;
            for(var T5 = Math.min(e16.inDepth, c19 + A5), N6 = R9 + S6 * b8, F6 = 0; F6 < e16.outHeight; ++F6){
                for(var _5 = F6 * o43 - d15, O5 = _5; O5 < 0;)O5 += s32;
                for(var M5 = Math.min(e16.inHeight, l26 + _5), B4 = N6 + F6 * w9, P4 = 0; P4 < e16.outWidth; ++P4){
                    for(var L3 = P4 * a32 - p13, W3 = L3; W3 < 0;)W3 += u28;
                    for(var U4 = Math.min(e16.inWidth, h15 + L3), V5 = B4 + P4 * C7, z4 = v14, G4 = 0, H3 = 0, q3 = D5; q3 < T5; q3 += i34){
                        for(var K4 = I8 + q3 * t9.strides[1], j4 = O5; j4 < M5; j4 += s32){
                            for(var X4 = K4 + j4 * t9.strides[2], Y4 = W3; Y4 < U4; Y4 += u28){
                                var $3 = m13[X4 + Y4 * t9.strides[3] + k8];
                                if ("max" === n24 && $3 > z4 ? z4 = $3 : "avg" === n24 && (G4 += $3, H3++), isNaN(z4)) break;
                            }
                            if (isNaN(z4)) break;
                        }
                        if (isNaN(z4)) break;
                    }
                    y9[V5 + k8] = "avg" === n24 ? G4 / H3 : z4;
                }
            }
        }
        return g12.toTensor();
    }, o32.prototype.avgPool3d = function(t9, e16) {
        return Hh(t9, "avgPool3d"), this.pool3d(t9, e16, "avg").toFloat();
    }, o32.prototype.avgPool3dBackprop = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "avgPool3dBackprop");
        for(var r33 = n24.strideDepth, o43 = n24.strideHeight, a32 = n24.strideWidth, i34 = n24.filterDepth, s32 = n24.filterHeight, u28 = n24.filterWidth, c19 = n24.dilationDepth, l26 = n24.dilationHeight, h15 = n24.dilationWidth, f18 = n24.effectiveFilterDepth, d15 = n24.effectiveFilterHeight, p13 = n24.effectiveFilterWidth, v14 = f18 - 1 - n24.padInfo.front, m13 = p13 - 1 - n24.padInfo.left, g12 = d15 - 1 - n24.padInfo.top, y9 = dr(e16.shape, "float32"), x8 = 1 / (i34 * s32 * u28), b8 = this.bufferSync(t9), w9 = 0; w9 < n24.batchSize; ++w9)for(var C7 = 0; C7 < n24.inChannels; ++C7)for(var E9 = 0; E9 < n24.inDepth; ++E9)for(var R9 = 0; R9 < n24.inHeight; ++R9)for(var I8 = 0; I8 < n24.inWidth; ++I8){
            for(var k8 = E9 - v14, S6 = R9 - g12, A6 = I8 - m13, D6 = 0, T6 = 0; T6 < f18; T6 += c19){
                var N7 = (k8 + T6) / r33;
                if (!(N7 < 0 || N7 >= n24.outDepth || Math.floor(N7) !== N7)) for(var F7 = 0; F7 < d15; F7 += l26){
                    var _6 = (S6 + F7) / o43;
                    if (!(_6 < 0 || _6 >= n24.outHeight || Math.floor(_6) !== _6)) for(var O6 = 0; O6 < p13; O6 += h15){
                        var M6 = (A6 + O6) / a32;
                        if (!(M6 < 0 || M6 >= n24.outWidth || Math.floor(M6) !== M6)) D6 += b8.get(w9, N7, _6, M6, C7);
                    }
                }
            }
            y9.set(D6 * x8, w9, E9, R9, I8, C7);
        }
        return y9.toTensor();
    }, o32.prototype.maxPool3d = function(t9, e16) {
        return Hh(t9, "maxPool3d"), this.pool3d(t9, e16, "max").toFloat();
    }, o32.prototype.maxPool3dPositions = function(t9, e16) {
        for(var n24 = dr(e16.outShape, "int32"), r33 = e16.strideDepth, o43 = e16.strideHeight, a32 = e16.strideWidth, i34 = e16.dilationDepth, s32 = e16.dilationHeight, u28 = e16.dilationWidth, c19 = e16.effectiveFilterDepth, l26 = e16.effectiveFilterHeight, h15 = e16.effectiveFilterWidth, f18 = e16.padInfo.front, d15 = e16.padInfo.top, p13 = e16.padInfo.left, v14 = this.bufferSync(t9), m13 = 0; m13 < e16.batchSize; ++m13)for(var g12 = 0; g12 < e16.inChannels; ++g12)for(var y9 = 0; y9 < e16.outDepth; ++y9){
            for(var x8 = y9 * r33 - f18, b8 = x8; b8 < 0;)b8 += i34;
            for(var w9 = Math.min(e16.inDepth, c19 + x8), C7 = 0; C7 < e16.outHeight; ++C7){
                for(var E9 = C7 * o43 - d15, R9 = E9; R9 < 0;)R9 += s32;
                for(var I8 = Math.min(e16.inHeight, l26 + E9), k9 = 0; k9 < e16.outWidth; ++k9){
                    for(var S7 = k9 * a32 - p13, A7 = S7; A7 < 0;)A7 += u28;
                    for(var D7 = Math.min(e16.inWidth, h15 + S7), T7 = Number.NEGATIVE_INFINITY, N8 = -1, F8 = b8; F8 < w9; F8 += i34)for(var _7 = F8 - x8, O7 = R9; O7 < I8; O7 += s32)for(var M7 = O7 - E9, B5 = A7; B5 < D7; B5 += u28){
                        var P5 = B5 - S7, L4 = v14.get(m13, F8, O7, B5, g12);
                        L4 >= T7 && (T7 = L4, N8 = _7 * l26 * h15 + M7 * l26 + P5);
                    }
                    n24.set(N8, m13, y9, C7, k9, g12);
                }
            }
        }
        return n24.toTensor();
    }, o32.prototype.maxPool3dBackprop = function(t9, e16, n24, r33) {
        Hh([
            e16,
            n24
        ], "maxPool3dBackprop");
        for(var o43 = this.maxPool3dPositions(e16, r33), a32 = r33.strideDepth, i34 = r33.strideHeight, s32 = r33.strideWidth, u28 = r33.dilationDepth, c19 = r33.dilationHeight, l26 = r33.dilationWidth, h15 = r33.effectiveFilterDepth, f18 = r33.effectiveFilterHeight, d15 = r33.effectiveFilterWidth, p13 = h15 - 1 - r33.padInfo.front, v14 = d15 - 1 - r33.padInfo.left, m13 = f18 - 1 - r33.padInfo.top, g12 = dr(e16.shape, "float32"), y9 = this.bufferSync(o43), x9 = this.bufferSync(t9), b9 = 0; b9 < r33.batchSize; ++b9)for(var w10 = 0; w10 < r33.inChannels; ++w10)for(var C8 = 0; C8 < r33.inDepth; ++C8)for(var E10 = 0; E10 < r33.inHeight; ++E10)for(var R10 = 0; R10 < r33.inWidth; ++R10){
            for(var I9 = C8 - p13, k10 = E10 - m13, S8 = R10 - v14, A8 = 0, D8 = 0; D8 < h15; D8 += u28){
                var T8 = (I9 + D8) / a32;
                if (!(T8 < 0 || T8 >= r33.outDepth || Math.floor(T8) !== T8)) for(var N9 = 0; N9 < f18; N9 += c19){
                    var F9 = (k10 + N9) / i34;
                    if (!(F9 < 0 || F9 >= r33.outHeight || Math.floor(F9) !== F9)) for(var _8 = 0; _8 < d15; _8 += l26){
                        var O8 = (S8 + _8) / s32;
                        if (!(O8 < 0 || O8 >= r33.outWidth || Math.floor(O8) !== O8)) {
                            var M8 = h15 * f18 * d15 - 1 - y9.get(b9, T8, F9, O8, w10) === D8 * f18 * d15 + N9 * d15 + _8 ? 1 : 0;
                            if (0 !== M8) A8 += x9.get(b9, T8, F9, O8, w10) * M8;
                        }
                    }
                }
            }
            g12.set(A8, b9, C8, E10, R10, w10);
        }
        return g12.toTensor();
    }, o32.prototype.cast = function(t9, e16) {
        return Po(t9, e16, this);
    }, o32.prototype.reshape = function(t9, e16) {
        return Lo(t9, e16);
    }, o32.prototype.avgPool = function(t9, e16) {
        return Hh(t9, "avgPool"), this.pool(t9, e16, "avg").toFloat();
    }, o32.prototype.resizeBilinear = function(t9, e16, n24, r33) {
        Hh(t9, "resizeBilinear");
        for(var o43 = t9.shape, a32 = o43[0], i34 = o43[1], s32 = o43[2], u28 = o43[3], c19 = this.readSync(t9.dataId), l26 = new Float32Array(k([
            a32,
            e16,
            n24,
            u28
        ])), h15 = [
            r33 && e16 > 1 ? i34 - 1 : i34,
            r33 && n24 > 1 ? s32 - 1 : s32
        ], f18 = [
            r33 && e16 > 1 ? e16 - 1 : e16,
            r33 && n24 > 1 ? n24 - 1 : n24
        ], d15 = 0, p13 = h15[0] / f18[0], v14 = h15[1] / f18[1], m13 = 0; m13 < a32; m13++)for(var g12 = 0; g12 < e16; g12++)for(var y9 = p13 * g12, x9 = Math.floor(y9), b9 = y9 - x9, w10 = Math.min(i34 - 1, Math.ceil(y9)), C8 = m13 * t9.strides[0] + x9 * t9.strides[1], E10 = m13 * t9.strides[0] + w10 * t9.strides[1], R10 = 0; R10 < n24; R10++)for(var I10 = v14 * R10, S9 = Math.floor(I10), A9 = I10 - S9, D9 = Math.min(s32 - 1, Math.ceil(I10)), T9 = C8 + S9 * t9.strides[2], N10 = E10 + S9 * t9.strides[2], F10 = C8 + D9 * t9.strides[2], _9 = E10 + D9 * t9.strides[2], O9 = 0; O9 < u28; O9++){
            var M9 = c19[T9 + O9], B6 = c19[N10 + O9], P6 = M9 + (c19[F10 + O9] - M9) * A9, L5 = P6 + (B6 + (c19[_9 + O9] - B6) * A9 - P6) * b9;
            l26[d15++] = L5;
        }
        return Fn(l26, [
            a32,
            e16,
            n24,
            u28
        ]);
    }, o32.prototype.resizeBilinearBackprop = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "resizeBilinearBackprop");
        for(var r33 = e16.shape, o43 = r33[0], a32 = r33[1], i34 = r33[2], s32 = r33[3], u28 = t9.shape, c19 = u28[1], l26 = u28[2], h15 = new Float32Array(o43 * a32 * i34 * s32), f18 = [
            n24 && c19 > 1 ? a32 - 1 : a32,
            n24 && l26 > 1 ? i34 - 1 : i34
        ], d15 = [
            n24 && c19 > 1 ? c19 - 1 : c19,
            n24 && l26 > 1 ? l26 - 1 : l26
        ], p13 = f18[0] / d15[0], v14 = f18[1] / d15[1], m13 = this.readSync(t9.dataId), g12 = 0, y9 = 0; y9 < o43; y9++)for(var x9 = y9 * e16.strides[0], b9 = 0; b9 < c19; b9++)for(var w10 = b9 * p13, C8 = Math.floor(w10), E10 = Math.min(Math.ceil(w10), a32 - 1), R10 = x9 + C8 * e16.strides[1], I10 = x9 + E10 * e16.strides[1], k11 = w10 - C8, S9 = 1 - k11, A9 = 0; A9 < l26; A9++)for(var D9 = A9 * v14, T9 = Math.floor(D9), N10 = Math.min(Math.ceil(D9), i34 - 1), F10 = D9 - T9, _9 = 1 - F10, O9 = R10 + T9 * e16.strides[2], M10 = R10 + N10 * e16.strides[2], B7 = I10 + T9 * e16.strides[2], P7 = I10 + N10 * e16.strides[2], L6 = S9 * _9, W4 = S9 * F10, U5 = k11 * _9, V6 = k11 * F10, z5 = 0; z5 < s32; z5++){
            var G5 = m13[g12++];
            h15[O9 + z5] += G5 * L6, h15[M10 + z5] += G5 * W4, h15[B7 + z5] += G5 * U5, h15[P7 + z5] += G5 * V6;
        }
        return Ln(h15, [
            o43,
            i34,
            a32,
            s32
        ], e16.dtype);
    }, o32.prototype.resizeNearestNeighbor = function(t9, e16, n24, r33) {
        Hh(t9, "resizeNearestNeighbor");
        for(var o43 = t9.shape, a32 = o43[0], i34 = o43[1], s32 = o43[2], u28 = o43[3], c19 = this.readSync(t9.dataId), l26 = new Float32Array(a32 * e16 * n24 * u28), h15 = [
            r33 && e16 > 1 ? i34 - 1 : i34,
            r33 && n24 > 1 ? s32 - 1 : s32
        ], f18 = [
            r33 && e16 > 1 ? e16 - 1 : e16,
            r33 && n24 > 1 ? n24 - 1 : n24
        ], d15 = h15[0] / f18[0], p13 = h15[1] / f18[1], v14 = 0, m13 = 0; m13 < a32; m13++)for(var g12 = m13 * t9.strides[0], y9 = 0; y9 < e16; y9++)for(var x9 = d15 * y9, b9 = g12 + Math.min(i34 - 1, r33 ? Math.round(x9) : Math.floor(x9)) * t9.strides[1], w10 = 0; w10 < n24; w10++)for(var C8 = p13 * w10, E10 = b9 + Math.min(s32 - 1, r33 ? Math.round(C8) : Math.floor(C8)) * t9.strides[2], R10 = 0; R10 < u28; R10++){
            var I10 = c19[E10 + R10];
            l26[v14++] = I10;
        }
        return Fn(l26, [
            a32,
            e16,
            n24,
            u28
        ], t9.dtype);
    }, o32.prototype.resizeNearestNeighborBackprop = function(t9, e16, n24) {
        Hh([
            t9,
            e16
        ], "resizeNearestNeighborBackprop");
        for(var r33 = e16.shape, o43 = r33[0], a32 = r33[1], i34 = r33[2], s32 = r33[3], u28 = t9.shape, c19 = u28[1], l26 = u28[2], h15 = new Float32Array(o43 * a32 * i34 * s32), f18 = this.readSync(t9.dataId), d15 = [
            n24 && c19 > 1 ? a32 - 1 : a32,
            n24 && l26 > 1 ? i34 - 1 : i34
        ], p13 = [
            n24 && c19 > 1 ? c19 - 1 : c19,
            n24 && l26 > 1 ? l26 - 1 : l26
        ], v14 = d15[0] / p13[0], m13 = d15[1] / p13[1], g12 = 1 / v14, y9 = 1 / m13, x9 = 2 * Math.ceil(g12) + 2, b9 = 2 * Math.ceil(y9) + 2, w10 = 0; w10 < o43; w10++)for(var C8 = w10 * e16.strides[0], E10 = 0; E10 < a32; E10++)for(var R10 = C8 + E10 * e16.strides[1], I11 = Math.floor(E10 * g12), k11 = Math.floor(I11 - x9 / 2), S9 = 0; S9 < i34; S9++)for(var A9 = R10 + S9 * e16.strides[2], D9 = Math.floor(S9 * y9), T9 = Math.floor(D9 - b9 / 2), N10 = 0; N10 < s32; N10++){
            for(var F10 = 0, _9 = 0; _9 < x9; _9++){
                var O9 = _9 + k11;
                if (!(O9 < 0 || O9 >= c19)) {
                    var M10 = C8 + O9 * t9.strides[1], B7 = O9 * v14;
                    if (E10 === Math.min(a32 - 1, n24 ? Math.round(B7) : Math.floor(B7))) for(var P7 = 0; P7 < b9; P7++){
                        var L6 = P7 + T9;
                        if (!(L6 < 0 || L6 >= l26)) {
                            var W4 = M10 + L6 * t9.strides[2], U5 = L6 * m13;
                            S9 === Math.min(i34 - 1, n24 ? Math.round(U5) : Math.floor(U5)) && (F10 += f18[W4 + N10]);
                        }
                    }
                }
            }
            h15[A9 + N10] = F10;
        }
        return Ln(h15, e16.shape, e16.dtype);
    }, o32.prototype.batchNormalization = function(t9, e16, n24, r33, o43, a32) {
        Hh([
            t9,
            e16,
            n24,
            o43,
            a32
        ], "batchNorm");
        for(var i34 = this.readSync(t9.dataId), s32 = this.readSync(e16.dataId), u28 = this.readSync(n24.dataId), c19 = o43 ? this.readSync(o43.dataId) : new Float32Array([
            1
        ]), l26 = a32 ? this.readSync(a32.dataId) : new Float32Array([
            0
        ]), h15 = new Float32Array(i34.length), f18 = l26.length, d15 = c19.length, p13 = u28.length, v14 = s32.length, m13 = 0, g12 = 0, y9 = 0, x9 = 0, b9 = 0; b9 < i34.length; ++b9)h15[b9] = l26[m13++] + (i34[b9] - s32[g12++]) * c19[y9++] / Math.sqrt(u28[x9++] + r33), m13 >= f18 && (m13 = 0), g12 >= v14 && (g12 = 0), y9 >= d15 && (y9 = 0), x9 >= p13 && (x9 = 0);
        return Ln(h15, t9.shape);
    }, o32.prototype.localResponseNormalization4D = function(t9, e16, n24, r33, o43) {
        Hh(t9, "localResponseNormalization4D");
        var a32 = t9.shape[3], i34 = a32 - 1, s32 = this.readSync(t9.dataId), u28 = t9.size, c19 = new Float32Array(u28);
        function l26(t10) {
            for(var n25 = t10 % a32, r34 = t10 - n25 + Math.max(0, n25 - e16), o44 = t10 - n25 + Math.min(n25 + e16, i34), u29 = 0; r34 <= o44; r34++){
                var c20 = s32[r34];
                u29 += c20 * c20;
            }
            return u29;
        }
        for(var h15 = 0; h15 < u28; h15++){
            var f18 = l26(h15), d15 = s32[h15] * Math.pow(n24 + r33 * f18, -o43);
            c19[h15] = d15;
        }
        return Ln(c19, t9.shape);
    }, o32.prototype.LRNGrad = function(t9, e16, n24, r33, o43, a32, i34) {
        Hh(t9, "LRNGrad");
        for(var s32 = t9.shape[3], u28 = this.readSync(t9.dataId), c19 = this.readSync(e16.dataId), l26 = this.readSync(n24.dataId), h15 = new Float32Array(t9.size), f19 = t9.size, d16 = 0; d16 < f19; d16++){
            for(var p13 = d16 % s32, v14 = d16 - p13 + Math.max(0, p13 - r33), m13 = d16 - p13 + Math.min(s32, p13 + r33 + 1), g12 = 0, y9 = v14; y9 < m13; y9++)g12 += Math.pow(c19[y9], 2);
            g12 = a32 * g12 + o43;
            for(y9 = v14; y9 < m13; y9++){
                var x9 = -2 * a32 * i34 * c19[y9] * l26[d16] / g12;
                d16 === y9 && (x9 += Math.pow(g12, -i34)), x9 *= u28[d16], h15[y9] += x9;
            }
        }
        return Ln(h15, t9.shape);
    }, o32.prototype.multinomial = function(t9, e16, n24, r33) {
        Hh(t9, "multinomial");
        for(var o43 = e16 ? t9 : go(t9), a32 = o43.shape[0], i34 = o43.shape[1], s32 = Gn([
            a32,
            n24
        ], "int32"), u28 = this.readSync(s32.dataId), c19 = this.readSync(o43.dataId), l26 = 0; l26 < a32; ++l26){
            var h15 = l26 * i34, f19 = new Float32Array(i34 - 1);
            f19[0] = c19[h15];
            for(var d16 = 1; d16 < f19.length; ++d16)f19[d16] = f19[d16 - 1] + c19[h15 + d16];
            for(var p14 = cr(r33.toString()), v15 = l26 * n24, m14 = 0; m14 < n24; ++m14){
                var g13 = p14();
                u28[v15 + m14] = f19.length;
                for(var y10 = 0; y10 < f19.length; y10++)if (g13 < f19[y10]) {
                    u28[v15 + m14] = y10;
                    break;
                }
            }
        }
        return s32;
    }, o32.prototype.oneHot = function(t9, e16, n24, r33) {
        Hh(t9, "oneHot");
        var o43 = new Float32Array(t9.size * e16);
        o43.fill(r33);
        for(var a32 = this.readSync(t9.dataId), i34 = 0; i34 < t9.size; ++i34)a32[i34] >= 0 && a32[i34] < e16 && (o43[i34 * e16 + a32[i34]] = n24);
        return Bn(o43, [
            t9.size,
            e16
        ], "int32");
    }, o32.prototype.nonMaxSuppression = function(t9, e16, n24, r33, o43) {
        return Hh(t9, "nonMaxSuppression"), jo(this.readSync(t9.dataId), this.readSync(e16.dataId), n24, r33, o43);
    }, o32.prototype.fft = function(t9) {
        return this.fftBatch(t9, !1);
    }, o32.prototype.ifft = function(t9) {
        return this.fftBatch(t9, !0);
    }, o32.prototype.fftBatch = function(t9, e16) {
        for(var n24 = t9.shape[0], r33 = t9.shape[1], o43 = dr(t9.shape, "float32"), a32 = dr(t9.shape, "float32"), i34 = Tn(t9).as2D(n24, r33), s32 = Nn(t9).as2D(n24, r33), u28 = 0; u28 < n24; u28++)for(var c19 = i34.slice([
            u28,
            0
        ], [
            1,
            r33
        ]), l26 = s32.slice([
            u28,
            0
        ], [
            1,
            r33
        ]), h16 = Dn(c19, l26), f20 = this.readSync(this.fftImpl(h16, e16).dataId), d17 = 0; d17 < r33; d17++){
            var p15 = zo(f20, d17);
            o43.values[u28 * r33 + d17] = p15.real, a32.values[u28 * r33 + d17] = p15.imag;
        }
        return Dn(o43.toTensor(), a32.toTensor()).as2D(n24, r33);
    }, o32.prototype.fftImpl = function(t9, e16) {
        var n24 = t9.as1D(), r33 = n24.size;
        if (this.isExponentOf2(r33)) {
            var o43 = this.fftRadix2(n24, r33, e16).as2D(t9.shape[0], t9.shape[1]);
            return e16 && (o43 = Dn(Tn(o43).div(On(r33)), Nn(o43).div(On(r33)))), o43;
        }
        var a32 = this.readSync(t9.dataId), i34 = function(t10) {
            for(var e17 = new Float32Array(t10.length / 2), n25 = new Float32Array(t10.length / 2), r34 = 0; r34 < t10.length; r34 += 2)e17[r34 / 2] = t10[r34], n25[r34 / 2] = t10[r34 + 1];
            return {
                real: e17,
                imag: n25
            };
        }(this.fourierTransformByMatmul(a32, r33, e16));
        return Dn(i34.real, i34.imag).as2D(t9.shape[0], t9.shape[1]);
    }, o32.prototype.isExponentOf2 = function(t9) {
        return 0 == (t9 & t9 - 1);
    }, o32.prototype.fftRadix2 = function(t9, e16, n24) {
        if (1 === e16) return t9;
        var r33 = this.readSync(t9.dataId), o44 = e16 / 2, a32 = function(t10) {
            for(var e17 = Math.ceil(t10.length / 4), n25 = new Float32Array(e17), r34 = new Float32Array(e17), o45 = 0; o45 < t10.length; o45 += 4)n25[Math.floor(o45 / 4)] = t10[o45], r34[Math.floor(o45 / 4)] = t10[o45 + 1];
            return {
                real: n25,
                imag: r34
            };
        }(r33), i34 = Dn(a32.real, a32.imag).as1D(), s32 = function(t10) {
            for(var e17 = Math.floor(t10.length / 4), n25 = new Float32Array(e17), r34 = new Float32Array(e17), o45 = 2; o45 < t10.length; o45 += 4)n25[Math.floor(o45 / 4)] = t10[o45], r34[Math.floor(o45 / 4)] = t10[o45 + 1];
            return {
                real: n25,
                imag: r34
            };
        }(r33), u28 = Dn(s32.real, s32.imag).as1D();
        i34 = this.fftRadix2(i34, o44, n24), u28 = this.fftRadix2(u28, o44, n24);
        var c19 = function(t10, e17) {
            for(var n25 = new Float32Array(t10 / 2), r34 = new Float32Array(t10 / 2), o45 = 0; o45 < Math.ceil(t10 / 2); o45++){
                var a33 = (e17 ? 2 : -2) * Math.PI * (o45 / t10);
                n25[o45] = Math.cos(a33), r34[o45] = Math.sin(a33);
            }
            return {
                real: n25,
                imag: r34
            };
        }(e16, n24), l26 = Dn(c19.real, c19.imag).mul(u28), h16 = i34.add(l26), f20 = i34.sub(l26), d17 = Tn(h16).concat(Tn(f20)), p16 = Nn(h16).concat(Nn(f20));
        return Dn(d17, p16).as1D();
    }, o32.prototype.fourierTransformByMatmul = function(t9, e16, n24) {
        for(var r33 = new Float32Array(2 * e16), o44 = 0; o44 < e16; o44++){
            for(var a32 = 0, i34 = 0, s32 = 0; s32 < e16; s32++){
                var u28 = Ho(o44 * s32, e16, n24), c19 = zo(t9, s32);
                a32 += c19.real * u28.real - c19.imag * u28.imag, i34 += c19.real * u28.imag + c19.imag * u28.real;
            }
            n24 && (a32 /= e16, i34 /= e16), Go(r33, a32, i34, o44);
        }
        return r33;
    }, o32.prototype.depthToSpace = function(t9, e16, n24) {
        C("NHWC" === n24, function() {
            return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n24;
        }), C(e16 > 1, function() {
            return "blockSize should be > 1 for depthToSpace, but was: " + e16;
        });
        for(var r33 = t9.shape[0], o44 = t9.shape[1], a34 = t9.shape[2], i35 = t9.shape[3], s33 = o44 * e16, u29 = a34 * e16, c21 = i35 / (e16 * e16), l26 = this.readSync(t9.dataId), h16 = new Float32Array(r33 * s33 * u29 * c21), f20 = 0, d17 = 0; d17 < r33; ++d17)for(var p16 = 0; p16 < s33; ++p16)for(var v16 = Math.floor(p16 / e16), m15 = p16 % e16, g14 = 0; g14 < u29; ++g14)for(var y11 = Math.floor(g14 / e16), x10 = (m15 * e16 + g14 % e16) * c21, b9 = 0; b9 < c21; ++b9){
            var w10 = b9 + x10 + i35 * (y11 + a34 * (v16 + o44 * d17));
            h16[f20++] = l26[w10];
        }
        return Ln(h16, [
            r33,
            s33,
            u29,
            c21
        ]);
    }, o32.prototype.broadcastedBinaryOp = function(t9, e16, n24, r33) {
        var o44 = Ro(t9.shape, e16.shape), a34 = dr(o44, n24), i35 = this.readSync(t9.dataId), s33 = this.readSync(e16.dataId), u29 = Co(t9.shape, o44), c21 = Co(e16.shape, o44), l26 = a34.values;
        if (u29.length + c21.length === 0) for(var h16 = 0; h16 < l26.length; ++h16)l26[h16] = r33(i35[h16 % i35.length], s33[h16 % s33.length]);
        else {
            var f20 = this.bufferSync(t9), d17 = this.bufferSync(e16), p16 = function(n25) {
                var o45 = a34.indexToLoc(n25), h17 = o45.slice(-t9.rank);
                u29.forEach(function(t10) {
                    return h17[t10] = 0;
                });
                var p17 = f20.locToIndex(h17), v16 = o45.slice(-e16.rank);
                c21.forEach(function(t10) {
                    return v16[t10] = 0;
                });
                var m15 = d17.locToIndex(v16);
                l26[n25] = r33(i35[p17], s33[m15]);
            };
            for(h16 = 0; h16 < l26.length; ++h16)p16(h16);
        }
        return a34.toTensor();
    }, o32.prototype.broadcastedBinaryComplexOp = function(t9, e16, n24) {
        var r33 = Ro(t9.shape, e16.shape), o44 = dr(r33, "float32"), a34 = dr(r33, "float32"), i35 = this.readSync(t9.dataId), s33 = this.readSync(e16.dataId), u29 = Co(t9.shape, r33), c21 = Co(e16.shape, r33), l26 = o44.values, h16 = a34.values;
        if (u29.length + c21.length === 0) for(var f21 = 0; f21 < l26.length; f21++){
            var d18 = f21 % i35.length, p17 = f21 % s33.length, v16 = n24(i35[2 * d18], i35[2 * d18 + 1], s33[2 * p17], s33[2 * p17 + 1]);
            l26[f21] = v16.real, h16[f21] = v16.imag;
        }
        else {
            var m15 = this.bufferSync(this.data.get(t9.dataId).complexTensors.real), g14 = this.bufferSync(this.data.get(e16.dataId).complexTensors.real), y11 = function(r34) {
                var a35 = o44.indexToLoc(r34), f22 = a35.slice(-t9.rank);
                u29.forEach(function(t10) {
                    return f22[t10] = 0;
                });
                var d19 = m15.locToIndex(f22), p18 = a35.slice(-e16.rank);
                c21.forEach(function(t10) {
                    return p18[t10] = 0;
                });
                var v17 = g14.locToIndex(p18), y12 = n24(i35[2 * d19], i35[2 * d19 + 1], s33[2 * v17], s33[2 * v17 + 1]);
                l26[r34] = y12.real, h16[r34] = y12.imag;
            };
            for(f21 = 0; f21 < l26.length; f21++)y11(f21);
        }
        return this.complex(o44.toTensor(), a34.toTensor());
    }, o32.prototype.split = function(t9, e16, n24) {
        return Zo(t9, e16, n24);
    }, o32.prototype.dispose = function() {
    }, o32.prototype.floatPrecision = function() {
        return 32;
    }, o32.prototype.epsilon = function() {
        return 0.0000001;
    }, o32.prototype.cropAndResize = function(t9, e16, n24, r33, o44, a34) {
        for(var i35 = t9.shape, s33 = i35[0], u29 = i35[1], c21 = i35[2], l26 = i35[3], h16 = e16.shape[0], f21 = r33[0], d19 = r33[1], p18 = dr([
            h16,
            f21,
            d19,
            l26
        ], "float32"), v17 = this.readSync(e16.dataId), m16 = this.readSync(n24.dataId), g15 = this.readSync(t9.dataId), y12 = t9.strides, x10 = p18.strides, b9 = 0; b9 < h16; b9++){
            var w11 = 4 * b9, C8 = v17[w11], E10 = v17[w11 + 1], R10 = v17[w11 + 2], I11 = v17[w11 + 3], k11 = m16[b9];
            if (!(k11 >= s33)) for(var S9 = f21 > 1 ? (R10 - C8) * (u29 - 1) / (f21 - 1) : 0, A9 = d19 > 1 ? (I11 - E10) * (c21 - 1) / (d19 - 1) : 0, D9 = 0; D9 < f21; D9++){
                var T9 = f21 > 1 ? C8 * (u29 - 1) + D9 * S9 : 0.5 * (C8 + R10) * (u29 - 1);
                if (T9 < 0 || T9 > u29 - 1) for(var N10 = 0; N10 < d19; N10++)for(var F11 = 0; F11 < l26; F11++){
                    var _10 = F11 + N10 * x10[2] + D9 * x10[1] + b9 * x10[0];
                    p18.values[_10] = a34;
                }
                else if ("bilinear" === o44) {
                    var O10 = Math.floor(T9), M11 = Math.ceil(T9), B8 = T9 - O10;
                    for(N10 = 0; N10 < d19; N10++){
                        if ((q5 = d19 > 1 ? E10 * (c21 - 1) + N10 * A9 : 0.5 * (E10 + I11) * (c21 - 1)) < 0 || q5 > c21 - 1) for(F11 = 0; F11 < l26; F11++){
                            _10 = F11 + N10 * x10[2] + D9 * x10[1] + b9 * x10[0];
                            p18.values[_10] = a34;
                        }
                        else {
                            var P8 = Math.floor(q5), L7 = Math.ceil(q5), W5 = q5 - P8;
                            for(F11 = 0; F11 < l26; F11++){
                                var U6 = g15[_10 = F11 + P8 * y12[2] + O10 * y12[1] + k11 * y12[0]], V6 = g15[_10 = F11 + L7 * y12[2] + O10 * y12[1] + k11 * y12[0]], z5 = g15[_10 = F11 + P8 * y12[2] + M11 * y12[1] + k11 * y12[0]], G6 = U6 + (V6 - U6) * W5, H4 = z5 + (g15[_10 = F11 + L7 * y12[2] + M11 * y12[1] + k11 * y12[0]] - z5) * W5;
                                _10 = F11 + N10 * x10[2] + D9 * x10[1] + b9 * x10[0], p18.values[_10] = G6 + (H4 - G6) * B8;
                            }
                        }
                    }
                } else for(N10 = 0; N10 < d19; ++N10){
                    var q5;
                    if ((q5 = d19 > 1 ? E10 * (c21 - 1) + N10 * A9 : 0.5 * (E10 + I11) * (c21 - 1)) < 0 || q5 > c21 - 1) for(F11 = 0; F11 < l26; F11++){
                        _10 = F11 + N10 * x10[2] + D9 * x10[1] + b9 * x10[0];
                        p18.values[_10] = a34;
                    }
                    else {
                        var K5 = Math.round(q5), j5 = Math.round(T9);
                        for(F11 = 0; F11 < l26; F11++){
                            var X5 = F11 + K5 * y12[2] + j5 * y12[1] + k11 * y12[0], Y5 = F11 + N10 * x10[2] + D9 * x10[1] + b9 * x10[0];
                            p18.values[Y5] = g15[X5];
                        }
                    }
                }
            }
        }
        return p18.toTensor();
    }, o32.prototype.sparseToDense = function(t9, e16, n24, r33) {
        var o44 = Zr(0, t9, n24), a34 = o44.sliceRank, i35 = o44.numUpdates, s33 = o44.sliceSize, u29 = o44.strides, c21 = o44.outputSize;
        return this.scatter(t9, e16, n24, c21, s33, i35, a34, u29, r33, !1);
    }, o32.prototype.gatherND = function(t9, e16) {
        var n24 = e16.shape, r33 = n24[n24.length - 1], o44 = jr(t9, e16), a34 = o44[0], i35 = o44[1], s33 = o44[2], u29 = o44[3];
        if (0 === i35) return Fn([], a34, t9.dtype);
        for(var c21 = new gt([
            i35,
            s33
        ], t9.dtype), l26 = this.readSync(e16.dataId), h16 = this.readSync(t9.dataId), f21 = 0; f21 < i35; f21++){
            for(var d19 = [], p18 = 0, v17 = 0; v17 < r33; v17++){
                var m16 = l26[f21 * r33 + v17];
                p18 += m16 * u29[v17], d19.push(m16);
            }
            if (p18 < 0 || p18 >= t9.size / s33) throw new Error("Invalid indices: " + d19 + " does not index into " + t9.shape);
            for(var g15 = 0; g15 < s33; g15++)c21.values[f21 * s33 + g15] = h16[p18 * s33 + g15];
        }
        return c21.toTensor().reshape(a34);
    }, o32.prototype.scatterND = function(t9, e16, n24) {
        var r33 = Zr(0, t9, n24), o44 = r33.sliceRank, a34 = r33.numUpdates, i35 = r33.sliceSize, s33 = r33.strides, u29 = r33.outputSize, c21 = On(0);
        return this.scatter(t9, e16, n24, u29, i35, a34, o44, s33, c21, !0);
    }, o32.prototype.fill = function(t9, e16, n24) {
        var r33 = P(n24 = n24 || j(e16), k(t9));
        return r33.fill(e16), Lt.makeTensor(r33, t9, n24, this);
    }, o32.prototype.onesLike = function(t9) {
        if ("string" === t9.dtype) throw new Error("onesLike is not supported for string tensors");
        return this.fill(t9.shape, 1, t9.dtype);
    }, o32.prototype.zerosLike = function(t9) {
        var e16 = P(t9.dtype, k(t9.shape));
        return this.makeOutput(e16, t9.shape, t9.dtype);
    }, o32.prototype.linspace = function(t9, e16, n24) {
        return Wo(t9, e16, n24);
    }, o32.prototype.scatter = function(t9, e16, n24, r33, o44, a34, i35, s33, u29, c21) {
        var l26 = [
            r33 / o44,
            o44
        ], h16 = this.readSync(t9.dataId), f21 = this.readSync(e16.dataId);
        if (0 === r33) return Fn([], n24, e16.dtype);
        var d20 = new gt(l26, e16.dtype);
        d20.values.fill(this.readSync(u29.dataId)[0]);
        for(var p19 = 0; p19 < a34; p19++){
            for(var v18 = [], m17 = 0, g16 = 0; g16 < i35; g16++){
                var y12 = h16[p19 * i35 + g16];
                v18.push(y12), m17 += y12 * s33[g16];
            }
            if (m17 < 0 || m17 >= r33 / o44) throw new Error("Invalid indices: " + v18 + " does not index into " + n24);
            for(var x10 = 0; x10 < o44; x10++)c21 ? d20.values[m17 * o44 + x10] += f21[p19 * o44 + x10] : d20.values[m17 * o44 + x10] = 0 === e16.rank ? f21[0] : f21[p19 * o44 + x10];
        }
        return d20.toTensor().reshape(n24);
    }, o32;
}(bo);
Lt.registerBackend("cpu", function() {
    return new Kh;
}, 1);
for(var jh = 0, Xh = [
    {
        kernelName: "NonMaxSuppressionV5",
        backendName: "cpu",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = t1.attrs, o32 = e16, a34 = o32.boxes, i35 = o32.scores, s33 = r33, u29 = s33.maxOutputSize, c21 = s33.iouThreshold, l26 = s33.scoreThreshold, h16 = s33.softNmsSigma, f21 = n24;
            Hh(a34, "NonMaxSuppressionWithScore");
            var d20 = Xo(f21.data.get(a34.dataId).values, f21.data.get(i35.dataId).values, u29, c21, l26, h16);
            return [
                d20.selectedIndices,
                d20.selectedScores
            ];
        }
    },
    {
        kernelName: "Square",
        backendName: "cpu",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = e16.x, o32 = n24;
            Hh(r33, "square");
            for(var a34 = o32.data.get(r33.dataId).values, i35 = new Float32Array(a34.length), s33 = 0; s33 < a34.length; ++s33){
                var u29 = a34[s33];
                i35[s33] = u29 * u29;
            }
            return {
                dataId: o32.write(i35, r33.shape, r33.dtype),
                shape: r33.shape,
                dtype: r33.dtype
            };
        }
    },
    {
        kernelName: eu,
        backendName: "cpu",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = e16, o32 = r33.a, a34 = r33.b, i35 = n24;
            Hh([
                o32,
                a34
            ], eu);
            var s33 = i35.data.get(o32.dataId).values, u30 = i35.data.get(a34.dataId).values, c21 = function(t9, e17, n25, r34, o44, a35) {
                var i36 = Ro(t9, e17), s34 = i36.length, u31 = $(i36), c22 = B(o44, k(i36)), l26 = t9.length, h16 = e17.length, f21 = $(t9), d20 = $(e17), p19 = Co(t9, i36), v19 = Co(e17, i36);
                if (p19.length + v19.length === 0) for(var m18 = 0; m18 < c22.length; ++m18)c22[m18] = a35(n25[m18 % n25.length], r34[m18 % r34.length]);
                else {
                    var g17 = function(t10) {
                        var e18 = it(t10, s34, u31), o45 = e18.slice(-l26);
                        p19.forEach(function(t11) {
                            return o45[t11] = 0;
                        });
                        var i37 = at(o45, l26, f21), m19 = e18.slice(-h16);
                        v19.forEach(function(t11) {
                            return m19[t11] = 0;
                        });
                        var g18 = at(m19, h16, d20);
                        c22[t10] = a35(n25[i37], r34[g18]);
                    };
                    for(m18 = 0; m18 < c22.length; ++m18)g17(m18);
                }
                return [
                    c22,
                    i36
                ];
            }(o32.shape, a34.shape, s33, u30, o32.dtype, function(t9, e17) {
                var n25 = t9 - e17;
                return n25 * n25;
            }), l26 = c21[0], h16 = c21[1];
            return {
                dataId: i35.write(l26, h16, o32.dtype),
                shape: h16,
                dtype: o32.dtype
            };
        }
    }
]; jh < Xh.length; jh++)d2(Xh[jh]);
var Yh, $h = function(t1) {
    this.variableNames = [
        "A"
    ];
    var e16 = ua(), n24 = t1[0], r33 = t1[1];
    this.outputShape = t1, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r33 + ".0, " + n24 + ".0);\n\n        vec4 values = " + e16.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
}, Qh = function(t1) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0;
    var e16 = ua(), n24 = t1[0], r33 = t1[1];
    this.outputShape = t1, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r33 + ".0, " + n24 + ".0);\n            vec4 values = " + e16.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e16.output + " = result;\n      }\n    ";
};
for(var Jh = 0, Zh = [
    {
        kernelName: "FromPixels",
        backendName: "webgl",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = t1.attrs, o32 = e16.pixels, a34 = r33.numChannels, s33 = "undefined" != typeof HTMLVideoElement && o32 instanceof HTMLVideoElement, u30 = "undefined" != typeof HTMLImageElement && o32 instanceof HTMLImageElement, c21 = s33 ? [
                o32.videoWidth,
                o32.videoHeight
            ] : [
                o32.width,
                o32.height
            ], l26 = c21[0], h16 = c21[1], f21 = [
                h16,
                l26
            ], d20 = [
                h16,
                l26,
                a34
            ];
            (u30 || s33) && (null == Yh && (Yh = document.createElement("canvas").getContext("2d")), Yh.canvas.width = l26, Yh.canvas.height = h16, Yh.drawImage(o32, 0, 0, l26, h16), o32 = Yh.canvas);
            var p19 = n24.makeTensorInfo(f21, "int32");
            n24.texData.get(p19.dataId).usage = zt.PIXELS, n24.gpgpu.uploadPixelDataToTexture(n24.getTexture(p19.dataId), o32);
            var v19 = i15().getBool("WEBGL_PACK") ? new Qh(d20) : new $h(d20), m18 = n24.runWebGLProgram(v19, [
                p19
            ], "int32");
            return n24.disposeData(p19.dataId), m18;
        }
    },
    {
        kernelName: "NonMaxSuppressionV5",
        backendName: "webgl",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = t1.attrs;
            dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
            var o32 = e16, a34 = o32.boxes, i35 = o32.scores, s33 = r33, u30 = s33.maxOutputSize, c21 = s33.iouThreshold, l26 = s33.scoreThreshold, h16 = s33.softNmsSigma, f21 = n24, d20 = Xo(f21.readSync(a34.dataId), f21.readSync(i35.dataId), u30, c21, l26, h16);
            return [
                d20.selectedIndices,
                d20.selectedScores
            ];
        }
    },
    {
        kernelName: "Square",
        backendName: "webgl",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = e16.x, o32 = n24, a34 = new Cs(r33.shape, "return x * x;");
            return o32.runWebGLProgram(a34, [
                r33
            ], r33.dtype);
        }
    },
    {
        kernelName: eu,
        backendName: "webgl",
        kernelFunc: function(t1) {
            var e16 = t1.inputs, n24 = t1.backend, r33 = e16, o32 = r33.a, a34 = r33.b, s33 = n24, u30 = i15().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("return (a - b) * (a - b);", o32.shape, a34.shape) : new Ba("return (a - b) * (a - b);", o32.shape, a34.shape);
            return s33.compileAndRun(u30, [
                o32,
                a34
            ]);
        }
    }
]; Jh < Zh.length; Jh++)d2(Zh[Jh]);
for(var tf = 0, ef = [
    {
        kernelName: "Square",
        gradFunc: function(t1, e16) {
            var n24 = e16[0];
            return {
                x: function() {
                    return t1.mul(n24.toFloat().mul(2));
                }
            };
        }
    },
    {
        kernelName: eu,
        gradFunc: function(t1, e16) {
            var n24 = e16[0], r33 = e16[1], o32 = On(2);
            return {
                a: function() {
                    return gc(t1, gc(o32, Cc(n24, r33)));
                },
                b: function() {
                    return gc(t1, gc(o32, Cc(r33, n24)));
                }
            };
        }
    }
]; tf < ef.length; tf++)p2(ef[tf]);
var nf = function() {
    function t1() {
    }
    return t1.prototype.fetch = function(t9, e16) {
        return fetch(t9, e16);
    }, t1.prototype.now = function() {
        return performance.now();
    }, t1.prototype.encode = function(t9, e16) {
        if ("utf-8" !== e16 && "utf8" !== e16) throw new Error("Browser's encoder only supports utf-8, but got " + e16);
        return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t9);
    }, t1.prototype.decode = function(t9, e16) {
        return new TextDecoder(e16).decode(t9);
    }, t1;
}();
i15().get("IS_BROWSER") && i15().setPlatform("browser", new nf);
var rf, of = function() {
    return require("node-fetch");
}, af = function() {
    function t1() {
        this.util = require("util"), this.textEncoder = new this.util.TextEncoder;
    }
    return t1.prototype.fetch = function(t9, e16) {
        return null != i15().global.fetch ? i15().global.fetch(t9, e16) : (null == rf && (rf = of()), rf(t9, e16));
    }, t1.prototype.now = function() {
        var t9 = process.hrtime();
        return 1000 * t9[0] + t9[1] / 1000000;
    }, t1.prototype.encode = function(t9, e16) {
        if ("utf-8" !== e16 && "utf8" !== e16) throw new Error("Node built-in encoder only supports utf-8, but got " + e16);
        return this.textEncoder.encode(t9);
    }, t1.prototype.decode = function(t9, e16) {
        return 0 === t9.length ? "" : new this.util.TextDecoder(e16).decode(t9);
    }, t1;
}();
i15().get("IS_NODE") && i15().setPlatform("node", new af);
var sf = {
    float32: 4,
    int32: 4,
    uint16: 2,
    uint8: 1,
    bool: 1
}, uf = 4;
function cf(t1, e16) {
    for(var n24 = {
    }, r33 = 0, o32 = function(e17) {
        var o44 = e17.name, a34 = e17.dtype, i35 = e17.shape, s33 = k(i35), u30 = void 0;
        if ("quantization" in e17) {
            var c21 = e17.quantization;
            if ("uint8" !== c21.dtype && "uint16" !== c21.dtype) throw new Error("Weight " + e17.name + " has unknown quantization dtype " + c21.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
            var l26 = sf[c21.dtype], h16 = t1.slice(r33, r33 + s33 * l26), f21 = "uint8" === c21.dtype ? new Uint8Array(h16) : new Uint16Array(h16);
            if ("float32" === a34) u30 = Float32Array.from(f21, function(t9) {
                return t9 * c21.scale + c21.min;
            });
            else {
                if ("int32" !== a34) throw new Error("Unsupported dtype in weight '" + o44 + "': " + a34);
                u30 = Int32Array.from(f21, function(t9) {
                    return Math.round(t9 * c21.scale + c21.min);
                });
            }
            r33 += s33 * l26;
        } else if ("string" === a34) {
            var d20 = k(e17.shape);
            u30 = [];
            for(var p19 = 0; p19 < d20; p19++){
                var v19 = new Uint32Array(t1.slice(r33, r33 + uf))[0];
                r33 += uf;
                var m18 = new Uint8Array(t1.slice(r33, r33 + v19));
                u30.push(m18), r33 += v19;
            }
        } else {
            var g18 = sf[a34];
            h16 = t1.slice(r33, r33 + s33 * g18);
            if ("float32" === a34) u30 = new Float32Array(h16);
            else if ("int32" === a34) u30 = new Int32Array(h16);
            else {
                if ("bool" !== a34) throw new Error("Unsupported dtype in weight '" + o44 + "': " + a34);
                u30 = new Uint8Array(h16);
            }
            r33 += s33 * g18;
        }
        n24[o44] = Fn(u30, i35, a34);
    }, a34 = 0, i35 = e16; a34 < i35.length; a34++)o32(i35[a34]);
    return n24;
}
function lf(t1) {
    if (null === t1) throw new Error("Invalid input value: " + JSON.stringify(t1));
    var e16 = 0, n24 = [];
    t1.forEach(function(t9) {
        if (e16 += t9.byteLength, n24.push(t9.byteLength === t9.buffer.byteLength ? t9 : new t9.constructor(t9)), !(t9 instanceof Float32Array || t9 instanceof Int32Array || t9 instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t9.constructor.name);
    });
    var r33 = new Uint8Array(e16), o32 = 0;
    return n24.forEach(function(t9) {
        r33.set(new Uint8Array(t9.buffer), o32), o32 += t9.byteLength;
    }), r33.buffer;
}
var hf = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
function ff(t1) {
    return hf ? Buffer.byteLength(t1) : new Blob([
        t1
    ]).size;
}
function df(t1) {
    var e16 = 0;
    t1.forEach(function(t9) {
        e16 += t9.byteLength;
    });
    var n24 = new Uint8Array(e16), r33 = 0;
    return t1.forEach(function(t9) {
        n24.set(new Uint8Array(t9), r33), r33 += t9.byteLength;
    }), n24.buffer;
}
function pf(t1) {
    for(t1 = t1.trim(); t1.endsWith("/");)t1 = t1.slice(0, t1.length - 1);
    var e16 = t1.split("/");
    return e16[e16.length - 1];
}
function vf(t1) {
    if (t1.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
        dateSaved: new Date,
        modelTopologyType: "JSON",
        modelTopologyBytes: null == t1.modelTopology ? 0 : ff(JSON.stringify(t1.modelTopology)),
        weightSpecsBytes: null == t1.weightSpecs ? 0 : ff(JSON.stringify(t1.weightSpecs)),
        weightDataBytes: null == t1.weightData ? 0 : t1.weightData.byteLength
    };
}
var mf = function() {
    function t1() {
        this.saveRouters = [], this.loadRouters = [];
    }
    return t1.getInstance = function() {
        return null == t1.instance && (t1.instance = new t1), t1.instance;
    }, t1.registerSaveRouter = function(e16) {
        t1.getInstance().saveRouters.push(e16);
    }, t1.registerLoadRouter = function(e16) {
        t1.getInstance().loadRouters.push(e16);
    }, t1.getSaveHandlers = function(e16) {
        return t1.getHandlers(e16, "save");
    }, t1.getLoadHandlers = function(e16, n24) {
        return t1.getHandlers(e16, "load", n24);
    }, t1.getHandlers = function(e16, n24, r33) {
        var o32 = [];
        return ("load" === n24 ? t1.getInstance().loadRouters : t1.getInstance().saveRouters).forEach(function(t9) {
            var n25 = t9(e16, r33);
            null !== n25 && o32.push(n25);
        }), o32;
    }, t1;
}(), gf = "://", yf = function() {
    function t1() {
        this.managers = {
        };
    }
    return t1.getInstance = function() {
        return null == t1.instance && (t1.instance = new t1), t1.instance;
    }, t1.registerManager = function(e16, n24) {
        C(null != e16, function() {
            return "scheme must not be undefined or null.";
        }), e16.endsWith(gf) && (e16 = e16.slice(0, e16.indexOf(gf))), C(e16.length > 0, function() {
            return "scheme must not be an empty string.";
        });
        var r33 = t1.getInstance();
        C(null == r33.managers[e16], function() {
            return "A model store manager is already registered for scheme '" + e16 + "'.";
        }), r33.managers[e16] = n24;
    }, t1.getManager = function(t9) {
        var e16 = this.getInstance().managers[t9];
        if (null == e16) throw new Error("Cannot find model manager for scheme '" + t9 + "'");
        return e16;
    }, t1.getSchemes = function() {
        return Object.keys(this.getInstance().managers);
    }, t1;
}();
function xf(t1) {
    if (-1 === t1.indexOf(gf)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + yf.getSchemes().join(","));
    return {
        scheme: t1.split(gf)[0],
        path: t1.split(gf)[1]
    };
}
function bf(t1, e16, o32) {
    return (void 0) === o32 && (o32 = !1), n10(this, void 0, void 0, function() {
        var n24, a34, i35, s33, u30, c22, l27, h17, f22;
        return r17(this, function(r33) {
            switch(r33.label){
                case 0:
                    return C(t1 !== e16, function() {
                        return "Old path and new path are the same: '" + t1 + "'";
                    }), C((n24 = mf.getLoadHandlers(t1)).length > 0, function() {
                        return "Copying failed because no load handler is found for source URL " + t1 + ".";
                    }), C(n24.length < 2, function() {
                        return "Copying failed because more than one (" + n24.length + ") load handlers for source URL " + t1 + ".";
                    }), a34 = n24[0], C((i35 = mf.getSaveHandlers(e16)).length > 0, function() {
                        return "Copying failed because no save handler is found for destination URL " + e16 + ".";
                    }), C(i35.length < 2, function() {
                        return "Copying failed because more than one (" + n24.length + ") save handlers for destination URL " + e16 + ".";
                    }), s33 = i35[0], u30 = xf(t1).scheme, c22 = xf(t1).path, l27 = u30 === xf(t1).scheme, [
                        4,
                        a34.load()
                    ];
                case 1:
                    return h17 = r33.sent(), o32 && l27 ? [
                        4,
                        yf.getManager(u30).removeModel(c22)
                    ] : [
                        3,
                        3
                    ];
                case 2:
                    r33.sent(), r33.label = 3;
                case 3:
                    return [
                        4,
                        s33.save(h17)
                    ];
                case 4:
                    return f22 = r33.sent(), !o32 || l27 ? [
                        3,
                        6
                    ] : [
                        4,
                        yf.getManager(u30).removeModel(c22)
                    ];
                case 5:
                    r33.sent(), r33.label = 6;
                case 6:
                    return [
                        2,
                        f22.modelArtifactsInfo
                    ];
            }
        });
    });
}
var wf = "models_store", Cf = "model_info_store";
function Ef() {
    if (!i15().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    var t1 = window || self, e16 = t1.indexedDB || t1.mozIndexedDB || t1.webkitIndexedDB || t1.msIndexedDB || t1.shimIndexedDB;
    if (null == e16) throw new Error("The current browser does not appear to support IndexedDB.");
    return e16;
}
function Rf(t1) {
    var e16 = t1.result;
    e16.createObjectStore(wf, {
        keyPath: "modelPath"
    }), e16.createObjectStore(Cf, {
        keyPath: "modelPath"
    });
}
var If = function() {
    function t1(t9) {
        if (this.indexedDB = Ef(), null == t9 || !t9) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = t9;
    }
    return t1.prototype.save = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e16) {
                if (t9.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                return [
                    2,
                    this.databaseAction(this.modelPath, t9)
                ];
            });
        });
    }, t1.prototype.load = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                return [
                    2,
                    this.databaseAction(this.modelPath)
                ];
            });
        });
    }, t1.prototype.databaseAction = function(t9, e16) {
        var n24 = this;
        return new Promise(function(t10, r33) {
            var o32 = n24.indexedDB.open("tensorflowjs", 1);
            o32.onupgradeneeded = function() {
                return Rf(o32);
            }, o32.onsuccess = function() {
                var a34 = o32.result;
                if (null == e16) {
                    var i35 = a34.transaction(wf, "readonly"), s33 = i35.objectStore(wf).get(n24.modelPath);
                    s33.onsuccess = function() {
                        if (null == s33.result) return a34.close(), r33(new Error("Cannot find model with path '" + n24.modelPath + "' in IndexedDB."));
                        t10(s33.result.modelArtifacts);
                    }, s33.onerror = function(t11) {
                        return a34.close(), r33(s33.error);
                    }, i35.oncomplete = function() {
                        return a34.close();
                    };
                } else {
                    var u30, c22 = vf(e16), l27 = a34.transaction(Cf, "readwrite"), h17 = l27.objectStore(Cf), f22 = h17.put({
                        modelPath: n24.modelPath,
                        modelArtifactsInfo: c22
                    });
                    f22.onsuccess = function() {
                        var o44 = (u30 = a34.transaction(wf, "readwrite")).objectStore(wf).put({
                            modelPath: n24.modelPath,
                            modelArtifacts: e16,
                            modelArtifactsInfo: c22
                        });
                        o44.onsuccess = function() {
                            return t10({
                                modelArtifactsInfo: c22
                            });
                        }, o44.onerror = function(t11) {
                            var e17 = (h17 = l27.objectStore(Cf)).delete(n24.modelPath);
                            e17.onsuccess = function() {
                                return a34.close(), r33(o44.error);
                            }, e17.onerror = function(t12) {
                                return a34.close(), r33(o44.error);
                            };
                        };
                    }, f22.onerror = function(t11) {
                        return a34.close(), r33(f22.error);
                    }, l27.oncomplete = function() {
                        null == u30 ? a34.close() : u30.oncomplete = function() {
                            return a34.close();
                        };
                    };
                }
            }, o32.onerror = function(t11) {
                return r33(o32.error);
            };
        });
    }, t1.URL_SCHEME = "indexeddb://", t1;
}(), kf = function(t1) {
    var e16;
    return i15().getBool("IS_BROWSER") && !Array.isArray(t1) && t1.startsWith(If.URL_SCHEME) ? (e16 = t1.slice(If.URL_SCHEME.length), new If(e16)) : null;
};
mf.registerSaveRouter(kf), mf.registerLoadRouter(kf);
var Sf = function() {
    function t1() {
        this.indexedDB = Ef();
    }
    return t1.prototype.listModels = function() {
        return n10(this, void 0, void 0, function() {
            var t9 = this;
            return r17(this, function(e16) {
                return [
                    2,
                    new Promise(function(e17, n24) {
                        var r33 = t9.indexedDB.open("tensorflowjs", 1);
                        r33.onupgradeneeded = function() {
                            return Rf(r33);
                        }, r33.onsuccess = function() {
                            var t10 = r33.result, o32 = t10.transaction(Cf, "readonly"), a34 = o32.objectStore(Cf).getAll();
                            a34.onsuccess = function() {
                                for(var t11 = {
                                }, n25 = 0, r34 = a34.result; n25 < r34.length; n25++){
                                    var o44 = r34[n25];
                                    t11[o44.modelPath] = o44.modelArtifactsInfo;
                                }
                                e17(t11);
                            }, a34.onerror = function(e18) {
                                return t10.close(), n24(a34.error);
                            }, o32.oncomplete = function() {
                                return t10.close();
                            };
                        }, r33.onerror = function(t10) {
                            return n24(r33.error);
                        };
                    })
                ];
            });
        });
    }, t1.prototype.removeModel = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16 = this;
            return r17(this, function(n24) {
                var r33;
                return t9 = (r33 = t9).startsWith(If.URL_SCHEME) ? r33.slice(If.URL_SCHEME.length) : r33, [
                    2,
                    new Promise(function(n25, r34) {
                        var o32 = e16.indexedDB.open("tensorflowjs", 1);
                        o32.onupgradeneeded = function() {
                            return Rf(o32);
                        }, o32.onsuccess = function() {
                            var e17, a34 = o32.result, i36 = a34.transaction(Cf, "readwrite"), s34 = i36.objectStore(Cf), u31 = s34.get(t9);
                            u31.onsuccess = function() {
                                if (null == u31.result) return a34.close(), r34(new Error("Cannot find model with path '" + t9 + "' in IndexedDB."));
                                var o45 = s34.delete(t9), i37 = function() {
                                    var o46 = (e17 = a34.transaction(wf, "readwrite")).objectStore(wf).delete(t9);
                                    o46.onsuccess = function() {
                                        return n25(u31.result.modelArtifactsInfo);
                                    }, o46.onerror = function(t10) {
                                        return r34(u31.error);
                                    };
                                };
                                o45.onsuccess = i37, o45.onerror = function(t10) {
                                    return i37(), a34.close(), r34(u31.error);
                                };
                            }, u31.onerror = function(t10) {
                                return a34.close(), r34(u31.error);
                            }, i36.oncomplete = function() {
                                null == e17 ? a34.close() : e17.oncomplete = function() {
                                    return a34.close();
                                };
                            };
                        }, o32.onerror = function(t10) {
                            return r34(o32.error);
                        };
                    })
                ];
            });
        });
    }, t1;
}();
if (i15().getBool("IS_BROWSER")) try {
    yf.registerManager(If.URL_SCHEME, new Sf);
} catch (t1) {
}
var Af = "/", Df = "tensorflowjs_models", Tf = "info", Nf = "model_topology", Ff = "weight_specs", _f = "weight_data", Of = "model_metadata";
function Mf(t1) {
    return {
        info: [
            Df,
            t1,
            Tf
        ].join(Af),
        topology: [
            Df,
            t1,
            Nf
        ].join(Af),
        weightSpecs: [
            Df,
            t1,
            Ff
        ].join(Af),
        weightData: [
            Df,
            t1,
            _f
        ].join(Af),
        modelMetadata: [
            Df,
            t1,
            Of
        ].join(Af)
    };
}
function Bf(t1) {
    var e16 = t1.split(Af);
    if (e16.length < 3) throw new Error("Invalid key format: " + t1);
    return e16.slice(1, e16.length - 1).join(Af);
}
var Pf = function() {
    function t1(t9) {
        if (!i15().getBool("IS_BROWSER") || "undefined" == typeof window || (void 0) === window.localStorage) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, null == t9 || !t9) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = t9, this.keys = Mf(this.modelPath);
    }
    return t1.prototype.save = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24, o32;
            return r17(this, function(r33) {
                if (t9.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                e16 = JSON.stringify(t9.modelTopology), n24 = JSON.stringify(t9.weightSpecs), o32 = vf(t9);
                try {
                    return this.LS.setItem(this.keys.info, JSON.stringify(o32)), this.LS.setItem(this.keys.topology, e16), this.LS.setItem(this.keys.weightSpecs, n24), this.LS.setItem(this.keys.weightData, function(t10) {
                        if (hf) return Buffer.from(t10).toString("base64");
                        for(var e17 = new Uint8Array(t10), n25 = "", r34 = 0, o45 = e17.length; r34 < o45; r34++)n25 += String.fromCharCode(e17[r34]);
                        return btoa(n25);
                    }(t9.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
                        format: t9.format,
                        generatedBy: t9.generatedBy,
                        convertedBy: t9.convertedBy,
                        userDefinedMetadata: t9.userDefinedMetadata
                    })), [
                        2,
                        {
                            modelArtifactsInfo: o32
                        }
                    ];
                } catch (t10) {
                    throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o32.modelTopologyBytes + ", weightSpecsBytes=" + o32.weightSpecsBytes + ", weightDataBytes=" + o32.weightDataBytes + ".");
                }
                return [
                    2
                ];
            });
        });
    }, t1.prototype.load = function() {
        return n10(this, void 0, void 0, function() {
            var t9, e16, n24, o32, a34, i36, s34;
            return r17(this, function(r33) {
                if (null == (t9 = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                if ("JSON" !== t9.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                if (e16 = {
                }, null == (n24 = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
                if (e16.modelTopology = n24, null == (o32 = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
                if (e16.weightSpecs = o32, null != (a34 = this.LS.getItem(this.keys.modelMetadata)) && (i36 = JSON.parse(a34), e16.format = i36.format, e16.generatedBy = i36.generatedBy, e16.convertedBy = i36.convertedBy, e16.userDefinedMetadata = i36.userDefinedMetadata), null == (s34 = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
                return e16.weightData = (function(t10) {
                    if (hf) {
                        var e17 = Buffer.from(t10, "base64");
                        return e17.buffer.slice(e17.byteOffset, e17.byteOffset + e17.byteLength);
                    }
                    for(var n25 = atob(t10), r34 = new Uint8Array(n25.length), o45 = 0; o45 < n25.length; ++o45)r34.set([
                        n25.charCodeAt(o45)
                    ], o45);
                    return r34.buffer;
                })(s34), [
                    2,
                    e16
                ];
            });
        });
    }, t1.URL_SCHEME = "localstorage://", t1;
}(), Lf = function(t1) {
    var e16;
    return i15().getBool("IS_BROWSER") && !Array.isArray(t1) && t1.startsWith(Pf.URL_SCHEME) ? (e16 = t1.slice(Pf.URL_SCHEME.length), new Pf(e16)) : null;
};
mf.registerSaveRouter(Lf), mf.registerLoadRouter(Lf);
var Wf = function() {
    function t1() {
        C(i15().getBool("IS_BROWSER"), function() {
            return "Current environment is not a web browser";
        }), C("undefined" == typeof window || (void 0) !== window.localStorage, function() {
            return "Current browser does not appear to support localStorage";
        }), this.LS = window.localStorage;
    }
    return t1.prototype.listModels = function() {
        return n10(this, void 0, void 0, function() {
            var t9, e16, n24, o32, a34, i36;
            return r17(this, function(r33) {
                for(t9 = {
                }, e16 = Df + Af, n24 = Af + Tf, o32 = 0; o32 < this.LS.length; ++o32)(a34 = this.LS.key(o32)).startsWith(e16) && a34.endsWith(n24) && (i36 = Bf(a34), t9[i36] = JSON.parse(this.LS.getItem(a34)));
                return [
                    2,
                    t9
                ];
            });
        });
    }, t1.prototype.removeModel = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24;
            return r17(this, function(r33) {
                var o32;
                if (t9 = (o32 = t9).startsWith(Pf.URL_SCHEME) ? o32.slice(Pf.URL_SCHEME.length) : o32, e16 = Mf(t9), null == this.LS.getItem(e16.info)) throw new Error("Cannot find model at path '" + t9 + "'");
                return n24 = JSON.parse(this.LS.getItem(e16.info)), this.LS.removeItem(e16.info), this.LS.removeItem(e16.topology), this.LS.removeItem(e16.weightSpecs), this.LS.removeItem(e16.weightData), [
                    2,
                    n24
                ];
            });
        });
    }, t1;
}();
if (i15().getBool("IS_BROWSER")) try {
    yf.registerManager(Pf.URL_SCHEME, new Wf);
} catch (t1) {
}
var Uf = "model", Vf = ".json", zf = ".weights.bin";
function Gf(t1) {
    return new Promise(function(t9) {
        return setTimeout(t9);
    }).then(t1);
}
var Hf = function() {
    function t1(e16) {
        if (!i15().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        e16.startsWith(t1.URL_SCHEME) && (e16 = e16.slice(t1.URL_SCHEME.length)), null != e16 && 0 !== e16.length || (e16 = Uf), this.modelTopologyFileName = e16 + Vf, this.weightDataFileName = e16 + zf;
    }
    return t1.prototype.save = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24, o32, a34, i36, s34;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                        if (e16 = window.URL.createObjectURL(new Blob([
                            t9.weightData
                        ], {
                            type: "application/octet-stream"
                        })), !(t9.modelTopology instanceof ArrayBuffer)) return [
                            3,
                            1
                        ];
                        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                    case 1:
                        return n24 = [
                            {
                                paths: [
                                    "./" + this.weightDataFileName
                                ],
                                weights: t9.weightSpecs
                            }
                        ], o32 = {
                            modelTopology: t9.modelTopology,
                            format: t9.format,
                            generatedBy: t9.generatedBy,
                            convertedBy: t9.convertedBy,
                            weightsManifest: n24
                        }, a34 = window.URL.createObjectURL(new Blob([
                            JSON.stringify(o32)
                        ], {
                            type: "application/json"
                        })), (i36 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i36.href = a34, [
                            4,
                            Gf(function() {
                                return i36.dispatchEvent(new MouseEvent("click"));
                            })
                        ];
                    case 2:
                        return r33.sent(), null == t9.weightData ? [
                            3,
                            4
                        ] : ((s34 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s34.href = e16, [
                            4,
                            Gf(function() {
                                return s34.dispatchEvent(new MouseEvent("click"));
                            })
                        ]);
                    case 3:
                        r33.sent(), r33.label = 4;
                    case 4:
                        return [
                            2,
                            {
                                modelArtifactsInfo: vf(t9)
                            }
                        ];
                }
            });
        });
    }, t1.URL_SCHEME = "downloads://", t1;
}(), qf = function() {
    function t1(t9) {
        if (null == t9 || t9.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t9);
        this.files = t9;
    }
    return t1.prototype.load = function() {
        return n10(this, void 0, void 0, function() {
            var t9, e16, n24 = this;
            return r17(this, function(r33) {
                return t9 = this.files[0], e16 = this.files.slice(1), [
                    2,
                    new Promise(function(r34, o32) {
                        var a34 = new FileReader;
                        a34.onload = function(a35) {
                            var i36 = JSON.parse(a35.target.result), s34 = i36.modelTopology;
                            if (null != s34) {
                                0 === e16.length && r34({
                                    modelTopology: s34
                                });
                                var u31 = i36.weightsManifest;
                                if (null != u31) {
                                    var c23;
                                    try {
                                        c23 = n24.checkManifestAndWeightFiles(u31, e16);
                                    } catch (t10) {
                                        return void o32(t10);
                                    }
                                    var l28 = [], h18 = [], f23 = [];
                                    u31.forEach(function(t10) {
                                        t10.paths.forEach(function(t11) {
                                            h18.push(t11), f23.push(null);
                                        }), l28.push.apply(l28, t10.weights);
                                    }), u31.forEach(function(t10) {
                                        t10.paths.forEach(function(t11) {
                                            var e18 = new FileReader;
                                            e18.onload = function(e19) {
                                                var n25 = e19.target.result, o45 = h18.indexOf(t11);
                                                f23[o45] = n25, -1 === f23.indexOf(null) && r34({
                                                    modelTopology: s34,
                                                    weightSpecs: l28,
                                                    weightData: df(f23),
                                                    format: i36.format,
                                                    generatedBy: i36.generatedBy,
                                                    convertedBy: i36.convertedBy,
                                                    userDefinedMetadata: i36.userDefinedMetadata
                                                });
                                            }, e18.onerror = function(e19) {
                                                return o32("Failed to weights data from file of path '" + t11 + "'.");
                                            }, e18.readAsArrayBuffer(c23[t11]);
                                        });
                                    });
                                } else o32(new Error("weightManifest field is missing from file " + t9.name));
                            } else o32(new Error("modelTopology field is missing from file " + t9.name));
                        }, a34.onerror = function(e18) {
                            return o32("Failed to read model topology and weights manifest JSON from file '" + t9.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
                        }, a34.readAsText(t9);
                    })
                ];
            });
        });
    }, t1.prototype.checkManifestAndWeightFiles = function(t9, e16) {
        for(var n24 = [], r33 = e16.map(function(t10) {
            return pf(t10.name);
        }), o32 = {
        }, a34 = 0, i36 = t9; a34 < i36.length; a34++)i36[a34].paths.forEach(function(t10) {
            var a35 = pf(t10);
            if (-1 !== n24.indexOf(a35)) throw new Error("Duplicate file basename found in weights manifest: '" + a35 + "'");
            if (n24.push(a35), -1 === r33.indexOf(a35)) throw new Error("Weight file with basename '" + a35 + "' is not provided.");
            o32[t10] = e16[r33.indexOf(a35)];
        });
        if (n24.length !== e16.length) throw new Error("Mismatch in the number of files in weights manifest (" + n24.length + ") and the number of weight files provided (" + e16.length + ").");
        return o32;
    }, t1;
}();
function Kf(t1, e16, n24, r33) {
    !function(t9) {
        C(null != t9 && Array.isArray(t9) && t9.length > 0, function() {
            return "promises must be a none empty array";
        });
    }(t1), (function(t9, e18) {
        C(t9 >= 0 && t9 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but got startFraction " + t9;
        }), C(e18 >= 0 && e18 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but got endFraction " + e18;
        }), C(e18 >= t9, function() {
            return "startFraction must be no more than endFraction, but got startFraction " + t9 + " and endFraction " + e18;
        });
    })(n24 = null == n24 ? 0 : n24, r33 = null == r33 ? 1 : r33);
    var o32 = 0;
    return Promise.all(t1.map(function(a34) {
        return a34.then(function(a35) {
            var i36 = n24 + (++o32) / t1.length * (r33 - n24);
            return e16(i36), a35;
        }), a34;
    }));
}
function jf(t1, e16) {
    return n10(this, void 0, void 0, function() {
        var n24, o32, a34, s34, u32, c24, l29, h19, f24;
        return r17(this, function(r33) {
            switch(r33.label){
                case 0:
                    return null == e16 && (e16 = {
                    }), n24 = null == e16.fetchFunc ? i15().platform.fetch : e16.fetchFunc, o32 = t1.map(function(t9) {
                        return n24(t9, e16.requestInit, {
                            isBinary: !0
                        });
                    }), a34 = 0, s34 = 0.5, null != e16.onProgress ? [
                        3,
                        2
                    ] : [
                        4,
                        Promise.all(o32)
                    ];
                case 1:
                    return u32 = r33.sent(), [
                        3,
                        4
                    ];
                case 2:
                    return [
                        4,
                        Kf(o32, e16.onProgress, a34, s34)
                    ];
                case 3:
                    u32 = r33.sent(), r33.label = 4;
                case 4:
                    return c24 = u32.map(function(t9) {
                        return t9.arrayBuffer();
                    }), l29 = 0.5, h19 = 1, null != e16.onProgress ? [
                        3,
                        6
                    ] : [
                        4,
                        Promise.all(c24)
                    ];
                case 5:
                    return f24 = r33.sent(), [
                        3,
                        8
                    ];
                case 6:
                    return [
                        4,
                        Kf(c24, e16.onProgress, l29, h19)
                    ];
                case 7:
                    f24 = r33.sent(), r33.label = 8;
                case 8:
                    return [
                        2,
                        f24
                    ];
            }
        });
    });
}
function Xf(t1) {
    var e16 = this;
    return function(o32, a34, i36) {
        return (void 0) === a34 && (a34 = ""), n10(e16, void 0, void 0, function() {
            var e18, n24, s34, u32, c24, l29, h19, f24, d21, p20;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        if (e18 = o32.map(function() {
                            return !1;
                        }), n24 = {
                        }, s34 = null != i36 ? i36.map(function() {
                            return !1;
                        }) : [], u32 = [], o32.forEach(function(t9, r34) {
                            var o45 = 0;
                            t9.weights.forEach(function(t10) {
                                var a35 = "quantization" in t10 ? t10.quantization.dtype : t10.dtype, c25 = sf[a35] * k(t10.shape), l30 = function() {
                                    e18[r34] = !0, null == n24[r34] && (n24[r34] = []), n24[r34].push({
                                        manifestEntry: t10,
                                        groupOffset: o45,
                                        sizeBytes: c25
                                    });
                                };
                                null != i36 ? i36.forEach(function(e19, n25) {
                                    e19 === t10.name && (l30(), s34[n25] = !0);
                                }) : l30(), u32.push(t10.name), o45 += c25;
                            });
                        }), !s34.every(function(t9) {
                            return t9;
                        })) throw c24 = i36.filter(function(t9, e19) {
                            return !s34[e19];
                        }), new Error("Could not find weights in manifest with names: " + c24.join(", ") + ". \nManifest JSON has weights with names: " + u32.join(", ") + ".");
                        return l29 = e18.reduce(function(t9, e19, n25) {
                            return e19 && t9.push(n25), t9;
                        }, []), h19 = [], l29.forEach(function(t9) {
                            o32[t9].paths.forEach(function(t10) {
                                var e19 = a34 + (a34.endsWith("/") ? "" : "/") + t10;
                                h19.push(e19);
                            });
                        }), [
                            4,
                            t1(h19)
                        ];
                    case 1:
                        return f24 = r33.sent(), d21 = {
                        }, p20 = 0, l29.forEach(function(t9) {
                            for(var e19 = o32[t9].paths.length, r34 = 0, a35 = 0; a35 < e19; a35++)r34 += f24[p20 + a35].byteLength;
                            for(var i37 = new ArrayBuffer(r34), s35 = new Uint8Array(i37), u33 = 0, c25 = 0; c25 < e19; c25++){
                                var l30 = new Uint8Array(f24[p20 + c25]);
                                s35.set(l30, u33), u33 += l30.byteLength;
                            }
                            n24[t9].forEach(function(t10) {
                                var e20 = cf(i37.slice(t10.groupOffset, t10.groupOffset + t10.sizeBytes), [
                                    t10.manifestEntry
                                ]);
                                for(var n25 in e20)d21[n25] = e20[n25];
                            }), p20 += e19;
                        }), [
                            2,
                            d21
                        ];
                }
            });
        });
    };
}
mf.registerSaveRouter(function(t1) {
    return i15().getBool("IS_BROWSER") && !Array.isArray(t1) && t1.startsWith(Hf.URL_SCHEME) ? (function(t9) {
        (void 0) === t9 && (t9 = "model");
        return new Hf(t9);
    })(t1.slice(Hf.URL_SCHEME.length)) : null;
});
var Yf = function() {
    function t1(t9, e16) {
        if (this.DEFAULT_METHOD = "POST", null == e16 && (e16 = {
        }), this.weightPathPrefix = e16.weightPathPrefix, this.onProgress = e16.onProgress, null != e16.fetchFunc ? (C("function" == typeof e16.fetchFunc, function() {
            return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
        }), this.fetch = e16.fetchFunc) : this.fetch = i15().platform.fetch, C(null != t9 && t9.length > 0, function() {
            return "URL path for http must not be null, undefined or empty.";
        }), Array.isArray(t9) && C(2 === t9.length, function() {
            return "URL paths for http must have a length of 2, (actual length is " + t9.length + ").";
        }), this.path = t9, null != e16.requestInit && null != e16.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        this.requestInit = e16.requestInit || {
        };
    }
    return t1.prototype.save = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24, o32, a34;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        if (t9.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                        return (e16 = Object.assign({
                            method: this.DEFAULT_METHOD
                        }, this.requestInit)).body = new FormData, n24 = [
                            {
                                paths: [
                                    "./model.weights.bin"
                                ],
                                weights: t9.weightSpecs
                            }
                        ], o32 = {
                            modelTopology: t9.modelTopology,
                            format: t9.format,
                            generatedBy: t9.generatedBy,
                            convertedBy: t9.convertedBy,
                            userDefinedMetadata: t9.userDefinedMetadata,
                            weightsManifest: n24
                        }, e16.body.append("model.json", new Blob([
                            JSON.stringify(o32)
                        ], {
                            type: "application/json"
                        }), "model.json"), null != t9.weightData && e16.body.append("model.weights.bin", new Blob([
                            t9.weightData
                        ], {
                            type: "application/octet-stream"
                        }), "model.weights.bin"), [
                            4,
                            this.fetch(this.path, e16)
                        ];
                    case 1:
                        if ((a34 = r33.sent()).ok) return [
                            2,
                            {
                                modelArtifactsInfo: vf(t9),
                                responses: [
                                    a34
                                ]
                            }
                        ];
                        throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a34.status + ".");
                }
            });
        });
    }, t1.prototype.load = function() {
        return n10(this, void 0, void 0, function() {
            var t9, e16, n24, o32, a34, i36, s34, u32, c24, l29, h19, f24;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        return [
                            4,
                            this.fetch(this.path, this.requestInit)
                        ];
                    case 1:
                        if (!(t9 = r33.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t9.status + ". Please verify this URL points to the model JSON of the model to load.");
                        r33.label = 2;
                    case 2:
                        return r33.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]), [
                            4,
                            t9.json()
                        ];
                    case 3:
                        return e16 = r33.sent(), [
                            3,
                            5
                        ];
                    case 4:
                        throw r33.sent(), n24 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n24 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n24 += " Please make sure the server is serving valid JSON for this request.", new Error(n24);
                    case 5:
                        if (o32 = e16.modelTopology, a34 = e16.weightsManifest, i36 = e16.generatedBy, s34 = e16.convertedBy, u32 = e16.format, c24 = e16.userDefinedMetadata, null == o32 && null == a34) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
                        return null == a34 ? [
                            3,
                            7
                        ] : [
                            4,
                            this.loadWeights(a34)
                        ];
                    case 6:
                        f24 = r33.sent(), l29 = f24[0], h19 = f24[1], r33.label = 7;
                    case 7:
                        return [
                            2,
                            {
                                modelTopology: o32,
                                weightSpecs: l29,
                                weightData: h19,
                                userDefinedMetadata: c24,
                                generatedBy: i36,
                                convertedBy: s34,
                                format: u32
                            }
                        ];
                }
            });
        });
    }, t1.prototype.loadWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24, o32, a34, i36, s34, u32, c24, l29, h19, f24;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        for(e16 = Array.isArray(this.path) ? this.path[1] : this.path, n24 = (function(t10) {
                            var e18 = t10.lastIndexOf("/"), n25 = t10.lastIndexOf("?"), r34 = t10.substring(0, e18), o45 = n25 > e18 ? t10.substring(n25) : "";
                            return [
                                r34 + "/",
                                o45
                            ];
                        })(e16), o32 = n24[0], a34 = n24[1], i36 = this.weightPathPrefix || o32, s34 = [], u32 = 0, c24 = t9; u32 < c24.length; u32++)l29 = c24[u32], s34.push.apply(s34, l29.weights);
                        return h19 = [], t9.forEach(function(t10) {
                            t10.paths.forEach(function(t11) {
                                h19.push(i36 + t11 + a34);
                            });
                        }), [
                            4,
                            jf(h19, {
                                requestInit: this.requestInit,
                                fetchFunc: this.fetch,
                                onProgress: this.onProgress
                            })
                        ];
                    case 1:
                        return f24 = r33.sent(), [
                            2,
                            [
                                s34,
                                df(f24)
                            ]
                        ];
                }
            });
        });
    }, t1.URL_SCHEME_REGEX = /^https?:\/\//, t1;
}();
function $f(t1) {
    return null != t1.match(Yf.URL_SCHEME_REGEX);
}
var Qf = function(t1, e16) {
    if ("undefined" == typeof fetch) return null;
    return (Array.isArray(t1) ? t1.every(function(t9) {
        return $f(t9);
    }) : $f(t1)) ? Jf(t1, {
        onProgress: e16
    }) : null;
};
function Jf(t1, e16) {
    return new Yf(t1, e16);
}
mf.registerSaveRouter(Qf), mf.registerLoadRouter(Qf);
var Zf = function() {
    function t1(t9) {
        this.modelArtifacts = t9;
    }
    return t1.prototype.load = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                return [
                    2,
                    this.modelArtifacts
                ];
            });
        });
    }, t1;
}(), td = function() {
    function t1(t9) {
        this.saveHandler = t9;
    }
    return t1.prototype.save = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e16) {
                return [
                    2,
                    this.saveHandler(t9)
                ];
            });
        });
    }, t1;
}();
var ed = Object.freeze({
    browserFiles: function(t1) {
        return new qf(t1);
    },
    browserHTTPRequest: function(t1, e16) {
        return Jf(t1, e16);
    },
    concatenateArrayBuffers: df,
    decodeWeights: cf,
    encodeWeights: function(t1, e16) {
        return n10(this, void 0, void 0, function() {
            var o32, a34, i36, s34, u32, c24 = this;
            return r17(this, function(l29) {
                switch(l29.label){
                    case 0:
                        for(o32 = [], a34 = [], i36 = Array.isArray(t1) ? t1.map(function(t9) {
                            return t9.name;
                        }) : Object.keys(t1), s34 = function(s35) {
                            var u33 = i36[s35], l31 = Array.isArray(t1) ? t1[s35].tensor : t1[u33];
                            if ("float32" !== l31.dtype && "int32" !== l31.dtype && "bool" !== l31.dtype && "string" !== l31.dtype) throw new Error("Unsupported dtype in weight '" + u33 + "': " + l31.dtype);
                            var h19 = {
                                name: u33,
                                shape: l31.shape,
                                dtype: l31.dtype
                            };
                            if ("string" === l31.dtype) {
                                var f24 = new Promise(function(t9) {
                                    return n10(c24, void 0, void 0, function() {
                                        var e18, n24, o45, a35, i37, s36, u34;
                                        return r17(this, function(r33) {
                                            switch(r33.label){
                                                case 0:
                                                    return [
                                                        4,
                                                        l31.bytes()
                                                    ];
                                                case 1:
                                                    for(e18 = r33.sent(), n24 = e18.reduce(function(t10, e19) {
                                                        return t10 + e19.length;
                                                    }, 0) + uf * e18.length, o45 = new Uint8Array(n24), a35 = 0, i37 = 0; i37 < e18.length; i37++)s36 = e18[i37], u34 = new Uint8Array(new Uint32Array([
                                                        s36.length
                                                    ]).buffer), o45.set(u34, a35), a35 += uf, o45.set(s36, a35), a35 += s36.length;
                                                    return t9(o45), [
                                                        2
                                                    ];
                                            }
                                        });
                                    });
                                });
                                a34.push(f24);
                            } else a34.push(l31.data());
                            null != e16 && (h19.group = e16), o32.push(h19);
                        }, u32 = 0; u32 < i36.length; ++u32)s34(u32);
                        return [
                            4,
                            Promise.all(a34)
                        ];
                    case 1:
                        return [
                            2,
                            {
                                data: lf(l29.sent()),
                                specs: o32
                            }
                        ];
                }
            });
        });
    },
    fromMemory: function(t1, e16, n24, r33) {
        return 1 === arguments.length ? null != t1.modelTopology || null != t1.weightSpecs ? new Zf(t1) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({
            modelTopology: t1
        })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({
            modelTopology: t1,
            weightSpecs: e16,
            weightData: n24,
            trainingConfig: r33
        }));
    },
    getLoadHandlers: function(t1, e16) {
        return mf.getLoadHandlers(t1, e16);
    },
    getModelArtifactsInfoForJSON: vf,
    getSaveHandlers: function(t1) {
        return mf.getSaveHandlers(t1);
    },
    http: Jf,
    isHTTPScheme: $f,
    loadWeights: function(t1, e16, o32, a34) {
        return (void 0) === e16 && (e16 = ""), n10(this, void 0, void 0, function() {
            return r17(this, function(n24) {
                return [
                    2,
                    Xf(function(t9) {
                        return jf(t9, {
                            requestInit: a34
                        });
                    })(t1, e16, o32)
                ];
            });
        });
    },
    registerLoadRouter: function(t1) {
        return mf.registerLoadRouter(t1);
    },
    registerSaveRouter: function(t1) {
        return mf.registerSaveRouter(t1);
    },
    weightsLoaderFactory: Xf,
    withSaveHandler: function(t1) {
        return new td(t1);
    },
    copyModel: function(t1, e16) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(n24) {
                return [
                    2,
                    bf(t1, e16, !1)
                ];
            });
        });
    },
    listModels: function() {
        return n10(this, void 0, void 0, function() {
            var t1, e16, n24, o32, a34, i36, s34;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        t1 = yf.getSchemes(), e16 = {
                        }, n24 = 0, o32 = t1, r33.label = 1;
                    case 1:
                        return n24 < o32.length ? (a34 = o32[n24], [
                            4,
                            yf.getManager(a34).listModels()
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        for(s34 in i36 = r33.sent())e16[a34 + gf + s34] = i36[s34];
                        r33.label = 3;
                    case 3:
                        return n24++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            e16
                        ];
                }
            });
        });
    },
    moveModel: function(t1, e16) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(n24) {
                return [
                    2,
                    bf(t1, e16, !0)
                ];
            });
        });
    },
    removeModel: function(t1) {
        return n10(this, void 0, void 0, function() {
            var e16;
            return r17(this, function(n24) {
                return e16 = xf(t1), [
                    2,
                    yf.getManager(e16.scheme).removeModel(e16.path)
                ];
            });
        });
    }
});
var nd, rd = An({
    confusionMatrix_: function(t1, e16, n24) {
        var r33 = mn(t1, "labels", "confusionMatrix"), o32 = mn(e16, "predictions", "confusionMatrix");
        C(null == n24 || n24 > 0 && Number.isInteger(n24), function() {
            return "If provided, numClasses must be a positive integer, but got " + n24;
        }), C(1 === r33.rank, function() {
            return "Expected the rank of labels to be 1, but got " + r33.rank;
        }), C(1 === o32.rank, function() {
            return "Expected the rank of predictions to be 1, but got " + o32.rank;
        }), C(r33.shape[0] === o32.shape[0], function() {
            return "Mismatch in the number of examples: " + r33.shape[0] + " vs. " + o32.shape[0] + ". Labels and predictions should have the same number of elements.";
        }), C(n24 > 0 && Number.isInteger(n24), function() {
            return "numClasses is required to be a positive integer, but got " + n24;
        });
        var a34 = Rr(r33.asType("int32"), n24), i36 = Rr(o32.asType("int32"), n24);
        return a34.transpose().matMul(i36).asType("int32");
    }
}), od = Object.freeze({
    confusionMatrix: rd
});
var ad = An({
    fromPixels_: function(t1, e16) {
        if ((void 0) === e16 && (e16 = 3), e16 > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == t1) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n24 = !1, r33 = !1, o32 = !1, a34 = !1, i36 = !1;
        if (t1.data instanceof Uint8Array) n24 = !0;
        else if ("undefined" != typeof ImageData && t1 instanceof ImageData) r33 = !0;
        else if ("undefined" != typeof HTMLVideoElement && t1 instanceof HTMLVideoElement) o32 = !0;
        else if ("undefined" != typeof HTMLImageElement && t1 instanceof HTMLImageElement) a34 = !0;
        else {
            if (null == t1.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t1.constructor.name);
            i36 = !0;
        }
        if (o32) {
            if (o32 && t1.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        }
        if (null != l("FromPixels", Lt.backendName)) return Lt.runKernel("FromPixels", {
            pixels: t1
        }, {
            numChannels: e16
        });
        var s34, u32, c24 = o32 ? [
            t1.videoWidth,
            t1.videoHeight
        ] : [
            t1.width,
            t1.height
        ], h19 = c24[0], f25 = c24[1];
        if (i36 ? s34 = t1.getContext("2d").getImageData(0, 0, h19, f25).data : r33 || n24 ? s34 = t1.data : (a34 || o32) && (null == nd && (nd = document.createElement("canvas").getContext("2d")), nd.canvas.width = h19, nd.canvas.height = f25, nd.drawImage(t1, 0, 0, h19, f25), s34 = nd.getImageData(0, 0, h19, f25).data), 4 === e16) u32 = new Int32Array(s34);
        else {
            var d21 = h19 * f25;
            u32 = new Int32Array(d21 * e16);
            for(var p20 = 0; p20 < d21; p20++)for(var v20 = 0; v20 < e16; ++v20)u32[p20 * e16 + v20] = s34[4 * p20 + v20];
        }
        return Pn(u32, [
            f25,
            h19,
            e16
        ], "int32");
    }
}), id = Object.freeze({
    toPixels: function(t1, e16) {
        return n10(this, void 0, void 0, function() {
            var n24, o32, a34, i36, s34, u32, c24, l29, h19, f25, d22, p21, v21, m19, g19, y13, x11, b9, w12, C9, E11, R11, I12;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        if (n24 = mn(t1, "img", "toPixels"), t1 instanceof wt || (n24 = n24.toInt()), 2 !== n24.rank && 3 !== n24.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n24.rank + ".");
                        if (o32 = n24.shape.slice(0, 2), a34 = o32[0], i36 = o32[1], (s34 = 2 === n24.rank ? 1 : n24.shape[2]) > 4 || 2 === s34) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s34);
                        return [
                            4,
                            n24.data()
                        ];
                    case 1:
                        return u32 = r33.sent(), c24 = n24.min(), l29 = n24.max(), [
                            4,
                            Promise.all([
                                c24.data(),
                                l29.data()
                            ])
                        ];
                    case 2:
                        if (h19 = r33.sent(), f25 = h19[0], d22 = h19[1], p21 = f25[0], v21 = d22[0], c24.dispose(), l29.dispose(), "float32" === n24.dtype) {
                            if (p21 < 0 || v21 > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p21 + " - " + v21 + "].");
                        } else {
                            if ("int32" !== n24.dtype) throw new Error("Unsupported type for toPixels: " + n24.dtype + ". Please use float32 or int32 tensors.");
                            if (p21 < 0 || v21 > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p21 + " - " + v21 + "].");
                        }
                        for(m19 = "float32" === n24.dtype ? 255 : 1, g19 = new Uint8ClampedArray(i36 * a34 * 4), y13 = 0; y13 < a34 * i36; ++y13)x11 = void 0, b9 = void 0, w12 = void 0, C9 = void 0, 1 === s34 ? (x11 = u32[y13] * m19, b9 = u32[y13] * m19, w12 = u32[y13] * m19, C9 = 255) : 3 === s34 ? (x11 = u32[3 * y13] * m19, b9 = u32[3 * y13 + 1] * m19, w12 = u32[3 * y13 + 2] * m19, C9 = 255) : 4 === s34 && (x11 = u32[4 * y13] * m19, b9 = u32[4 * y13 + 1] * m19, w12 = u32[4 * y13 + 2] * m19, C9 = u32[4 * y13 + 3] * m19), g19[(E11 = 4 * y13) + 0] = Math.round(x11), g19[E11 + 1] = Math.round(b9), g19[E11 + 2] = Math.round(w12), g19[E11 + 3] = Math.round(C9);
                        return null != e16 && (e16.width = i36, e16.height = a34, R11 = e16.getContext("2d"), I12 = new ImageData(g19, i36, a34), R11.putImageData(I12, 0, 0)), n24 !== t1 && n24.dispose(), [
                            2,
                            g19
                        ];
                }
            });
        });
    },
    fromPixels: ad
}), sd = function() {
    function t1() {
    }
    return t1.prototype.getClassName = function() {
        return this.constructor.className;
    }, t1.fromConfig = function(t9, e16) {
        return new t9(e16);
    }, t1;
}(), ud = function() {
    function t1() {
        this.classNameMap = {
        };
    }
    return t1.getMap = function() {
        return null == t1.instance && (t1.instance = new t1), t1.instance;
    }, t1.register = function(e16) {
        t1.getMap().classNameMap[e16.className] = [
            e16,
            e16.fromConfig
        ];
    }, t1;
}();
function cd(t1) {
    C(null != t1.className, function() {
        return "Class being registered does not have the static className property defined.";
    }), C("string" == typeof t1.className, function() {
        return "className is required to be a string, but got type " + typeof t1.className;
    }), C(t1.className.length > 0, function() {
        return "Class being registered has an empty-string as its className, which is disallowed.";
    }), ud.register(t1);
}
var ld = Object.freeze({
    Serializable: sd,
    SerializationMap: ud,
    registerClass: cd
}), hd = 0.001, fd = 0.1;
function dd() {
    return 32 === Lt.backend.floatPrecision() ? hd : fd;
}
function pd(t1, e16, n24) {
    var r33 = !0;
    if ((V(t1) || V(e16)) && (r33 = !1), V(t1) && V(e16) && (r33 = !0), r33) {
        var o32 = t1.constructor.name, a34 = e16.constructor.name;
        if (o32 !== a34) throw new Error("Arrays are of different type. Actual: " + o32 + ". Expected: " + a34);
    }
    if (Array.isArray(t1) && Array.isArray(e16)) {
        var i36 = pn(t1), s34 = pn(e16);
        if (!S(i36, s34)) throw new Error("Arrays have different shapes. Actual: [" + i36 + "]. Expected: [" + s34 + "]");
    }
    var u32 = V(t1) ? t1 : I(t1), c24 = V(e16) ? e16 : I(e16);
    if (u32.length !== c24.length) throw new Error("Arrays have different lengths actual: " + u32.length + " vs expected: " + c24.length + ".\nActual:   " + u32 + ".\nExpected: " + c24 + ".");
    for(var l29 = 0; l29 < c24.length; ++l29){
        var h19 = u32[l29], f25 = c24[l29];
        if (!n24(h19, f25)) throw new Error("Arrays differ: actual[" + l29 + "] = " + h19 + ", expected[" + l29 + "] = " + f25 + ".\nActual:   " + u32 + ".\nExpected: " + c24 + ".");
    }
}
function vd(t1, e16, n24) {
    return !isFinite(t1) && !isFinite(e16) || !(isNaN(t1) || isNaN(e16) || Math.abs(t1 - e16) > n24);
}
var md = Object.freeze({
    TEST_EPSILON_FLOAT16: fd,
    expectArraysClose: function(t1, e16, n24) {
        return null == n24 && (n24 = dd()), pd(t1, e16, function(t9, e18) {
            return vd(t9, e18, n24);
        });
    },
    testEpsilon: dd,
    expectPromiseToFail: function(t1, e16) {
        t1().then(function() {
            return e16.fail();
        }, function() {
            return e16();
        });
    },
    expectArraysEqual: function(t1, e16) {
        var n24 = "string" == typeof e16 || "number" == typeof e16 || "boolean" == typeof e16 ? [
            e16
        ] : e16;
        return H(t1) || H(t1[0]) || H(e16) || H(e16[0]) ? pd(t1, n24, function(t9, e18) {
            return t9 == e18;
        }) : pd(t1, e16, function(t9, e18) {
            return vd(t9, e18, 0);
        });
    },
    expectNumbersClose: function(t1, e16, n24) {
        if (null == n24 && (n24 = dd()), !vd(t1, e16, n24)) throw new Error("Numbers differ: actual === " + t1 + ", expected === " + e16);
    },
    expectValuesInRange: function(t1, e16, n24) {
        for(var r33 = 0; r33 < t1.length; r33++)if (t1[r33] < e16 || t1[r33] > n24) throw new Error("Value out of range:" + t1[r33] + " low: " + e16 + ", high: " + n24);
    },
    expectArrayBuffersEqual: function(t1, e16) {
        expect(new Float32Array(t1)).toEqual(new Float32Array(e16));
    }
}), gd = "1.7.0";
var yd = Object.freeze({
    gpgpu_util: Mi,
    webgl_util: Ge,
    forceHalfFloat: function() {
        i15().set("WEBGL_FORCE_F16_TEXTURES", !0);
    },
    MathBackendWebGL: Zs,
    setWebGLContext: Kt,
    GPGPUContext: Bi
}), xd = function(t1) {
    function o45() {
        return null !== t1 && t1.apply(this, arguments) || this;
    }
    return e(o45, t1), o45.prototype.minimize = function(t9, e16, n24) {
        (void 0) === e16 && (e16 = !1);
        var r33 = this.computeGradients(t9, n24), o46 = r33.value, a35 = r33.grads;
        if (null != n24) {
            var i37 = n24.map(function(t10) {
                return {
                    name: t10.name,
                    tensor: a35[t10.name]
                };
            });
            this.applyGradients(i37);
        } else this.applyGradients(a35);
        return tn(a35), e16 ? o46 : (o46.dispose(), null);
    }, Object.defineProperty(o45.prototype, "iterations", {
        get: function() {
            return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
        },
        enumerable: !0,
        configurable: !0
    }), o45.prototype.incrementIterations = function() {
        this.iterations_ = this.iterations + 1;
    }, o45.prototype.computeGradients = function(t9, e16) {
        return po(t9, e16);
    }, o45.prototype.dispose = function() {
        null != this.iterations_ && tn(this.iterations_);
    }, o45.prototype.saveIterations = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                return null == this.iterations_ && (this.iterations_ = 0), [
                    2,
                    {
                        name: "iter",
                        tensor: On(this.iterations_, "int32")
                    }
                ];
            });
        });
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                throw new Error("getWeights() is not implemented for this optimizer yet.");
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t10) {
                throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
            });
        });
    }, o45.prototype.extractIterations = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16;
            return r17(this, function(n24) {
                switch(n24.label){
                    case 0:
                        return e16 = this, [
                            4,
                            t9[0].tensor.data()
                        ];
                    case 1:
                        return e16.iterations_ = n24.sent()[0], [
                            2,
                            t9.slice(1)
                        ];
                }
            });
        });
    }, o45;
}(sd);
Object.defineProperty(xd, Symbol.hasInstance, {
    value: function(t1) {
        return null != t1.minimize && null != t1.computeGradients && null != t1.applyGradients;
    }
});
var bd = function(t1) {
    function o45(e16, n24, r33) {
        (void 0) === r33 && (r33 = null);
        var o46 = t1.call(this) || this;
        return o46.learningRate = e16, o46.rho = n24, o46.epsilon = r33, o46.accumulatedGrads = [], o46.accumulatedUpdates = [], null == r33 && (o46.epsilon = Lt.backend.epsilon()), o46;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this;
        (Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9)).forEach(function(n24, r33) {
            var o46 = Lt.registeredVariables[n24];
            null == e16.accumulatedGrads[r33] && (e16.accumulatedGrads[r33] = {
                originalName: n24 + "/accum_grad",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            }), null == e16.accumulatedUpdates[r33] && (e16.accumulatedUpdates[r33] = {
                originalName: n24 + "/accum_var",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            });
            var a35 = Array.isArray(t9) ? t9[r33].tensor : t9[n24];
            if (null != a35) {
                var i38 = e16.accumulatedGrads[r33].variable, s35 = e16.accumulatedUpdates[r33].variable;
                Ze(function() {
                    var t10 = i38.mul(e16.rho).add(a35.square().mul(1 - e16.rho)), n25 = s35.add(e16.epsilon).sqrt().div(i38.add(e16.epsilon).sqrt()).mul(a35), r34 = s35.mul(e16.rho).add(n25.square().mul(1 - e16.rho));
                    i38.assign(t10), s35.assign(r34);
                    var u32 = n25.mul(-e16.learningRate).add(o46);
                    o46.assign(u32);
                });
            }
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function(t9) {
            return t9.variable;
        })), tn(this.accumulatedUpdates.map(function(t9) {
            return t9.variable;
        })));
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            var t9;
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return t9 = this.accumulatedGrads.concat(this.accumulatedUpdates), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e16.sent()
                            ].concat(t9.map(function(t10) {
                                return {
                                    name: t10.originalName,
                                    tensor: t10.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16;
            return r17(this, function(n24) {
                switch(n24.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        return t9 = n24.sent(), e16 = t9.length / 2, this.accumulatedGrads = t9.slice(0, e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), this.accumulatedUpdates = t9.slice(e16, 2 * e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.rho, e16.epsilon);
    }, o45.className = "Adadelta", o45;
}(xd);
cd(bd);
var wd = function(t1) {
    function o45(e16, n24) {
        (void 0) === n24 && (n24 = 0.1);
        var r33 = t1.call(this) || this;
        return r33.learningRate = e16, r33.initialAccumulatorValue = n24, r33.accumulatedGrads = [], r33;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this;
        (Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9)).forEach(function(n24, r33) {
            var o46 = Lt.registeredVariables[n24];
            if (null == e16.accumulatedGrads[r33]) e16.accumulatedGrads[r33] = {
                originalName: n24 + "/accumulator",
                variable: Ze(function() {
                    return Hn(o46.shape, e16.initialAccumulatorValue).variable(!1);
                })
            };
            var a35 = Array.isArray(t9) ? t9[r33].tensor : t9[n24];
            if (null != a35) {
                var i39 = e16.accumulatedGrads[r33].variable;
                Ze(function() {
                    var t10 = i39.add(a35.square());
                    i39.assign(t10);
                    var n25 = a35.div(t10.add(Lt.backend.epsilon()).sqrt()).mul(-e16.learningRate).add(o46);
                    o46.assign(n25);
                });
            }
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function(t9) {
            return t9.variable;
        }));
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                switch(t9.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t9.sent()
                            ].concat(this.accumulatedGrads.map(function(t10) {
                                return {
                                    name: t10.originalName,
                                    tensor: t10.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        return t9 = e16.sent(), this.accumulatedGrads = t9.map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.initialAccumulatorValue);
    }, o45.className = "Adagrad", o45;
}(xd);
cd(wd);
var Cd = function(t1) {
    function o45(e16, n24, r33, o46) {
        (void 0) === o46 && (o46 = null);
        var a35 = t1.call(this) || this;
        return a35.learningRate = e16, a35.beta1 = n24, a35.beta2 = r33, a35.epsilon = o46, a35.accumulatedFirstMoment = [], a35.accumulatedSecondMoment = [], Ze(function() {
            a35.accBeta1 = On(n24).variable(), a35.accBeta2 = On(r33).variable();
        }), null == o46 && (a35.epsilon = Lt.backend.epsilon()), a35;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this, n24 = Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9);
        Ze(function() {
            var r33 = Cc(1, e16.accBeta1), o46 = Cc(1, e16.accBeta2);
            n24.forEach(function(n25, a35) {
                var i40 = Lt.registeredVariables[n25];
                null == e16.accumulatedFirstMoment[a35] && (e16.accumulatedFirstMoment[a35] = {
                    originalName: n25 + "/m",
                    variable: Ze(function() {
                        return Xn(i40).variable(!1);
                    })
                }), null == e16.accumulatedSecondMoment[a35] && (e16.accumulatedSecondMoment[a35] = {
                    originalName: n25 + "/v",
                    variable: Ze(function() {
                        return Xn(i40).variable(!1);
                    })
                });
                var s36 = Array.isArray(t9) ? t9[a35].tensor : t9[n25];
                if (null != s36) {
                    var u32 = e16.accumulatedFirstMoment[a35].variable, c24 = e16.accumulatedSecondMoment[a35].variable, l29 = u32.mul(e16.beta1).add(s36.mul(1 - e16.beta1)), h20 = c24.mul(e16.beta2).add(s36.square().mul(1 - e16.beta2)), f26 = l29.div(r33), d22 = h20.div(o46);
                    u32.assign(l29), c24.assign(h20);
                    var p21 = f26.div(d22.sqrt().add(e16.epsilon)).mul(-e16.learningRate).add(i40);
                    i40.assign(p21);
                }
            }), e16.accBeta1.assign(e16.accBeta1.mul(e16.beta1)), e16.accBeta2.assign(e16.accBeta2.mul(e16.beta2));
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t9) {
            return t9.variable;
        })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function(t9) {
            return t9.variable;
        }));
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            var t9;
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return t9 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e16.sent()
                            ].concat(t9.map(function(t10) {
                                return {
                                    name: t10.originalName,
                                    tensor: t10.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16, n24 = this;
            return r17(this, function(r33) {
                switch(r33.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        return t9 = r33.sent(), Ze(function() {
                            n24.accBeta1.assign(xc(n24.beta1, n24.iterations_ + 1)), n24.accBeta2.assign(xc(n24.beta2, n24.iterations_ + 1));
                        }), e16 = t9.length / 2, this.accumulatedFirstMoment = t9.slice(0, e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), this.accumulatedSecondMoment = t9.slice(e16, 2 * e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.beta1, e16.beta2, e16.epsilon);
    }, o45.className = "Adam", o45;
}(xd);
cd(Cd);
var Ed = function(t1) {
    function o45(e16, n24, r33, o46, a35) {
        (void 0) === o46 && (o46 = null), (void 0) === a35 && (a35 = 0);
        var i40 = t1.call(this) || this;
        return i40.learningRate = e16, i40.beta1 = n24, i40.beta2 = r33, i40.epsilon = o46, i40.decay = a35, i40.accumulatedFirstMoment = [], i40.accumulatedWeightedInfNorm = [], Ze(function() {
            i40.iteration = On(0).variable(), i40.accBeta1 = On(n24).variable();
        }), null == o46 && (i40.epsilon = Lt.backend.epsilon()), i40;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this, n24 = Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9);
        Ze(function() {
            var r33 = Cc(1, e16.accBeta1), o46 = sc(-e16.learningRate, e16.iteration.mul(e16.decay).add(1));
            n24.forEach(function(n25, a35) {
                var i40 = Lt.registeredVariables[n25];
                null == e16.accumulatedFirstMoment[a35] && (e16.accumulatedFirstMoment[a35] = {
                    originalName: n25 + "/m",
                    variable: Xn(i40).variable(!1)
                }), null == e16.accumulatedWeightedInfNorm[a35] && (e16.accumulatedWeightedInfNorm[a35] = {
                    originalName: n25 + "/v",
                    variable: Xn(i40).variable(!1)
                });
                var s36 = Array.isArray(t9) ? t9[a35].tensor : t9[n25];
                if (null != s36) {
                    var u33 = e16.accumulatedFirstMoment[a35].variable, c25 = e16.accumulatedWeightedInfNorm[a35].variable, l31 = u33.mul(e16.beta1).add(s36.mul(1 - e16.beta1)), h21 = c25.mul(e16.beta2), f27 = s36.abs(), d23 = h21.maximum(f27);
                    u33.assign(l31), c25.assign(d23);
                    var p22 = o46.div(r33).mul(l31.div(d23.add(e16.epsilon))).add(i40);
                    i40.assign(p22);
                }
            }), e16.iteration.assign(e16.iteration.add(1)), e16.accBeta1.assign(e16.accBeta1.mul(e16.beta1));
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t9) {
            return t9.variable;
        })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function(t9) {
            return t9.variable;
        }));
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                throw new Error("getWeights() is not implemented for Adamax yet.");
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t10) {
                throw new Error("setWeights() is not implemented for Adamax yet.");
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.beta1, e16.beta2, e16.epsilon, e16.decay);
    }, o45.className = "Adamax", o45;
}(xd);
cd(Ed);
var Rd = function(t1) {
    function o45(e16) {
        var n24 = t1.call(this) || this;
        return n24.learningRate = e16, n24.setLearningRate(e16), n24;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this;
        (Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9)).forEach(function(n24, r33) {
            var o46 = Array.isArray(t9) ? t9[r33].tensor : t9[n24];
            if (null != o46) {
                var a35 = Lt.registeredVariables[n24];
                Ze(function() {
                    var t10 = e16.c.mul(o46).add(a35);
                    a35.assign(t10);
                });
            }
        }), this.incrementIterations();
    }, o45.prototype.setLearningRate = function(t9) {
        this.learningRate = t9, null != this.c && this.c.dispose(), this.c = en(On(-t9));
    }, o45.prototype.dispose = function() {
        this.c.dispose();
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                switch(t9.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t9.sent()
                            ]
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        if (0 !== (t9 = e16.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
                        return [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate);
    }, o45.className = "SGD", o45;
}(xd);
cd(Rd);
var Id = function(t1) {
    function o45(e16, n24, r33) {
        (void 0) === r33 && (r33 = !1);
        var o46 = t1.call(this, e16) || this;
        return o46.learningRate = e16, o46.momentum = n24, o46.useNesterov = r33, o46.accumulations = [], o46.m = On(o46.momentum), o46;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this;
        (Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9)).forEach(function(n24, r33) {
            var o46 = Lt.registeredVariables[n24];
            if (null == e16.accumulations[r33]) e16.accumulations[r33] = {
                originalName: n24 + "/momentum",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            };
            var a36 = e16.accumulations[r33].variable, i40 = Array.isArray(t9) ? t9[r33].tensor : t9[n24];
            null != i40 && Ze(function() {
                var t10, n25 = e16.m.mul(a36).add(i40);
                t10 = e16.useNesterov ? e16.c.mul(i40.add(n25.mul(e16.m))).add(o46) : e16.c.mul(n25).add(o46), a36.assign(n25), o46.assign(t10);
            });
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function(t9) {
            return t9.variable;
        }));
    }, o45.prototype.setMomentum = function(t9) {
        this.momentum = t9;
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(t9) {
                switch(t9.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t9.sent()
                            ].concat(this.accumulations.map(function(t10) {
                                return {
                                    name: t10.originalName,
                                    tensor: t10.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        return t9 = e16.sent(), this.accumulations = t9.map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.momentum, e16.useNesterov);
    }, o45.className = "Momentum", o45;
}(Rd);
cd(Id);
var kd = function(t1) {
    function o45(e16, n24, r33, o46, a36) {
        (void 0) === n24 && (n24 = 0.9), (void 0) === r33 && (r33 = 0), (void 0) === o46 && (o46 = null), (void 0) === a36 && (a36 = !1);
        var i40 = t1.call(this) || this;
        if (i40.learningRate = e16, i40.decay = n24, i40.momentum = r33, i40.epsilon = o46, i40.accumulatedMeanSquares = [], i40.accumulatedMoments = [], i40.accumulatedMeanGrads = [], i40.centered = a36, null == o46 && (i40.epsilon = Lt.backend.epsilon()), null == e16) throw new Error("learningRate for RMSPropOptimizer must be defined.");
        return i40;
    }
    return e(o45, t1), o45.prototype.applyGradients = function(t9) {
        var e16 = this;
        (Array.isArray(t9) ? t9.map(function(t10) {
            return t10.name;
        }) : Object.keys(t9)).forEach(function(n24, r33) {
            var o46 = Lt.registeredVariables[n24];
            null == e16.accumulatedMeanSquares[r33] && (e16.accumulatedMeanSquares[r33] = {
                originalName: n24 + "/rms",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            }), null == e16.accumulatedMoments[r33] && (e16.accumulatedMoments[r33] = {
                originalName: n24 + "/momentum",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            }), null == e16.accumulatedMeanGrads[r33] && e16.centered && (e16.accumulatedMeanGrads[r33] = {
                originalName: n24 + "/mg",
                variable: Ze(function() {
                    return Xn(o46).variable(!1);
                })
            });
            var a36 = Array.isArray(t9) ? t9[r33].tensor : t9[n24];
            if (null != a36) {
                var i40 = e16.accumulatedMeanSquares[r33].variable, s36 = e16.accumulatedMoments[r33].variable;
                Ze(function() {
                    var t10 = i40.mul(e16.decay).add(a36.square().mul(1 - e16.decay));
                    if (e16.centered) {
                        var n25 = e16.accumulatedMeanGrads[r33].variable, u34 = n25.mul(e16.decay).add(a36.mul(1 - e16.decay)), c26 = s36.mul(e16.momentum).add(a36.mul(e16.learningRate).div(t10.sub(u34.square().add(e16.epsilon)).sqrt()));
                        i40.assign(t10), n25.assign(u34), s36.assign(c26);
                        var l32 = o46.sub(c26);
                        o46.assign(l32);
                    } else {
                        var h22 = i40.mul(e16.decay).add(a36.square().mul(1 - e16.decay));
                        c26 = s36.mul(e16.momentum).add(a36.mul(e16.learningRate).div(h22.add(e16.epsilon).sqrt()));
                        i40.assign(h22), s36.assign(c26);
                        l32 = o46.sub(c26);
                        o46.assign(l32);
                    }
                });
            }
        }), this.incrementIterations();
    }, o45.prototype.dispose = function() {
        null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function(t9) {
            return t9.variable;
        })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function(t9) {
            return t9.variable;
        })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function(t9) {
            return t9.variable;
        }));
    }, o45.prototype.getWeights = function() {
        return n10(this, void 0, void 0, function() {
            var t9;
            return r17(this, function(e16) {
                switch(e16.label){
                    case 0:
                        return t9 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t9.push.apply(t9, this.accumulatedMeanGrads), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e16.sent()
                            ].concat(t9.map(function(t10) {
                                return {
                                    name: t10.originalName,
                                    tensor: t10.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o45.prototype.setWeights = function(t9) {
        return n10(this, void 0, void 0, function() {
            var e16;
            return r17(this, function(n24) {
                switch(n24.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t9)
                        ];
                    case 1:
                        return t9 = n24.sent(), e16 = this.centered ? t9.length / 3 : t9.length / 2, this.accumulatedMeanSquares = t9.slice(0, e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), this.accumulatedMoments = t9.slice(e16, 2 * e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        }), this.centered && (this.accumulatedMeanGrads = t9.slice(2 * e16, 3 * e16).map(function(t10) {
                            return {
                                originalName: t10.name,
                                variable: t10.tensor.variable(!1)
                            };
                        })), [
                            2
                        ];
                }
            });
        });
    }, o45.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    }, o45.fromConfig = function(t9, e16) {
        return new t9(e16.learningRate, e16.decay, e16.momentum, e16.epsilon, e16.centered);
    }, o45.className = "RMSProp", o45;
}(xd);
cd(kd);
var Sd = function() {
    function t1() {
    }
    return t1.sgd = function(t9) {
        return new Rd(t9);
    }, t1.momentum = function(t9, e16, n24) {
        return (void 0) === n24 && (n24 = !1), new Id(t9, e16, n24);
    }, t1.rmsprop = function(t9, e16, n24, r33, o45) {
        return (void 0) === e16 && (e16 = 0.9), (void 0) === n24 && (n24 = 0), (void 0) === r33 && (r33 = null), (void 0) === o45 && (o45 = !1), new kd(t9, e16, n24, r33, o45);
    }, t1.adam = function(t9, e16, n24, r33) {
        return (void 0) === t9 && (t9 = 0.001), (void 0) === e16 && (e16 = 0.9), (void 0) === n24 && (n24 = 0.999), (void 0) === r33 && (r33 = null), new Cd(t9, e16, n24, r33);
    }, t1.adadelta = function(t9, e16, n24) {
        return (void 0) === t9 && (t9 = 0.001), (void 0) === e16 && (e16 = 0.95), (void 0) === n24 && (n24 = null), new bd(t9, e16, n24);
    }, t1.adamax = function(t9, e16, n24, r33, o45) {
        return (void 0) === t9 && (t9 = 0.002), (void 0) === e16 && (e16 = 0.9), (void 0) === n24 && (n24 = 0.999), (void 0) === r33 && (r33 = null), (void 0) === o45 && (o45 = 0), new Ed(t9, e16, n24, r33, o45);
    }, t1.adagrad = function(t9, e16) {
        return (void 0) === e16 && (e16 = 0.1), new wd(t9, e16);
    }, t1;
}(), Ad = {
    sgd: Sd.sgd,
    momentum: Sd.momentum,
    adadelta: Sd.adadelta,
    adagrad: Sd.adagrad,
    rmsprop: Sd.rmsprop,
    adamax: Sd.adamax,
    adam: Sd.adam
}, Dd = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t1) {
    return t1();
};
function Td() {
    return new Promise(function(t1) {
        return Dd(function() {
            return t1();
        });
    });
}
wt.prototype.squaredDifference = function(t1) {
    return nu(this, t1);
}, xt = Gh;

},{"process":"6Upk8","buffer":"bpNHw","crypto":"8VSUO","node-fetch":"8VSUO","util":"8VSUO","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6Upk8":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while((++queueIndex) < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"bpNHw":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare1(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset + --byteLength1];
    var mul = 1;
    while(byteLength1 > 0 && (mul *= 256))val += this[offset + --byteLength1] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var i = byteLength1;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"2vMBM","ieee754":"lz1we"}],"2vMBM":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len1; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i1 = start; i1 < end; i1 += 3){
        tmp = (uint8[i1] << 16 & 16711680) + (uint8[i1 + 1] << 8 & 65280) + (uint8[i1 + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len1 = uint8.length;
    var extraBytes = len1 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i1 = 0, len2 = len1 - extraBytes; i1 < len2; i1 += maxChunkLength)parts.push(encodeChunk(uint8, i1, i1 + maxChunkLength > len2 ? len2 : i1 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len1 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len1 - 2] << 8) + uint8[len1 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"lz1we":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"8VSUO":[function(require,module,exports) {
"use strict";

},{}],"4NrvZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _drawContour = require("./drawContour");
parcelHelpers.exportAll(_drawContour, exports);
var _drawDetections = require("./drawDetections");
parcelHelpers.exportAll(_drawDetections, exports);
var _drawFaceExpressions = require("./drawFaceExpressions");
parcelHelpers.exportAll(_drawFaceExpressions, exports);
var _drawBox = require("./DrawBox");
parcelHelpers.exportAll(_drawBox, exports);
var _drawFaceLandmarks = require("./DrawFaceLandmarks");
parcelHelpers.exportAll(_drawFaceLandmarks, exports);
var _drawTextField = require("./DrawTextField");
parcelHelpers.exportAll(_drawTextField, exports);

},{"./drawContour":"6cgKF","./drawDetections":"jd0m3","./drawFaceExpressions":"cM8Rx","./DrawBox":"8f9fY","./DrawFaceLandmarks":"jUad3","./DrawTextField":"3QqV1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6cgKF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawContour", ()=>drawContour
);
function drawContour(ctx, points, isClosed) {
    if (isClosed === void 0) isClosed = false;
    ctx.beginPath();
    points.slice(1).forEach(function(_a, prevIdx) {
        var x = _a.x, y = _a.y;
        var from = points[prevIdx];
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(x, y);
    });
    if (isClosed) {
        var from = points[points.length - 1];
        var to = points[0];
        if (!from || !to) return;
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
    }
    ctx.stroke();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jd0m3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawDetections", ()=>drawDetections
);
var _classes = require("../classes");
var _faceDetection = require("../classes/FaceDetection");
var _withFaceDetection = require("../factories/WithFaceDetection");
var _utils = require("../utils");
var _drawBox = require("./DrawBox");
function drawDetections(canvasArg, detections) {
    var detectionsArray = Array.isArray(detections) ? detections : [
        detections
    ];
    detectionsArray.forEach(function(det) {
        var score = det instanceof _faceDetection.FaceDetection ? det.score : _withFaceDetection.isWithFaceDetection(det) ? det.detection.score : undefined;
        var box = det instanceof _faceDetection.FaceDetection ? det.box : _withFaceDetection.isWithFaceDetection(det) ? det.detection.box : new _classes.Box(det);
        var label = score ? "" + _utils.round(score) : undefined;
        new _drawBox.DrawBox(box, {
            label: label
        }).draw(canvasArg);
    });
}

},{"../classes":"6Yf93","../classes/FaceDetection":"f78Si","../factories/WithFaceDetection":"bFfpU","../utils":"1iSuU","./DrawBox":"8f9fY","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6Yf93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundingBox = require("./BoundingBox");
parcelHelpers.exportAll(_boundingBox, exports);
var _box = require("./Box");
parcelHelpers.exportAll(_box, exports);
var _dimensions = require("./Dimensions");
parcelHelpers.exportAll(_dimensions, exports);
var _faceDetection = require("./FaceDetection");
parcelHelpers.exportAll(_faceDetection, exports);
var _faceLandmarks = require("./FaceLandmarks");
parcelHelpers.exportAll(_faceLandmarks, exports);
var _faceLandmarks5 = require("./FaceLandmarks5");
parcelHelpers.exportAll(_faceLandmarks5, exports);
var _faceLandmarks68 = require("./FaceLandmarks68");
parcelHelpers.exportAll(_faceLandmarks68, exports);
var _faceMatch = require("./FaceMatch");
parcelHelpers.exportAll(_faceMatch, exports);
var _labeledBox = require("./LabeledBox");
parcelHelpers.exportAll(_labeledBox, exports);
var _labeledFaceDescriptors = require("./LabeledFaceDescriptors");
parcelHelpers.exportAll(_labeledFaceDescriptors, exports);
var _objectDetection = require("./ObjectDetection");
parcelHelpers.exportAll(_objectDetection, exports);
var _point = require("./Point");
parcelHelpers.exportAll(_point, exports);
var _predictedBox = require("./PredictedBox");
parcelHelpers.exportAll(_predictedBox, exports);
var _rect = require("./Rect");
parcelHelpers.exportAll(_rect, exports);

},{"./BoundingBox":"kCX5I","./Box":"bPVfe","./Dimensions":"6YMdR","./FaceDetection":"f78Si","./FaceLandmarks":"bin8I","./FaceLandmarks5":"f4KYU","./FaceLandmarks68":"3c9t5","./FaceMatch":"49agE","./LabeledBox":"30WN9","./LabeledFaceDescriptors":"9qjE9","./ObjectDetection":"fGpww","./Point":"gbysQ","./PredictedBox":"1bN2I","./Rect":"lIBhU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kCX5I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoundingBox", ()=>BoundingBox1
);
var _tslib = require("tslib");
var _box = require("./Box");
var BoundingBox1 = function(_super) {
    _tslib.__extends(BoundingBox2, _super);
    function BoundingBox2(left, top, right, bottom, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) allowNegativeDimensions = false;
        return _super.call(this, {
            left: left,
            top: top,
            right: right,
            bottom: bottom
        }, allowNegativeDimensions) || this;
    }
    return BoundingBox2;
}(_box.Box);

},{"tslib":"bjkXk","./Box":"bPVfe","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bjkXk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends
);
parcelHelpers.export(exports, "__assign", ()=>__assign
);
parcelHelpers.export(exports, "__rest", ()=>__rest
);
parcelHelpers.export(exports, "__decorate", ()=>__decorate
);
parcelHelpers.export(exports, "__param", ()=>__param
);
parcelHelpers.export(exports, "__metadata", ()=>__metadata
);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter
);
parcelHelpers.export(exports, "__generator", ()=>__generator
);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding
);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar
);
parcelHelpers.export(exports, "__values", ()=>__values
);
parcelHelpers.export(exports, "__read", ()=>__read
);
parcelHelpers.export(exports, "__spread", ()=>__spread
);
parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays
);
parcelHelpers.export(exports, "__await", ()=>__await
);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator
);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator
);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues
);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject
);
parcelHelpers.export(exports, "__importStar", ()=>__importStar
);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault
);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet
);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d1, b1) {
        d1.__proto__ = b1;
    } || function(d1, b1) {
        for(var p in b1)if (b1.hasOwnProperty(p)) d1[p] = b1[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign1(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {
    };
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
}
function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}
function __exportStar(m, exports) {
    for(var p in m)if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || (n--) > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
    return i = {
    }, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
}
function __asyncDelegator(o) {
    var i, p;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === "return"
            } : f ? f(v) : v;
        } : f;
    }
    return i = {
    }, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v1) {
            resolve({
                value: v1,
                done: d
            });
        }, reject);
    }
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {
    }, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {
    };
    if (mod != null) for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
    return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to set private field on non-instance");
    privateMap.set(receiver, value);
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bPVfe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Box", ()=>Box
);
var _utils = require("../utils");
var _point = require("./Point");
var Box = function() {
    function Box1(_box, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) allowNegativeDimensions = true;
        var box = _box || {
        };
        var isBbox = [
            box.left,
            box.top,
            box.right,
            box.bottom
        ].every(_utils.isValidNumber);
        var isRect = [
            box.x,
            box.y,
            box.width,
            box.height
        ].every(_utils.isValidNumber);
        if (!isRect && !isBbox) throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(box));
        var _a = isRect ? [
            box.x,
            box.y,
            box.width,
            box.height
        ] : [
            box.left,
            box.top,
            box.right - box.left,
            box.bottom - box.top
        ], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        Box1.assertIsValidBox({
            x: x,
            y: y,
            width: width,
            height: height
        }, 'Box.constructor', allowNegativeDimensions);
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    Box1.isRect = function(rect) {
        return !!rect && [
            rect.x,
            rect.y,
            rect.width,
            rect.height
        ].every(_utils.isValidNumber);
    };
    Box1.assertIsValidBox = function(box, callee, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) allowNegativeDimensions = false;
        if (!Box1.isRect(box)) throw new Error(callee + " - invalid box: " + JSON.stringify(box) + ", expected object with properties x, y, width, height");
        if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) throw new Error(callee + " - width (" + box.width + ") and height (" + box.height + ") must be positive numbers");
    };
    Object.defineProperty(Box1.prototype, "x", {
        get: function() {
            return this._x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "y", {
        get: function() {
            return this._y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "width", {
        get: function() {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "height", {
        get: function() {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "left", {
        get: function() {
            return this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "top", {
        get: function() {
            return this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "area", {
        get: function() {
            return this.width * this.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "topLeft", {
        get: function() {
            return new _point.Point(this.left, this.top);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "topRight", {
        get: function() {
            return new _point.Point(this.right, this.top);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "bottomLeft", {
        get: function() {
            return new _point.Point(this.left, this.bottom);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box1.prototype, "bottomRight", {
        get: function() {
            return new _point.Point(this.right, this.bottom);
        },
        enumerable: true,
        configurable: true
    });
    Box1.prototype.round = function() {
        var _a = [
            this.x,
            this.y,
            this.width,
            this.height
        ].map(function(val) {
            return Math.round(val);
        }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box1({
            x: x,
            y: y,
            width: width,
            height: height
        });
    };
    Box1.prototype.floor = function() {
        var _a = [
            this.x,
            this.y,
            this.width,
            this.height
        ].map(function(val) {
            return Math.floor(val);
        }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box1({
            x: x,
            y: y,
            width: width,
            height: height
        });
    };
    Box1.prototype.toSquare = function() {
        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var diff = Math.abs(width - height);
        if (width < height) {
            x -= diff / 2;
            width += diff;
        }
        if (height < width) {
            y -= diff / 2;
            height += diff;
        }
        return new Box1({
            x: x,
            y: y,
            width: width,
            height: height
        });
    };
    Box1.prototype.rescale = function(s) {
        var scaleX = _utils.isDimensions(s) ? s.width : s;
        var scaleY = _utils.isDimensions(s) ? s.height : s;
        return new Box1({
            x: this.x * scaleX,
            y: this.y * scaleY,
            width: this.width * scaleX,
            height: this.height * scaleY
        });
    };
    Box1.prototype.pad = function(padX, padY) {
        var _a = [
            this.x - padX / 2,
            this.y - padY / 2,
            this.width + padX,
            this.height + padY
        ], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box1({
            x: x,
            y: y,
            width: width,
            height: height
        });
    };
    Box1.prototype.clipAtImageBorders = function(imgWidth, imgHeight) {
        var _a = this, x = _a.x, y = _a.y, right = _a.right, bottom = _a.bottom;
        var clippedX = Math.max(x, 0);
        var clippedY = Math.max(y, 0);
        var newWidth = right - clippedX;
        var newHeight = bottom - clippedY;
        var clippedWidth = Math.min(newWidth, imgWidth - clippedX);
        var clippedHeight = Math.min(newHeight, imgHeight - clippedY);
        return new Box1({
            x: clippedX,
            y: clippedY,
            width: clippedWidth,
            height: clippedHeight
        }).floor();
    };
    Box1.prototype.shift = function(sx, sy) {
        var _a = this, width = _a.width, height = _a.height;
        var x = this.x + sx;
        var y = this.y + sy;
        return new Box1({
            x: x,
            y: y,
            width: width,
            height: height
        });
    };
    Box1.prototype.padAtBorders = function(imageHeight, imageWidth) {
        var w = this.width + 1;
        var h = this.height + 1;
        var dx = 1;
        var dy = 1;
        var edx = w;
        var edy = h;
        var x = this.left;
        var y = this.top;
        var ex = this.right;
        var ey = this.bottom;
        if (ex > imageWidth) {
            edx = -ex + imageWidth + w;
            ex = imageWidth;
        }
        if (ey > imageHeight) {
            edy = -ey + imageHeight + h;
            ey = imageHeight;
        }
        if (x < 1) {
            edy = 2 - x;
            x = 1;
        }
        if (y < 1) {
            edy = 2 - y;
            y = 1;
        }
        return {
            dy: dy,
            edy: edy,
            dx: dx,
            edx: edx,
            y: y,
            ey: ey,
            x: x,
            ex: ex,
            w: w,
            h: h
        };
    };
    Box1.prototype.calibrate = function(region) {
        return new Box1({
            left: this.left + region.left * this.width,
            top: this.top + region.top * this.height,
            right: this.right + region.right * this.width,
            bottom: this.bottom + region.bottom * this.height
        }).toSquare().round();
    };
    return Box1;
}();

},{"../utils":"1iSuU","./Point":"gbysQ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1iSuU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTensor", ()=>isTensor
);
parcelHelpers.export(exports, "isTensor1D", ()=>isTensor1D
);
parcelHelpers.export(exports, "isTensor2D", ()=>isTensor2D
);
parcelHelpers.export(exports, "isTensor3D", ()=>isTensor3D
);
parcelHelpers.export(exports, "isTensor4D", ()=>isTensor4D
);
parcelHelpers.export(exports, "isFloat", ()=>isFloat
);
parcelHelpers.export(exports, "isEven", ()=>isEven
);
parcelHelpers.export(exports, "round", ()=>round
);
parcelHelpers.export(exports, "isDimensions", ()=>isDimensions
);
parcelHelpers.export(exports, "computeReshapedDimensions", ()=>computeReshapedDimensions
);
parcelHelpers.export(exports, "getCenterPoint", ()=>getCenterPoint
);
parcelHelpers.export(exports, "range", ()=>range
);
parcelHelpers.export(exports, "isValidNumber", ()=>isValidNumber
);
parcelHelpers.export(exports, "isValidProbablitiy", ()=>isValidProbablitiy
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _dimensions = require("../classes/Dimensions");
function isTensor(tensor, dim) {
    return tensor instanceof _tfjsCore.Tensor && tensor.shape.length === dim;
}
function isTensor1D(tensor) {
    return isTensor(tensor, 1);
}
function isTensor2D(tensor) {
    return isTensor(tensor, 2);
}
function isTensor3D(tensor) {
    return isTensor(tensor, 3);
}
function isTensor4D(tensor) {
    return isTensor(tensor, 4);
}
function isFloat(num) {
    return num % 1 !== 0;
}
function isEven(num) {
    return num % 2 === 0;
}
function round(num, prec) {
    if (prec === void 0) prec = 2;
    var f = Math.pow(10, prec);
    return Math.floor(num * f) / f;
}
function isDimensions(obj) {
    return obj && obj.width && obj.height;
}
function computeReshapedDimensions(_a, inputSize) {
    var width = _a.width, height = _a.height;
    var scale = inputSize / Math.max(height, width);
    return new _dimensions.Dimensions(Math.round(width * scale), Math.round(height * scale));
}
function getCenterPoint(pts) {
    return pts.reduce(function(sum, pt) {
        return sum.add(pt);
    }, new _classes.Point(0, 0)).div(new _classes.Point(pts.length, pts.length));
}
function range(num, start, step) {
    return Array(num).fill(0).map(function(_, i) {
        return start + i * step;
    });
}
function isValidNumber(num) {
    return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;
}
function isValidProbablitiy(num) {
    return isValidNumber(num) && 0 <= num && num <= 1;
}

},{"@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../classes/Dimensions":"6YMdR","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6YMdR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Dimensions", ()=>Dimensions
);
var _utils = require("../utils");
var Dimensions = function() {
    function Dimensions1(width, height) {
        if (!_utils.isValidNumber(width) || !_utils.isValidNumber(height)) throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({
            width: width,
            height: height
        }));
        this._width = width;
        this._height = height;
    }
    Object.defineProperty(Dimensions1.prototype, "width", {
        get: function() {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dimensions1.prototype, "height", {
        get: function() {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Dimensions1.prototype.reverse = function() {
        return new Dimensions1(1 / this.width, 1 / this.height);
    };
    return Dimensions1;
}();

},{"../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gbysQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Point", ()=>Point
);
var Point = function() {
    function Point1(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(Point1.prototype, "x", {
        get: function() {
            return this._x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Point1.prototype, "y", {
        get: function() {
            return this._y;
        },
        enumerable: true,
        configurable: true
    });
    Point1.prototype.add = function(pt) {
        return new Point1(this.x + pt.x, this.y + pt.y);
    };
    Point1.prototype.sub = function(pt) {
        return new Point1(this.x - pt.x, this.y - pt.y);
    };
    Point1.prototype.mul = function(pt) {
        return new Point1(this.x * pt.x, this.y * pt.y);
    };
    Point1.prototype.div = function(pt) {
        return new Point1(this.x / pt.x, this.y / pt.y);
    };
    Point1.prototype.abs = function() {
        return new Point1(Math.abs(this.x), Math.abs(this.y));
    };
    Point1.prototype.magnitude = function() {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    };
    Point1.prototype.floor = function() {
        return new Point1(Math.floor(this.x), Math.floor(this.y));
    };
    return Point1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"f78Si":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceDetection", ()=>FaceDetection1
);
var _tslib = require("tslib");
var _objectDetection = require("./ObjectDetection");
var FaceDetection1 = function(_super) {
    _tslib.__extends(FaceDetection2, _super);
    function FaceDetection2(score, relativeBox, imageDims) {
        return _super.call(this, score, score, '', relativeBox, imageDims) || this;
    }
    FaceDetection2.prototype.forSize = function(width, height) {
        var _a = _super.prototype.forSize.call(this, width, height), score = _a.score, relativeBox = _a.relativeBox, imageDims = _a.imageDims;
        return new FaceDetection2(score, relativeBox, imageDims);
    };
    return FaceDetection2;
}(_objectDetection.ObjectDetection);

},{"tslib":"bjkXk","./ObjectDetection":"fGpww","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fGpww":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObjectDetection", ()=>ObjectDetection
);
var _box = require("./Box");
var _dimensions = require("./Dimensions");
var ObjectDetection = function() {
    function ObjectDetection1(score, classScore, className, relativeBox, imageDims) {
        this._imageDims = new _dimensions.Dimensions(imageDims.width, imageDims.height);
        this._score = score;
        this._classScore = classScore;
        this._className = className;
        this._box = new _box.Box(relativeBox).rescale(this._imageDims);
    }
    Object.defineProperty(ObjectDetection1.prototype, "score", {
        get: function() {
            return this._score;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "classScore", {
        get: function() {
            return this._classScore;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "className", {
        get: function() {
            return this._className;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "box", {
        get: function() {
            return this._box;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "imageDims", {
        get: function() {
            return this._imageDims;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "imageWidth", {
        get: function() {
            return this.imageDims.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "imageHeight", {
        get: function() {
            return this.imageDims.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection1.prototype, "relativeBox", {
        get: function() {
            return new _box.Box(this._box).rescale(this.imageDims.reverse());
        },
        enumerable: true,
        configurable: true
    });
    ObjectDetection1.prototype.forSize = function(width, height) {
        return new ObjectDetection1(this.score, this.classScore, this.className, this.relativeBox, {
            width: width,
            height: height
        });
    };
    return ObjectDetection1;
}();

},{"./Box":"bPVfe","./Dimensions":"6YMdR","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bin8I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmarks", ()=>FaceLandmarks
);
var _ops = require("../ops");
var _utils = require("../utils");
var _box = require("./Box");
var _dimensions = require("./Dimensions");
var _faceDetection = require("./FaceDetection");
var _point = require("./Point");
var _rect = require("./Rect");
// face alignment constants
var relX = 0.5;
var relY = 0.43;
var relScale = 0.45;
var FaceLandmarks = function() {
    function FaceLandmarks1(relativeFaceLandmarkPositions, imgDims, shift) {
        if (shift === void 0) shift = new _point.Point(0, 0);
        var width = imgDims.width, height = imgDims.height;
        this._imgDims = new _dimensions.Dimensions(width, height);
        this._shift = shift;
        this._positions = relativeFaceLandmarkPositions.map(function(pt) {
            return pt.mul(new _point.Point(width, height)).add(shift);
        });
    }
    Object.defineProperty(FaceLandmarks1.prototype, "shift", {
        get: function() {
            return new _point.Point(this._shift.x, this._shift.y);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks1.prototype, "imageWidth", {
        get: function() {
            return this._imgDims.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks1.prototype, "imageHeight", {
        get: function() {
            return this._imgDims.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks1.prototype, "positions", {
        get: function() {
            return this._positions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks1.prototype, "relativePositions", {
        get: function() {
            var _this = this;
            return this._positions.map(function(pt) {
                return pt.sub(_this._shift).div(new _point.Point(_this.imageWidth, _this.imageHeight));
            });
        },
        enumerable: true,
        configurable: true
    });
    FaceLandmarks1.prototype.forSize = function(width, height) {
        return new this.constructor(this.relativePositions, {
            width: width,
            height: height
        });
    };
    FaceLandmarks1.prototype.shiftBy = function(x, y) {
        return new this.constructor(this.relativePositions, this._imgDims, new _point.Point(x, y));
    };
    FaceLandmarks1.prototype.shiftByPoint = function(pt) {
        return this.shiftBy(pt.x, pt.y);
    };
    /**
     * Aligns the face landmarks after face detection from the relative positions of the faces
     * bounding box, or it's current shift. This function should be used to align the face images
     * after face detection has been performed, before they are passed to the face recognition net.
     * This will make the computed face descriptor more accurate.
     *
     * @param detection (optional) The bounding box of the face or the face detection result. If
     * no argument was passed the position of the face landmarks are assumed to be relative to
     * it's current shift.
     * @returns The bounding box of the aligned face.
     */ FaceLandmarks1.prototype.align = function(detection, options) {
        if (options === void 0) options = {
        };
        if (detection) {
            var box = detection instanceof _faceDetection.FaceDetection ? detection.box.floor() : new _box.Box(detection);
            return this.shiftBy(box.x, box.y).align(null, options);
        }
        var _a = Object.assign({
        }, {
            useDlibAlignment: false,
            minBoxPadding: 0.2
        }, options), useDlibAlignment = _a.useDlibAlignment, minBoxPadding = _a.minBoxPadding;
        if (useDlibAlignment) return this.alignDlib();
        return this.alignMinBbox(minBoxPadding);
    };
    FaceLandmarks1.prototype.alignDlib = function() {
        var centers = this.getRefPointsForAlignment();
        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];
        var distToMouth = function(pt) {
            return mouthCenter.sub(pt).magnitude();
        };
        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;
        var size = Math.floor(eyeToMouthDist / relScale);
        var refPoint = _utils.getCenterPoint(centers);
        // TODO: pad in case rectangle is out of image bounds
        var x = Math.floor(Math.max(0, refPoint.x - relX * size));
        var y = Math.floor(Math.max(0, refPoint.y - relY * size));
        return new _rect.Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));
    };
    FaceLandmarks1.prototype.alignMinBbox = function(padding) {
        var box = _ops.minBbox(this.positions);
        return box.pad(box.width * padding, box.height * padding);
    };
    FaceLandmarks1.prototype.getRefPointsForAlignment = function() {
        throw new Error('getRefPointsForAlignment not implemented by base class');
    };
    return FaceLandmarks1;
}();

},{"../ops":"cSYle","../utils":"1iSuU","./Box":"bPVfe","./Dimensions":"6YMdR","./FaceDetection":"f78Si","./Point":"gbysQ","./Rect":"lIBhU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cSYle":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sigmoid", ()=>sigmoid
);
parcelHelpers.export(exports, "inverseSigmoid", ()=>inverseSigmoid
);
var _iou = require("./iou");
parcelHelpers.exportAll(_iou, exports);
var _minBbox = require("./minBbox");
parcelHelpers.exportAll(_minBbox, exports);
var _nonMaxSuppression = require("./nonMaxSuppression");
parcelHelpers.exportAll(_nonMaxSuppression, exports);
var _normalize = require("./normalize");
parcelHelpers.exportAll(_normalize, exports);
var _padToSquare = require("./padToSquare");
parcelHelpers.exportAll(_padToSquare, exports);
var _shuffleArray = require("./shuffleArray");
parcelHelpers.exportAll(_shuffleArray, exports);
function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
}
function inverseSigmoid(x) {
    return Math.log(x / (1 - x));
}

},{"./iou":"2DYrH","./minBbox":"fqmRz","./nonMaxSuppression":"eCKOv","./normalize":"jTWUd","./padToSquare":"Vbks5","./shuffleArray":"lLqmG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2DYrH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "iou", ()=>iou
);
function iou(box1, box2, isIOU) {
    if (isIOU === void 0) isIOU = true;
    var width = Math.max(0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));
    var height = Math.max(0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));
    var interSection = width * height;
    return isIOU ? interSection / (box1.area + box2.area - interSection) : interSection / Math.min(box1.area, box2.area);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fqmRz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minBbox", ()=>minBbox
);
var _classes = require("../classes");
function minBbox(pts) {
    var xs = pts.map(function(pt) {
        return pt.x;
    });
    var ys = pts.map(function(pt) {
        return pt.y;
    });
    var minX = xs.reduce(function(min, x) {
        return x < min ? x : min;
    }, Infinity);
    var minY = ys.reduce(function(min, y) {
        return y < min ? y : min;
    }, Infinity);
    var maxX = xs.reduce(function(max, x) {
        return max < x ? x : max;
    }, 0);
    var maxY = ys.reduce(function(max, y) {
        return max < y ? y : max;
    }, 0);
    return new _classes.BoundingBox(minX, minY, maxX, maxY);
}

},{"../classes":"6Yf93","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eCKOv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nonMaxSuppression", ()=>nonMaxSuppression
);
var _iou = require("./iou");
function nonMaxSuppression(boxes, scores, iouThreshold, isIOU) {
    if (isIOU === void 0) isIOU = true;
    var indicesSortedByScore = scores.map(function(score, boxIndex) {
        return {
            score: score,
            boxIndex: boxIndex
        };
    }).sort(function(c1, c2) {
        return c1.score - c2.score;
    }).map(function(c) {
        return c.boxIndex;
    });
    var pick = [];
    var _loop_1 = function() {
        var curr = indicesSortedByScore.pop();
        pick.push(curr);
        var indices = indicesSortedByScore;
        var outputs = [];
        for(var i = 0; i < indices.length; i++){
            var idx = indices[i];
            var currBox = boxes[curr];
            var idxBox = boxes[idx];
            outputs.push(_iou.iou(currBox, idxBox, isIOU));
        }
        indicesSortedByScore = indicesSortedByScore.filter(function(_, j) {
            return outputs[j] <= iouThreshold;
        });
    };
    while(indicesSortedByScore.length > 0)_loop_1();
    return pick;
}

},{"./iou":"2DYrH","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jTWUd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
function normalize(x, meanRgb) {
    return _tfjsCore.tidy(function() {
        var r = meanRgb[0], g = meanRgb[1], b = meanRgb[2];
        var avg_r = _tfjsCore.fill(_tslib.__spreadArrays(x.shape.slice(0, 3), [
            1
        ]), r);
        var avg_g = _tfjsCore.fill(_tslib.__spreadArrays(x.shape.slice(0, 3), [
            1
        ]), g);
        var avg_b = _tfjsCore.fill(_tslib.__spreadArrays(x.shape.slice(0, 3), [
            1
        ]), b);
        var avg_rgb = _tfjsCore.concat([
            avg_r,
            avg_g,
            avg_b
        ], 3);
        return _tfjsCore.sub(x, avg_rgb);
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"Vbks5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Pads the smaller dimension of an image tensor with zeros, such that width === height.
 *
 * @param imgTensor The image tensor.
 * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
 * both sides of the minor dimension oof the image.
 * @returns The padded tensor with width === height.
 */ parcelHelpers.export(exports, "padToSquare", ()=>padToSquare
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function padToSquare(imgTensor, isCenterImage) {
    if (isCenterImage === void 0) isCenterImage = false;
    return _tfjsCore.tidy(function() {
        var _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
        if (height === width) return imgTensor;
        var dimDiff = Math.abs(height - width);
        var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));
        var paddingAxis = height > width ? 2 : 1;
        var createPaddingTensor = function(paddingAmount1) {
            var paddingTensorShape = imgTensor.shape.slice();
            paddingTensorShape[paddingAxis] = paddingAmount1;
            return _tfjsCore.fill(paddingTensorShape, 0);
        };
        var paddingTensorAppend = createPaddingTensor(paddingAmount);
        var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];
        var paddingTensorPrepend = isCenterImage && remainingPaddingAmount ? createPaddingTensor(remainingPaddingAmount) : null;
        var tensorsToStack = [
            paddingTensorPrepend,
            imgTensor,
            paddingTensorAppend
        ].filter(function(t) {
            return !!t;
        }).map(function(t) {
            return t.toFloat();
        });
        return _tfjsCore.concat(tensorsToStack, paddingAxis);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lLqmG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shuffleArray", ()=>shuffleArray
);
function shuffleArray(inputArray) {
    var array = inputArray.slice();
    for(var i = array.length - 1; i > 0; i--){
        var j = Math.floor(Math.random() * (i + 1));
        var x = array[i];
        array[i] = array[j];
        array[j] = x;
    }
    return array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lIBhU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Rect", ()=>Rect1
);
var _tslib = require("tslib");
var _box = require("./Box");
var Rect1 = function(_super) {
    _tslib.__extends(Rect2, _super);
    function Rect2(x, y, width, height, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) allowNegativeDimensions = false;
        return _super.call(this, {
            x: x,
            y: y,
            width: width,
            height: height
        }, allowNegativeDimensions) || this;
    }
    return Rect2;
}(_box.Box);

},{"tslib":"bjkXk","./Box":"bPVfe","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"f4KYU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmarks5", ()=>FaceLandmarks51
);
var _tslib = require("tslib");
var _utils = require("../utils");
var _faceLandmarks = require("./FaceLandmarks");
var FaceLandmarks51 = function(_super) {
    _tslib.__extends(FaceLandmarks52, _super);
    function FaceLandmarks52() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks52.prototype.getRefPointsForAlignment = function() {
        var pts = this.positions;
        return [
            pts[0],
            pts[1],
            _utils.getCenterPoint([
                pts[3],
                pts[4]
            ])
        ];
    };
    return FaceLandmarks52;
}(_faceLandmarks.FaceLandmarks);

},{"tslib":"bjkXk","../utils":"1iSuU","./FaceLandmarks":"bin8I","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3c9t5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmarks68", ()=>FaceLandmarks681
);
var _tslib = require("tslib");
var _utils = require("../utils");
var _faceLandmarks = require("./FaceLandmarks");
var FaceLandmarks681 = function(_super) {
    _tslib.__extends(FaceLandmarks682, _super);
    function FaceLandmarks682() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks682.prototype.getJawOutline = function() {
        return this.positions.slice(0, 17);
    };
    FaceLandmarks682.prototype.getLeftEyeBrow = function() {
        return this.positions.slice(17, 22);
    };
    FaceLandmarks682.prototype.getRightEyeBrow = function() {
        return this.positions.slice(22, 27);
    };
    FaceLandmarks682.prototype.getNose = function() {
        return this.positions.slice(27, 36);
    };
    FaceLandmarks682.prototype.getLeftEye = function() {
        return this.positions.slice(36, 42);
    };
    FaceLandmarks682.prototype.getRightEye = function() {
        return this.positions.slice(42, 48);
    };
    FaceLandmarks682.prototype.getMouth = function() {
        return this.positions.slice(48, 68);
    };
    FaceLandmarks682.prototype.getRefPointsForAlignment = function() {
        return [
            this.getLeftEye(),
            this.getRightEye(),
            this.getMouth()
        ].map(_utils.getCenterPoint);
    };
    return FaceLandmarks682;
}(_faceLandmarks.FaceLandmarks);

},{"tslib":"bjkXk","../utils":"1iSuU","./FaceLandmarks":"bin8I","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"49agE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceMatch", ()=>FaceMatch
);
var _utils = require("../utils");
var FaceMatch = function() {
    function FaceMatch1(label, distance) {
        this._label = label;
        this._distance = distance;
    }
    Object.defineProperty(FaceMatch1.prototype, "label", {
        get: function() {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatch1.prototype, "distance", {
        get: function() {
            return this._distance;
        },
        enumerable: true,
        configurable: true
    });
    FaceMatch1.prototype.toString = function(withDistance) {
        if (withDistance === void 0) withDistance = true;
        return "" + this.label + (withDistance ? " (" + _utils.round(this.distance) + ")" : '');
    };
    return FaceMatch1;
}();

},{"../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"30WN9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LabeledBox", ()=>LabeledBox1
);
var _tslib = require("tslib");
var _utils = require("../utils");
var _box = require("./Box");
var LabeledBox1 = function(_super) {
    _tslib.__extends(LabeledBox2, _super);
    function LabeledBox2(box, label) {
        var _this = _super.call(this, box) || this;
        _this._label = label;
        return _this;
    }
    LabeledBox2.assertIsValidLabeledBox = function(box, callee) {
        _box.Box.assertIsValidBox(box, callee);
        if (!_utils.isValidNumber(box.label)) throw new Error(callee + " - expected property label (" + box.label + ") to be a number");
    };
    Object.defineProperty(LabeledBox2.prototype, "label", {
        get: function() {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    return LabeledBox2;
}(_box.Box);

},{"tslib":"bjkXk","../utils":"1iSuU","./Box":"bPVfe","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9qjE9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LabeledFaceDescriptors", ()=>LabeledFaceDescriptors
);
var LabeledFaceDescriptors = function() {
    function LabeledFaceDescriptors1(label, descriptors) {
        if (!(typeof label === 'string')) throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');
        if (!Array.isArray(descriptors) || descriptors.some(function(desc) {
            return !(desc instanceof Float32Array);
        })) throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');
        this._label = label;
        this._descriptors = descriptors;
    }
    Object.defineProperty(LabeledFaceDescriptors1.prototype, "label", {
        get: function() {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabeledFaceDescriptors1.prototype, "descriptors", {
        get: function() {
            return this._descriptors;
        },
        enumerable: true,
        configurable: true
    });
    LabeledFaceDescriptors1.prototype.toJSON = function() {
        return {
            label: this.label,
            descriptors: this.descriptors.map(function(d) {
                return Array.from(d);
            })
        };
    };
    LabeledFaceDescriptors1.fromJSON = function(json) {
        var descriptors = json.descriptors.map(function(d) {
            return new Float32Array(d);
        });
        return new LabeledFaceDescriptors1(json.label, descriptors);
    };
    return LabeledFaceDescriptors1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1bN2I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PredictedBox", ()=>PredictedBox1
);
var _tslib = require("tslib");
var _utils = require("../utils");
var _labeledBox = require("./LabeledBox");
var PredictedBox1 = function(_super) {
    _tslib.__extends(PredictedBox2, _super);
    function PredictedBox2(box, label, score, classScore) {
        var _this = _super.call(this, box, label) || this;
        _this._score = score;
        _this._classScore = classScore;
        return _this;
    }
    PredictedBox2.assertIsValidPredictedBox = function(box, callee) {
        _labeledBox.LabeledBox.assertIsValidLabeledBox(box, callee);
        if (!_utils.isValidProbablitiy(box.score) || !_utils.isValidProbablitiy(box.classScore)) throw new Error(callee + " - expected properties score (" + box.score + ") and (" + box.classScore + ") to be a number between [0, 1]");
    };
    Object.defineProperty(PredictedBox2.prototype, "score", {
        get: function() {
            return this._score;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PredictedBox2.prototype, "classScore", {
        get: function() {
            return this._classScore;
        },
        enumerable: true,
        configurable: true
    });
    return PredictedBox2;
}(_labeledBox.LabeledBox);

},{"tslib":"bjkXk","../utils":"1iSuU","./LabeledBox":"30WN9","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bFfpU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWithFaceDetection", ()=>isWithFaceDetection
);
parcelHelpers.export(exports, "extendWithFaceDetection", ()=>extendWithFaceDetection
);
var _faceDetection = require("../classes/FaceDetection");
function isWithFaceDetection(obj) {
    return obj['detection'] instanceof _faceDetection.FaceDetection;
}
function extendWithFaceDetection(sourceObj, detection) {
    var extension = {
        detection: detection
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"../classes/FaceDetection":"f78Si","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8f9fY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DrawBoxOptions", ()=>DrawBoxOptions
);
parcelHelpers.export(exports, "DrawBox", ()=>DrawBox
);
var _classes = require("../classes");
var _getContext2DOrThrow = require("../dom/getContext2dOrThrow");
var _drawTextField = require("./DrawTextField");
var DrawBoxOptions = function() {
    function DrawBoxOptions1(options) {
        if (options === void 0) options = {
        };
        var boxColor = options.boxColor, lineWidth = options.lineWidth, label = options.label, drawLabelOptions = options.drawLabelOptions;
        this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';
        this.lineWidth = lineWidth || 2;
        this.label = label;
        var defaultDrawLabelOptions = {
            anchorPosition: _drawTextField.AnchorPosition.BOTTOM_LEFT,
            backgroundColor: this.boxColor
        };
        this.drawLabelOptions = new _drawTextField.DrawTextFieldOptions(Object.assign({
        }, defaultDrawLabelOptions, drawLabelOptions));
    }
    return DrawBoxOptions1;
}();
var DrawBox = function() {
    function DrawBox1(box, options) {
        if (options === void 0) options = {
        };
        this.box = new _classes.Box(box);
        this.options = new DrawBoxOptions(options);
    }
    DrawBox1.prototype.draw = function(canvasArg) {
        var ctx = _getContext2DOrThrow.getContext2dOrThrow(canvasArg);
        var _a = this.options, boxColor = _a.boxColor, lineWidth = _a.lineWidth;
        var _b = this.box, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
        ctx.strokeStyle = boxColor;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x, y, width, height);
        var label = this.options.label;
        if (label) new _drawTextField.DrawTextField([
            label
        ], {
            x: x - lineWidth / 2,
            y: y
        }, this.options.drawLabelOptions).draw(canvasArg);
    };
    return DrawBox1;
}();

},{"../classes":"6Yf93","../dom/getContext2dOrThrow":"trz3D","./DrawTextField":"3QqV1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"trz3D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContext2dOrThrow", ()=>getContext2dOrThrow
);
var _env = require("../env");
var _resolveInput = require("./resolveInput");
function getContext2dOrThrow(canvasArg) {
    var _a = _env.env.getEnv(), Canvas = _a.Canvas, CanvasRenderingContext2D1 = _a.CanvasRenderingContext2D;
    if (canvasArg instanceof CanvasRenderingContext2D1) return canvasArg;
    var canvas = _resolveInput.resolveInput(canvasArg);
    if (!(canvas instanceof Canvas)) throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');
    var ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('resolveContext2d - canvas 2d context is null');
    return ctx;
}

},{"../env":"aqpPn","./resolveInput":"lt21i","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aqpPn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "env", ()=>env
);
var _createBrowserEnv = require("./createBrowserEnv");
var _createFileSystem = require("./createFileSystem");
var _createNodejsEnv = require("./createNodejsEnv");
var _isBrowser = require("./isBrowser");
var _isNodejs = require("./isNodejs");
var environment;
function getEnv() {
    if (!environment) throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');
    return environment;
}
function setEnv(env) {
    environment = env;
}
function initialize() {
    // check for isBrowser() first to prevent electron renderer process
    // to be initialized with wrong environment due to isNodejs() returning true
    if (_isBrowser.isBrowser()) setEnv(_createBrowserEnv.createBrowserEnv());
    if (_isNodejs.isNodejs()) setEnv(_createNodejsEnv.createNodejsEnv());
}
function monkeyPatch(env) {
    if (!environment) initialize();
    if (!environment) throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');
    var _a = env.Canvas, Canvas = _a === void 0 ? environment.Canvas : _a, _b = env.Image, Image1 = _b === void 0 ? environment.Image : _b;
    environment.Canvas = Canvas;
    environment.Image = Image1;
    environment.createCanvasElement = env.createCanvasElement || function() {
        return new Canvas();
    };
    environment.createImageElement = env.createImageElement || function() {
        return new Image1();
    };
    environment.ImageData = env.ImageData || environment.ImageData;
    environment.Video = env.Video || environment.Video;
    environment.fetch = env.fetch || environment.fetch;
    environment.readFile = env.readFile || environment.readFile;
}
var env = {
    getEnv: getEnv,
    setEnv: setEnv,
    initialize: initialize,
    createBrowserEnv: _createBrowserEnv.createBrowserEnv,
    createFileSystem: _createFileSystem.createFileSystem,
    createNodejsEnv: _createNodejsEnv.createNodejsEnv,
    monkeyPatch: monkeyPatch,
    isBrowser: _isBrowser.isBrowser,
    isNodejs: _isNodejs.isNodejs
};
initialize();

},{"./createBrowserEnv":"90Srt","./createFileSystem":"ekyPn","./createNodejsEnv":"af8ZN","./isBrowser":"eFXY1","./isNodejs":"1NRB1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"90Srt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createBrowserEnv", ()=>createBrowserEnv
);
function createBrowserEnv() {
    var fetch = window['fetch'] || function() {
        throw new Error('fetch - missing fetch implementation for browser environment');
    };
    var readFile = function() {
        throw new Error('readFile - filesystem not available for browser environment');
    };
    return {
        Canvas: HTMLCanvasElement,
        CanvasRenderingContext2D: CanvasRenderingContext2D,
        Image: HTMLImageElement,
        ImageData: ImageData,
        Video: HTMLVideoElement,
        createCanvasElement: function() {
            return document.createElement('canvas');
        },
        createImageElement: function() {
            return document.createElement('img');
        },
        fetch: fetch,
        readFile: readFile
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ekyPn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFileSystem", ()=>createFileSystem
);
function createFileSystem(fs) {
    var requireFsError = '';
    if (!fs) try {
        fs = require('fs');
    } catch (err) {
        requireFsError = err.toString();
    }
    var readFile = fs ? function(filePath) {
        return new Promise(function(res, rej) {
            fs.readFile(filePath, function(err, buffer) {
                return err ? rej(err) : res(buffer);
            });
        });
    } : function() {
        throw new Error("readFile - failed to require fs in nodejs environment with error: " + requireFsError);
    };
    return {
        readFile: readFile
    };
}

},{"fs":"8VSUO","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"af8ZN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createNodejsEnv", ()=>createNodejsEnv
);
var _tslib = require("tslib");
var _createFileSystem = require("./createFileSystem");
var global = arguments[3];
function createNodejsEnv() {
    var Canvas = global['Canvas'] || global['HTMLCanvasElement'];
    var Image1 = global['Image'] || global['HTMLImageElement'];
    var createCanvasElement = function() {
        if (Canvas) return new Canvas();
        throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');
    };
    var createImageElement = function() {
        if (Image1) return new Image1();
        throw new Error('createImageElement - missing Image implementation for nodejs environment');
    };
    var fetch = global['fetch'] || function() {
        throw new Error('fetch - missing fetch implementation for nodejs environment');
    };
    var fileSystem = _createFileSystem.createFileSystem();
    return _tslib.__assign({
        Canvas: Canvas || function() {
            function Canvas1() {
            }
            return Canvas1;
        }(),
        CanvasRenderingContext2D: global['CanvasRenderingContext2D'] || function() {
            function class_1() {
            }
            return class_1;
        }(),
        Image: Image1 || function() {
            function Image2() {
            }
            return Image2;
        }(),
        ImageData: global['ImageData'] || function() {
            function class_2() {
            }
            return class_2;
        }(),
        Video: global['HTMLVideoElement'] || function() {
            function class_3() {
            }
            return class_3;
        }(),
        createCanvasElement: createCanvasElement,
        createImageElement: createImageElement,
        fetch: fetch
    }, fileSystem);
}

},{"tslib":"bjkXk","./createFileSystem":"ekyPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eFXY1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser
);
function isBrowser() {
    return typeof window === 'object' && typeof document !== 'undefined' && typeof HTMLImageElement !== 'undefined' && typeof HTMLCanvasElement !== 'undefined' && typeof HTMLVideoElement !== 'undefined' && typeof ImageData !== 'undefined' && typeof CanvasRenderingContext2D !== 'undefined';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1NRB1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNodejs", ()=>isNodejs
);
var global = arguments[3];
var process = require("process");
function isNodejs() {
    return typeof global === 'object' && typeof require === 'function' && typeof module !== 'undefined' && typeof process !== 'undefined' && !!process.version;
}

},{"process":"6Upk8","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lt21i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveInput", ()=>resolveInput
);
var _env = require("../env");
function resolveInput(arg) {
    if (!_env.env.isNodejs() && typeof arg === 'string') return document.getElementById(arg);
    return arg;
}

},{"../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3QqV1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnchorPosition", ()=>AnchorPosition
);
parcelHelpers.export(exports, "DrawTextFieldOptions", ()=>DrawTextFieldOptions
);
parcelHelpers.export(exports, "DrawTextField", ()=>DrawTextField
);
var _getContext2DOrThrow = require("../dom/getContext2dOrThrow");
var _resolveInput = require("../dom/resolveInput");
var AnchorPosition;
(function(AnchorPosition1) {
    AnchorPosition1["TOP_LEFT"] = "TOP_LEFT";
    AnchorPosition1["TOP_RIGHT"] = "TOP_RIGHT";
    AnchorPosition1["BOTTOM_LEFT"] = "BOTTOM_LEFT";
    AnchorPosition1["BOTTOM_RIGHT"] = "BOTTOM_RIGHT";
})(AnchorPosition || (AnchorPosition = {
}));
var DrawTextFieldOptions = function() {
    function DrawTextFieldOptions1(options) {
        if (options === void 0) options = {
        };
        var anchorPosition = options.anchorPosition, backgroundColor = options.backgroundColor, fontColor = options.fontColor, fontSize = options.fontSize, fontStyle = options.fontStyle, padding = options.padding;
        this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;
        this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';
        this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';
        this.fontSize = fontSize || 14;
        this.fontStyle = fontStyle || 'Georgia';
        this.padding = padding || 4;
    }
    return DrawTextFieldOptions1;
}();
var DrawTextField = function() {
    function DrawTextField1(text, anchor, options) {
        if (options === void 0) options = {
        };
        this.text = typeof text === 'string' ? [
            text
        ] : text instanceof DrawTextField1 ? text.text : text;
        this.anchor = anchor;
        this.options = new DrawTextFieldOptions(options);
    }
    DrawTextField1.prototype.measureWidth = function(ctx) {
        var padding = this.options.padding;
        return this.text.map(function(l) {
            return ctx.measureText(l).width;
        }).reduce(function(w0, w1) {
            return w0 < w1 ? w1 : w0;
        }, 0) + 2 * padding;
    };
    DrawTextField1.prototype.measureHeight = function() {
        var _a = this.options, fontSize = _a.fontSize, padding = _a.padding;
        return this.text.length * fontSize + 2 * padding;
    };
    DrawTextField1.prototype.getUpperLeft = function(ctx, canvasDims) {
        var anchorPosition = this.options.anchorPosition;
        var isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;
        var isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;
        var textFieldWidth = this.measureWidth(ctx);
        var textFieldHeight = this.measureHeight();
        var x = isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x;
        var y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;
        // adjust anchor if text box exceeds canvas borders
        if (canvasDims) {
            var width = canvasDims.width, height = canvasDims.height;
            var newX = Math.max(Math.min(x, width - textFieldWidth), 0);
            var newY = Math.max(Math.min(y, height - textFieldHeight), 0);
            return {
                x: newX,
                y: newY
            };
        }
        return {
            x: x,
            y: y
        };
    };
    DrawTextField1.prototype.draw = function(canvasArg) {
        var canvas = _resolveInput.resolveInput(canvasArg);
        var ctx = _getContext2DOrThrow.getContext2dOrThrow(canvas);
        var _a = this.options, backgroundColor = _a.backgroundColor, fontColor = _a.fontColor, fontSize = _a.fontSize, fontStyle = _a.fontStyle, padding = _a.padding;
        ctx.font = fontSize + "px " + fontStyle;
        var maxTextWidth = this.measureWidth(ctx);
        var textHeight = this.measureHeight();
        ctx.fillStyle = backgroundColor;
        var upperLeft = this.getUpperLeft(ctx, canvas);
        ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);
        ctx.fillStyle = fontColor;
        this.text.forEach(function(textLine, i) {
            var x = padding + upperLeft.x;
            var y = padding + upperLeft.y + (i + 1) * fontSize;
            ctx.fillText(textLine, x, y);
        });
    };
    return DrawTextField1;
}();

},{"../dom/getContext2dOrThrow":"trz3D","../dom/resolveInput":"lt21i","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cM8Rx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawFaceExpressions", ()=>drawFaceExpressions
);
var _classes = require("../classes");
var _faceExpressionNet = require("../faceExpressionNet");
var _withFaceDetection = require("../factories/WithFaceDetection");
var _withFaceExpressions = require("../factories/WithFaceExpressions");
var _utils = require("../utils");
var _drawTextField = require("./DrawTextField");
function drawFaceExpressions(canvasArg, faceExpressions, minConfidence, textFieldAnchor) {
    if (minConfidence === void 0) minConfidence = 0.1;
    var faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [
        faceExpressions
    ];
    faceExpressionsArray.forEach(function(e) {
        var expr = e instanceof _faceExpressionNet.FaceExpressions ? e : _withFaceExpressions.isWithFaceExpressions(e) ? e.expressions : undefined;
        if (!expr) throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');
        var sorted = expr.asSortedArray();
        var resultsToDisplay = sorted.filter(function(expr1) {
            return expr1.probability > minConfidence;
        });
        var anchor = _withFaceDetection.isWithFaceDetection(e) ? e.detection.box.bottomLeft : textFieldAnchor || new _classes.Point(0, 0);
        var drawTextField = new _drawTextField.DrawTextField(resultsToDisplay.map(function(expr1) {
            return expr1.expression + " (" + _utils.round(expr1.probability) + ")";
        }), anchor);
        drawTextField.draw(canvasArg);
    });
}

},{"../classes":"6Yf93","../faceExpressionNet":"32FcX","../factories/WithFaceDetection":"bFfpU","../factories/WithFaceExpressions":"eO705","../utils":"1iSuU","./DrawTextField":"3QqV1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"32FcX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _faceExpressionNet = require("./FaceExpressionNet");
parcelHelpers.exportAll(_faceExpressionNet, exports);
var _faceExpressions = require("./FaceExpressions");
parcelHelpers.exportAll(_faceExpressions, exports);

},{"./FaceExpressionNet":"10BVg","./FaceExpressions":"loD35","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"10BVg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceExpressionNet", ()=>FaceExpressionNet1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _faceFeatureExtractor = require("../faceFeatureExtractor/FaceFeatureExtractor");
var _faceProcessor = require("../faceProcessor/FaceProcessor");
var _faceExpressions = require("./FaceExpressions");
var FaceExpressionNet1 = function(_super) {
    _tslib.__extends(FaceExpressionNet2, _super);
    function FaceExpressionNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) faceFeatureExtractor = new _faceFeatureExtractor.FaceFeatureExtractor();
        return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;
    }
    FaceExpressionNet2.prototype.forwardInput = function(input) {
        var _this = this;
        return _tfjsCore.tidy(function() {
            return _tfjsCore.softmax(_this.runNet(input));
        });
    };
    FaceExpressionNet2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    FaceExpressionNet2.prototype.predictExpressions = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var netInput, out, probabilitesByBatch, predictionsByBatch;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.forwardInput(netInput)
                        ];
                    case 2:
                        out = _a.sent();
                        return [
                            4 /*yield*/ ,
                            Promise.all(_tfjsCore.unstack(out).map(function(t) {
                                return _tslib.__awaiter(_this, void 0, void 0, function() {
                                    var data;
                                    return _tslib.__generator(this, function(_a1) {
                                        switch(_a1.label){
                                            case 0:
                                                return [
                                                    4 /*yield*/ ,
                                                    t.data()
                                                ];
                                            case 1:
                                                data = _a1.sent();
                                                t.dispose();
                                                return [
                                                    2 /*return*/ ,
                                                    data
                                                ];
                                        }
                                    });
                                });
                            }))
                        ];
                    case 3:
                        probabilitesByBatch = _a.sent();
                        out.dispose();
                        predictionsByBatch = probabilitesByBatch.map(function(probabilites) {
                            return new _faceExpressions.FaceExpressions(probabilites);
                        });
                        return [
                            2 /*return*/ ,
                            netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]
                        ];
                }
            });
        });
    };
    FaceExpressionNet2.prototype.getDefaultModelName = function() {
        return 'face_expression_model';
    };
    FaceExpressionNet2.prototype.getClassifierChannelsIn = function() {
        return 256;
    };
    FaceExpressionNet2.prototype.getClassifierChannelsOut = function() {
        return 7;
    };
    return FaceExpressionNet2;
}(_faceProcessor.FaceProcessor);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../faceFeatureExtractor/FaceFeatureExtractor":"3l1PF","../faceProcessor/FaceProcessor":"9R6YA","./FaceExpressions":"loD35","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eQw1p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _awaitMediaLoaded = require("./awaitMediaLoaded");
parcelHelpers.exportAll(_awaitMediaLoaded, exports);
var _bufferToImage = require("./bufferToImage");
parcelHelpers.exportAll(_bufferToImage, exports);
var _createCanvas = require("./createCanvas");
parcelHelpers.exportAll(_createCanvas, exports);
var _extractFaces = require("./extractFaces");
parcelHelpers.exportAll(_extractFaces, exports);
var _extractFaceTensors = require("./extractFaceTensors");
parcelHelpers.exportAll(_extractFaceTensors, exports);
var _fetchImage = require("./fetchImage");
parcelHelpers.exportAll(_fetchImage, exports);
var _fetchJson = require("./fetchJson");
parcelHelpers.exportAll(_fetchJson, exports);
var _fetchNetWeights = require("./fetchNetWeights");
parcelHelpers.exportAll(_fetchNetWeights, exports);
var _fetchOrThrow = require("./fetchOrThrow");
parcelHelpers.exportAll(_fetchOrThrow, exports);
var _getContext2DOrThrow = require("./getContext2dOrThrow");
parcelHelpers.exportAll(_getContext2DOrThrow, exports);
var _getMediaDimensions = require("./getMediaDimensions");
parcelHelpers.exportAll(_getMediaDimensions, exports);
var _imageTensorToCanvas = require("./imageTensorToCanvas");
parcelHelpers.exportAll(_imageTensorToCanvas, exports);
var _imageToSquare = require("./imageToSquare");
parcelHelpers.exportAll(_imageToSquare, exports);
var _isMediaElement = require("./isMediaElement");
parcelHelpers.exportAll(_isMediaElement, exports);
var _isMediaLoaded = require("./isMediaLoaded");
parcelHelpers.exportAll(_isMediaLoaded, exports);
var _loadWeightMap = require("./loadWeightMap");
parcelHelpers.exportAll(_loadWeightMap, exports);
var _matchDimensions = require("./matchDimensions");
parcelHelpers.exportAll(_matchDimensions, exports);
var _netInput = require("./NetInput");
parcelHelpers.exportAll(_netInput, exports);
var _resolveInput = require("./resolveInput");
parcelHelpers.exportAll(_resolveInput, exports);
var _toNetInput = require("./toNetInput");
parcelHelpers.exportAll(_toNetInput, exports);

},{"./awaitMediaLoaded":"QWowN","./bufferToImage":"bj52I","./createCanvas":"dPb1y","./extractFaces":"g5Quz","./extractFaceTensors":"7xK20","./fetchImage":"1CIu8","./fetchJson":"aOTfN","./fetchNetWeights":"iM3Qx","./fetchOrThrow":"dC00D","./getContext2dOrThrow":"trz3D","./getMediaDimensions":"kaoif","./imageTensorToCanvas":"4HRWg","./imageToSquare":"BwakG","./isMediaElement":"kzU0a","./isMediaLoaded":"cQsAu","./loadWeightMap":"eQMcq","./matchDimensions":"bMXk3","./NetInput":"6OAN2","./resolveInput":"lt21i","./toNetInput":"fKWvr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"QWowN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "awaitMediaLoaded", ()=>awaitMediaLoaded
);
var _env = require("../env");
var _isMediaLoaded = require("./isMediaLoaded");
function awaitMediaLoaded(media) {
    return new Promise(function(resolve, reject) {
        if (media instanceof _env.env.getEnv().Canvas || _isMediaLoaded.isMediaLoaded(media)) return resolve();
        function onLoad(e) {
            if (!e.currentTarget) return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            resolve(e);
        }
        function onError(e) {
            if (!e.currentTarget) return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            reject(e);
        }
        media.addEventListener('load', onLoad);
        media.addEventListener('error', onError);
    });
}

},{"../env":"aqpPn","./isMediaLoaded":"cQsAu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cQsAu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isMediaLoaded", ()=>isMediaLoaded
);
var _env = require("../env");
function isMediaLoaded(media) {
    var _a = _env.env.getEnv(), Image1 = _a.Image, Video = _a.Video;
    return media instanceof Image1 && media.complete || media instanceof Video && media.readyState >= 3;
}

},{"../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bj52I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bufferToImage", ()=>bufferToImage
);
var _env = require("../env");
function bufferToImage(buf) {
    return new Promise(function(resolve, reject) {
        if (!(buf instanceof Blob)) return reject('bufferToImage - expected buf to be of type: Blob');
        var reader = new FileReader();
        reader.onload = function() {
            if (typeof reader.result !== 'string') return reject('bufferToImage - expected reader.result to be a string, in onload');
            var img = _env.env.getEnv().createImageElement();
            img.onload = function() {
                return resolve(img);
            };
            img.onerror = reject;
            img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(buf);
    });
}

},{"../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dPb1y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCanvas", ()=>createCanvas
);
parcelHelpers.export(exports, "createCanvasFromMedia", ()=>createCanvasFromMedia
);
var _env = require("../env");
var _getContext2DOrThrow = require("./getContext2dOrThrow");
var _getMediaDimensions = require("./getMediaDimensions");
var _isMediaLoaded = require("./isMediaLoaded");
function createCanvas(_a) {
    var width = _a.width, height = _a.height;
    var createCanvasElement = _env.env.getEnv().createCanvasElement;
    var canvas = createCanvasElement();
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function createCanvasFromMedia(media, dims) {
    var ImageData1 = _env.env.getEnv().ImageData;
    if (!(media instanceof ImageData1) && !_isMediaLoaded.isMediaLoaded(media)) throw new Error('createCanvasFromMedia - media has not finished loading yet');
    var _a = dims || _getMediaDimensions.getMediaDimensions(media), width = _a.width, height = _a.height;
    var canvas = createCanvas({
        width: width,
        height: height
    });
    if (media instanceof ImageData1) _getContext2DOrThrow.getContext2dOrThrow(canvas).putImageData(media, 0, 0);
    else _getContext2DOrThrow.getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height);
    return canvas;
}

},{"../env":"aqpPn","./getContext2dOrThrow":"trz3D","./getMediaDimensions":"kaoif","./isMediaLoaded":"cQsAu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kaoif":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getMediaDimensions", ()=>getMediaDimensions
);
var _dimensions = require("../classes/Dimensions");
var _env = require("../env");
function getMediaDimensions(input) {
    var _a = _env.env.getEnv(), Image1 = _a.Image, Video = _a.Video;
    if (input instanceof Image1) return new _dimensions.Dimensions(input.naturalWidth, input.naturalHeight);
    if (input instanceof Video) return new _dimensions.Dimensions(input.videoWidth, input.videoHeight);
    return new _dimensions.Dimensions(input.width, input.height);
}

},{"../classes/Dimensions":"6YMdR","../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"g5Quz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts the image regions containing the detected faces.
 *
 * @param input The image that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns The Canvases of the corresponding image region for each detected face.
 */ parcelHelpers.export(exports, "extractFaces", ()=>extractFaces
);
var _tslib = require("tslib");
var _faceDetection = require("../classes/FaceDetection");
var _env = require("../env");
var _createCanvas = require("./createCanvas");
var _getContext2DOrThrow = require("./getContext2dOrThrow");
var _imageTensorToCanvas = require("./imageTensorToCanvas");
var _toNetInput = require("./toNetInput");
function extractFaces(input, detections) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;
        return _tslib.__generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    Canvas = _env.env.getEnv().Canvas;
                    canvas = input;
                    if (!!(input instanceof Canvas)) return [
                        3 /*break*/ ,
                        5
                    ];
                    return [
                        4 /*yield*/ ,
                        _toNetInput.toNetInput(input)
                    ];
                case 1:
                    netInput = _b.sent();
                    if (netInput.batchSize > 1) throw new Error('extractFaces - batchSize > 1 not supported');
                    tensorOrCanvas = netInput.getInput(0);
                    if (!(tensorOrCanvas instanceof Canvas)) return [
                        3 /*break*/ ,
                        2
                    ];
                    _a = tensorOrCanvas;
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 2:
                    return [
                        4 /*yield*/ ,
                        _imageTensorToCanvas.imageTensorToCanvas(tensorOrCanvas)
                    ];
                case 3:
                    _a = _b.sent();
                    _b.label = 4;
                case 4:
                    canvas = _a;
                    _b.label = 5;
                case 5:
                    ctx = _getContext2DOrThrow.getContext2dOrThrow(canvas);
                    boxes = detections.map(function(det) {
                        return det instanceof _faceDetection.FaceDetection ? det.forSize(canvas.width, canvas.height).box.floor() : det;
                    }).map(function(box) {
                        return box.clipAtImageBorders(canvas.width, canvas.height);
                    });
                    return [
                        2 /*return*/ ,
                        boxes.map(function(_a1) {
                            var x = _a1.x, y = _a1.y, width = _a1.width, height = _a1.height;
                            var faceImg = _createCanvas.createCanvas({
                                width: width,
                                height: height
                            });
                            _getContext2DOrThrow.getContext2dOrThrow(faceImg).putImageData(ctx.getImageData(x, y, width, height), 0, 0);
                            return faceImg;
                        })
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","../classes/FaceDetection":"f78Si","../env":"aqpPn","./createCanvas":"dPb1y","./getContext2dOrThrow":"trz3D","./imageTensorToCanvas":"4HRWg","./toNetInput":"fKWvr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4HRWg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageTensorToCanvas", ()=>imageTensorToCanvas
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _env = require("../env");
var _utils = require("../utils");
function imageTensorToCanvas(imgTensor, canvas) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var targetCanvas, _a, height, width, numChannels, imgTensor3D;
        return _tslib.__generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    targetCanvas = canvas || _env.env.getEnv().createCanvasElement();
                    _a = imgTensor.shape.slice(_utils.isTensor4D(imgTensor) ? 1 : 0), height = _a[0], width = _a[1], numChannels = _a[2];
                    imgTensor3D = _tfjsCore.tidy(function() {
                        return imgTensor.as3D(height, width, numChannels).toInt();
                    });
                    return [
                        4 /*yield*/ ,
                        _tfjsCore.browser.toPixels(imgTensor3D, targetCanvas)
                    ];
                case 1:
                    _b.sent();
                    imgTensor3D.dispose();
                    return [
                        2 /*return*/ ,
                        targetCanvas
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../env":"aqpPn","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fKWvr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Validates the input to make sure, they are valid net inputs and awaits all media elements
 * to be finished loading.
 *
 * @param input The input, which can be a media element or an array of different media elements.
 * @returns A NetInput instance, which can be passed into one of the neural networks.
 */ parcelHelpers.export(exports, "toNetInput", ()=>toNetInput
);
var _tslib = require("tslib");
var _utils = require("../utils");
var _awaitMediaLoaded = require("./awaitMediaLoaded");
var _isMediaElement = require("./isMediaElement");
var _netInput = require("./NetInput");
var _resolveInput = require("./resolveInput");
function toNetInput(inputs) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var inputArgArray, getIdxHint, inputArray;
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    if (inputs instanceof _netInput.NetInput) return [
                        2 /*return*/ ,
                        inputs
                    ];
                    inputArgArray = Array.isArray(inputs) ? inputs : [
                        inputs
                    ];
                    if (!inputArgArray.length) throw new Error('toNetInput - empty array passed as input');
                    getIdxHint = function(idx) {
                        return Array.isArray(inputs) ? " at input index " + idx + ":" : '';
                    };
                    inputArray = inputArgArray.map(_resolveInput.resolveInput);
                    inputArray.forEach(function(input, i) {
                        if (!_isMediaElement.isMediaElement(input) && !_utils.isTensor3D(input) && !_utils.isTensor4D(input)) {
                            if (typeof inputArgArray[i] === 'string') throw new Error("toNetInput -" + getIdxHint(i) + " string passed, but could not resolve HTMLElement for element id " + inputArgArray[i]);
                            throw new Error("toNetInput -" + getIdxHint(i) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
                        }
                        if (_utils.isTensor4D(input)) {
                            // if tf.Tensor4D is passed in the input array, the batch size has to be 1
                            var batchSize = input.shape[0];
                            if (batchSize !== 1) throw new Error("toNetInput -" + getIdxHint(i) + " tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                        }
                    });
                    // wait for all media elements being loaded
                    return [
                        4 /*yield*/ ,
                        Promise.all(inputArray.map(function(input) {
                            return _isMediaElement.isMediaElement(input) && _awaitMediaLoaded.awaitMediaLoaded(input);
                        }))
                    ];
                case 1:
                    // wait for all media elements being loaded
                    _a.sent();
                    return [
                        2 /*return*/ ,
                        new _netInput.NetInput(inputArray, Array.isArray(inputs))
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","../utils":"1iSuU","./awaitMediaLoaded":"QWowN","./isMediaElement":"kzU0a","./NetInput":"6OAN2","./resolveInput":"lt21i","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kzU0a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isMediaElement", ()=>isMediaElement
);
var _env = require("../env");
function isMediaElement(input) {
    var _a = _env.env.getEnv(), Image1 = _a.Image, Canvas = _a.Canvas, Video = _a.Video;
    return input instanceof Image1 || input instanceof Canvas || input instanceof Video;
}

},{"../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6OAN2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NetInput", ()=>NetInput
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _env = require("../env");
var _padToSquare = require("../ops/padToSquare");
var _utils = require("../utils");
var _createCanvas = require("./createCanvas");
var _imageToSquare = require("./imageToSquare");
var NetInput = function() {
    function NetInput1(inputs, treatAsBatchInput) {
        var _this = this;
        if (treatAsBatchInput === void 0) treatAsBatchInput = false;
        this._imageTensors = [];
        this._canvases = [];
        this._treatAsBatchInput = false;
        this._inputDimensions = [];
        if (!Array.isArray(inputs)) throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + inputs);
        this._treatAsBatchInput = treatAsBatchInput;
        this._batchSize = inputs.length;
        inputs.forEach(function(input, idx) {
            if (_utils.isTensor3D(input)) {
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape;
                return;
            }
            if (_utils.isTensor4D(input)) {
                var batchSize = input.shape[0];
                if (batchSize !== 1) throw new Error("NetInput - tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape.slice(1);
                return;
            }
            var canvas = input instanceof _env.env.getEnv().Canvas ? input : _createCanvas.createCanvasFromMedia(input);
            _this._canvases[idx] = canvas;
            _this._inputDimensions[idx] = [
                canvas.height,
                canvas.width,
                3
            ];
        });
    }
    Object.defineProperty(NetInput1.prototype, "imageTensors", {
        get: function() {
            return this._imageTensors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "canvases", {
        get: function() {
            return this._canvases;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "isBatchInput", {
        get: function() {
            return this.batchSize > 1 || this._treatAsBatchInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "batchSize", {
        get: function() {
            return this._batchSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "inputDimensions", {
        get: function() {
            return this._inputDimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "inputSize", {
        get: function() {
            return this._inputSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput1.prototype, "reshapedInputDimensions", {
        get: function() {
            var _this = this;
            return _utils.range(this.batchSize, 0, 1).map(function(_, batchIdx) {
                return _this.getReshapedInputDimensions(batchIdx);
            });
        },
        enumerable: true,
        configurable: true
    });
    NetInput1.prototype.getInput = function(batchIdx) {
        return this.canvases[batchIdx] || this.imageTensors[batchIdx];
    };
    NetInput1.prototype.getInputDimensions = function(batchIdx) {
        return this._inputDimensions[batchIdx];
    };
    NetInput1.prototype.getInputHeight = function(batchIdx) {
        return this._inputDimensions[batchIdx][0];
    };
    NetInput1.prototype.getInputWidth = function(batchIdx) {
        return this._inputDimensions[batchIdx][1];
    };
    NetInput1.prototype.getReshapedInputDimensions = function(batchIdx) {
        if (typeof this.inputSize !== 'number') throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');
        var width = this.getInputWidth(batchIdx);
        var height = this.getInputHeight(batchIdx);
        return _utils.computeReshapedDimensions({
            width: width,
            height: height
        }, this.inputSize);
    };
    /**
     * Create a batch tensor from all input canvases and tensors
     * with size [batchSize, inputSize, inputSize, 3].
     *
     * @param inputSize Height and width of the tensor.
     * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
     * both sides of the minor dimension oof the image.
     * @returns The batch tensor.
     */ NetInput1.prototype.toBatchTensor = function(inputSize, isCenterInputs) {
        var _this = this;
        if (isCenterInputs === void 0) isCenterInputs = true;
        this._inputSize = inputSize;
        return _tfjsCore.tidy(function() {
            var inputTensors = _utils.range(_this.batchSize, 0, 1).map(function(batchIdx) {
                var input = _this.getInput(batchIdx);
                if (input instanceof _tfjsCore.Tensor) {
                    var imgTensor = _utils.isTensor4D(input) ? input : input.expandDims();
                    imgTensor = _padToSquare.padToSquare(imgTensor, isCenterInputs);
                    if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) imgTensor = _tfjsCore.image.resizeBilinear(imgTensor, [
                        inputSize,
                        inputSize
                    ]);
                    return imgTensor.as3D(inputSize, inputSize, 3);
                }
                if (input instanceof _env.env.getEnv().Canvas) return _tfjsCore.browser.fromPixels(_imageToSquare.imageToSquare(input, inputSize, isCenterInputs));
                throw new Error("toBatchTensor - at batchIdx " + batchIdx + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + input);
            });
            var batchTensor = _tfjsCore.stack(inputTensors.map(function(t) {
                return t.toFloat();
            })).as4D(_this.batchSize, inputSize, inputSize, 3);
            return batchTensor;
        });
    };
    return NetInput1;
}();

},{"@tensorflow/tfjs-core":"82lJf","../env":"aqpPn","../ops/padToSquare":"Vbks5","../utils":"1iSuU","./createCanvas":"dPb1y","./imageToSquare":"BwakG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"BwakG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imageToSquare", ()=>imageToSquare
);
var _env = require("../env");
var _createCanvas = require("./createCanvas");
var _getContext2DOrThrow = require("./getContext2dOrThrow");
var _getMediaDimensions = require("./getMediaDimensions");
function imageToSquare(input, inputSize, centerImage) {
    if (centerImage === void 0) centerImage = false;
    var _a = _env.env.getEnv(), Image1 = _a.Image, Canvas = _a.Canvas;
    if (!(input instanceof Image1 || input instanceof Canvas)) throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');
    var dims = _getMediaDimensions.getMediaDimensions(input);
    var scale = inputSize / Math.max(dims.height, dims.width);
    var width = scale * dims.width;
    var height = scale * dims.height;
    var targetCanvas = _createCanvas.createCanvas({
        width: inputSize,
        height: inputSize
    });
    var inputCanvas = input instanceof Canvas ? input : _createCanvas.createCanvasFromMedia(input);
    var offset = Math.abs(width - height) / 2;
    var dx = centerImage && width < height ? offset : 0;
    var dy = centerImage && height < width ? offset : 0;
    _getContext2DOrThrow.getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);
    return targetCanvas;
}

},{"../env":"aqpPn","./createCanvas":"dPb1y","./getContext2dOrThrow":"trz3D","./getMediaDimensions":"kaoif","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7xK20":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts the tensors of the image regions containing the detected faces.
 * Useful if you want to compute the face descriptors for the face images.
 * Using this method is faster then extracting a canvas for each face and
 * converting them to tensors individually.
 *
 * @param imageTensor The image tensor that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns Tensors of the corresponding image region for each detected face.
 */ parcelHelpers.export(exports, "extractFaceTensors", ()=>extractFaceTensors
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _faceDetection = require("../classes/FaceDetection");
var _utils = require("../utils");
function extractFaceTensors(imageTensor, detections) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        return _tslib.__generator(this, function(_a) {
            if (!_utils.isTensor3D(imageTensor) && !_utils.isTensor4D(imageTensor)) throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');
            if (_utils.isTensor4D(imageTensor) && imageTensor.shape[0] > 1) throw new Error('extractFaceTensors - batchSize > 1 not supported');
            return [
                2 /*return*/ ,
                _tfjsCore.tidy(function() {
                    var _a1 = imageTensor.shape.slice(_utils.isTensor4D(imageTensor) ? 1 : 0), imgHeight = _a1[0], imgWidth = _a1[1], numChannels = _a1[2];
                    var boxes = detections.map(function(det) {
                        return det instanceof _faceDetection.FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;
                    }).map(function(box) {
                        return box.clipAtImageBorders(imgWidth, imgHeight);
                    });
                    var faceTensors = boxes.map(function(_a2) {
                        var x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
                        return _tfjsCore.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [
                            y,
                            x,
                            0
                        ], [
                            height,
                            width,
                            numChannels
                        ]);
                    });
                    return faceTensors;
                })
            ];
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes/FaceDetection":"f78Si","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1CIu8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetchImage", ()=>fetchImage
);
var _tslib = require("tslib");
var _bufferToImage = require("./bufferToImage");
var _fetchOrThrow = require("./fetchOrThrow");
function fetchImage(uri) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var res, blob;
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        _fetchOrThrow.fetchOrThrow(uri)
                    ];
                case 1:
                    res = _a.sent();
                    return [
                        4 /*yield*/ ,
                        res.blob()
                    ];
                case 2:
                    blob = _a.sent();
                    if (!blob.type.startsWith('image/')) throw new Error("fetchImage - expected blob type to be of type image/*, instead have: " + blob.type + ", for url: " + res.url);
                    return [
                        2 /*return*/ ,
                        _bufferToImage.bufferToImage(blob)
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","./bufferToImage":"bj52I","./fetchOrThrow":"dC00D","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dC00D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetchOrThrow", ()=>fetchOrThrow
);
var _tslib = require("tslib");
var _env = require("../env");
function fetchOrThrow(url, init) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var fetch, res;
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    fetch = _env.env.getEnv().fetch;
                    return [
                        4 /*yield*/ ,
                        fetch(url, init)
                    ];
                case 1:
                    res = _a.sent();
                    if (!(res.status < 400)) throw new Error("failed to fetch: (" + res.status + ") " + res.statusText + ", from url: " + res.url);
                    return [
                        2 /*return*/ ,
                        res
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","../env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aOTfN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetchJson", ()=>fetchJson
);
var _tslib = require("tslib");
var _fetchOrThrow = require("./fetchOrThrow");
function fetchJson(uri) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        _fetchOrThrow.fetchOrThrow(uri)
                    ];
                case 1:
                    return [
                        2 /*return*/ ,
                        _a.sent().json()
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","./fetchOrThrow":"dC00D","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iM3Qx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetchNetWeights", ()=>fetchNetWeights
);
var _tslib = require("tslib");
var _fetchOrThrow = require("./fetchOrThrow");
function fetchNetWeights(uri) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var _a;
        return _tslib.__generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    _a = Float32Array.bind;
                    return [
                        4 /*yield*/ ,
                        _fetchOrThrow.fetchOrThrow(uri)
                    ];
                case 1:
                    return [
                        4 /*yield*/ ,
                        _b.sent().arrayBuffer()
                    ];
                case 2:
                    return [
                        2 /*return*/ ,
                        new (_a.apply(Float32Array, [
                            void 0,
                            _b.sent()
                        ]))()
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","./fetchOrThrow":"dC00D","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eQMcq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadWeightMap", ()=>loadWeightMap
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _getModelUris = require("../common/getModelUris");
var _fetchJson = require("./fetchJson");
function loadWeightMap(uri, defaultModelName) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var _a, manifestUri, modelBaseUri, manifest;
        return _tslib.__generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    _a = _getModelUris.getModelUris(uri, defaultModelName), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                    return [
                        4 /*yield*/ ,
                        _fetchJson.fetchJson(manifestUri)
                    ];
                case 1:
                    manifest = _b.sent();
                    return [
                        2 /*return*/ ,
                        _tfjsCore.io.loadWeights(manifest, modelBaseUri)
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../common/getModelUris":"gHelh","./fetchJson":"aOTfN","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gHelh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getModelUris", ()=>getModelUris
);
function getModelUris(uri, defaultModelName) {
    var defaultManifestFilename = defaultModelName + "-weights_manifest.json";
    if (!uri) return {
        modelBaseUri: '',
        manifestUri: defaultManifestFilename
    };
    if (uri === '/') return {
        modelBaseUri: '/',
        manifestUri: "/" + defaultManifestFilename
    };
    var protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';
    uri = uri.replace(protocol, '');
    var parts = uri.split('/').filter(function(s) {
        return s;
    });
    var manifestFile = uri.endsWith('.json') ? parts[parts.length - 1] : defaultManifestFilename;
    var modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');
    modelBaseUri = uri.startsWith('/') ? "/" + modelBaseUri : modelBaseUri;
    return {
        modelBaseUri: modelBaseUri,
        manifestUri: modelBaseUri === '/' ? "/" + manifestFile : modelBaseUri + "/" + manifestFile
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bMXk3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matchDimensions", ()=>matchDimensions
);
var _getMediaDimensions = require("./getMediaDimensions");
function matchDimensions(input, reference, useMediaDimensions) {
    if (useMediaDimensions === void 0) useMediaDimensions = false;
    var _a = useMediaDimensions ? _getMediaDimensions.getMediaDimensions(reference) : reference, width = _a.width, height = _a.height;
    input.width = width;
    input.height = height;
    return {
        width: width,
        height: height
    };
}

},{"./getMediaDimensions":"kaoif","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3l1PF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceFeatureExtractor", ()=>FaceFeatureExtractor1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _ops = require("../ops");
var _denseBlock = require("./denseBlock");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var FaceFeatureExtractor1 = function(_super) {
    _tslib.__extends(FaceFeatureExtractor2, _super);
    function FaceFeatureExtractor2() {
        return _super.call(this, 'FaceFeatureExtractor') || this;
    }
    FaceFeatureExtractor2.prototype.forwardInput = function(input) {
        var params = this.params;
        if (!params) throw new Error('FaceFeatureExtractor - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [
                122.782,
                117.001,
                104.298
            ];
            var normalized = _ops.normalize(batchTensor, meanRgb).div(_tfjsCore.scalar(255));
            var out = _denseBlock.denseBlock4(normalized, params.dense0, true);
            out = _denseBlock.denseBlock4(out, params.dense1);
            out = _denseBlock.denseBlock4(out, params.dense2);
            out = _denseBlock.denseBlock4(out, params.dense3);
            out = _tfjsCore.avgPool(out, [
                7,
                7
            ], [
                2,
                2
            ], 'valid');
            return out;
        });
    };
    FaceFeatureExtractor2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    FaceFeatureExtractor2.prototype.getDefaultModelName = function() {
        return 'face_feature_extractor_model';
    };
    FaceFeatureExtractor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap);
    };
    FaceFeatureExtractor2.prototype.extractParams = function(weights) {
        return _extractParams.extractParams(weights);
    };
    return FaceFeatureExtractor2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../NeuralNetwork":"lrDwN","../ops":"cSYle","./denseBlock":"15857","./extractParams":"lvrRU","./extractParamsFromWeigthMap":"bjOvZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lrDwN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NeuralNetwork", ()=>NeuralNetwork
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _getModelUris = require("./common/getModelUris");
var _dom = require("./dom");
var _env = require("./env");
var NeuralNetwork = function() {
    function NeuralNetwork1(_name) {
        this._name = _name;
        this._params = undefined;
        this._paramMappings = [];
    }
    Object.defineProperty(NeuralNetwork1.prototype, "params", {
        get: function() {
            return this._params;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork1.prototype, "paramMappings", {
        get: function() {
            return this._paramMappings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork1.prototype, "isLoaded", {
        get: function() {
            return !!this.params;
        },
        enumerable: true,
        configurable: true
    });
    NeuralNetwork1.prototype.getParamFromPath = function(paramPath) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        return obj[objProp];
    };
    NeuralNetwork1.prototype.reassignParamFromPath = function(paramPath, tensor) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        obj[objProp].dispose();
        obj[objProp] = tensor;
    };
    NeuralNetwork1.prototype.getParamList = function() {
        var _this = this;
        return this._paramMappings.map(function(_a) {
            var paramPath = _a.paramPath;
            return {
                path: paramPath,
                tensor: _this.getParamFromPath(paramPath)
            };
        });
    };
    NeuralNetwork1.prototype.getTrainableParams = function() {
        return this.getParamList().filter(function(param) {
            return param.tensor instanceof _tfjsCore.Variable;
        });
    };
    NeuralNetwork1.prototype.getFrozenParams = function() {
        return this.getParamList().filter(function(param) {
            return !(param.tensor instanceof _tfjsCore.Variable);
        });
    };
    NeuralNetwork1.prototype.variable = function() {
        var _this = this;
        this.getFrozenParams().forEach(function(_a) {
            var path = _a.path, tensor = _a.tensor;
            _this.reassignParamFromPath(path, tensor.variable());
        });
    };
    NeuralNetwork1.prototype.freeze = function() {
        var _this = this;
        this.getTrainableParams().forEach(function(_a) {
            var path = _a.path, variable = _a.tensor;
            var tensor = _tfjsCore.tensor(variable.dataSync());
            variable.dispose();
            _this.reassignParamFromPath(path, tensor);
        });
    };
    NeuralNetwork1.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) throwOnRedispose = true;
        this.getParamList().forEach(function(param) {
            if (throwOnRedispose && param.tensor.isDisposed) throw new Error("param tensor has already been disposed for path " + param.path);
            param.tensor.dispose();
        });
        this._params = undefined;
    };
    NeuralNetwork1.prototype.serializeParams = function() {
        return new Float32Array(this.getParamList().map(function(_a) {
            var tensor = _a.tensor;
            return Array.from(tensor.dataSync());
        }).reduce(function(flat, arr) {
            return flat.concat(arr);
        }));
    };
    NeuralNetwork1.prototype.load = function(weightsOrUrl) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (weightsOrUrl instanceof Float32Array) {
                            this.extractWeights(weightsOrUrl);
                            return [
                                2 /*return*/ 
                            ];
                        }
                        return [
                            4 /*yield*/ ,
                            this.loadFromUri(weightsOrUrl)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    NeuralNetwork1.prototype.loadFromUri = function(uri) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var weightMap;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (uri && typeof uri !== 'string') throw new Error(this._name + ".loadFromUri - expected model uri");
                        return [
                            4 /*yield*/ ,
                            _dom.loadWeightMap(uri, this.getDefaultModelName())
                        ];
                    case 1:
                        weightMap = _a.sent();
                        this.loadFromWeightMap(weightMap);
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    NeuralNetwork1.prototype.loadFromDisk = function(filePath) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var readFile, _a, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c, weightMap;
            return _tslib.__generator(this, function(_d) {
                switch(_d.label){
                    case 0:
                        if (filePath && typeof filePath !== 'string') throw new Error(this._name + ".loadFromDisk - expected model file path");
                        readFile = _env.env.getEnv().readFile;
                        _a = _getModelUris.getModelUris(filePath, this.getDefaultModelName()), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                        fetchWeightsFromDisk = function(filePaths) {
                            return Promise.all(filePaths.map(function(filePath1) {
                                return readFile(filePath1).then(function(buf) {
                                    return buf.buffer;
                                });
                            }));
                        };
                        loadWeights = _tfjsCore.io.weightsLoaderFactory(fetchWeightsFromDisk);
                        _c = (_b = JSON).parse;
                        return [
                            4 /*yield*/ ,
                            readFile(manifestUri)
                        ];
                    case 1:
                        manifest = _c.apply(_b, [
                            _d.sent().toString()
                        ]);
                        return [
                            4 /*yield*/ ,
                            loadWeights(manifest, modelBaseUri)
                        ];
                    case 2:
                        weightMap = _d.sent();
                        this.loadFromWeightMap(weightMap);
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    NeuralNetwork1.prototype.loadFromWeightMap = function(weightMap) {
        var _a = this.extractParamsFromWeigthMap(weightMap), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork1.prototype.extractWeights = function(weights) {
        var _a = this.extractParams(weights), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork1.prototype.traversePropertyPath = function(paramPath) {
        if (!this.params) throw new Error("traversePropertyPath - model has no loaded params");
        var result = paramPath.split('/').reduce(function(res, objProp) {
            if (!res.nextObj.hasOwnProperty(objProp)) throw new Error("traversePropertyPath - object does not have property " + objProp + ", for path " + paramPath);
            return {
                obj: res.nextObj,
                objProp: objProp,
                nextObj: res.nextObj[objProp]
            };
        }, {
            nextObj: this.params
        });
        var obj = result.obj, objProp = result.objProp;
        if (!obj || !objProp || !(obj[objProp] instanceof _tfjsCore.Tensor)) throw new Error("traversePropertyPath - parameter is not a tensor, for path " + paramPath);
        return {
            obj: obj,
            objProp: objProp
        };
    };
    return NeuralNetwork1;
}();

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","./common/getModelUris":"gHelh","./dom":"eQw1p","./env":"aqpPn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"15857":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "denseBlock3", ()=>denseBlock3
);
parcelHelpers.export(exports, "denseBlock4", ()=>denseBlock4
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _depthwiseSeparableConv = require("../common/depthwiseSeparableConv");
function denseBlock3(x, denseBlockParams, isFirstLayer) {
    if (isFirstLayer === void 0) isFirstLayer = false;
    return _tfjsCore.tidy(function() {
        var out1 = _tfjsCore.relu(isFirstLayer ? _tfjsCore.add(_tfjsCore.conv2d(x, denseBlockParams.conv0.filters, [
            2,
            2
        ], 'same'), denseBlockParams.conv0.bias) : _depthwiseSeparableConv.depthwiseSeparableConv(x, denseBlockParams.conv0, [
            2,
            2
        ]));
        var out2 = _depthwiseSeparableConv.depthwiseSeparableConv(out1, denseBlockParams.conv1, [
            1,
            1
        ]);
        var in3 = _tfjsCore.relu(_tfjsCore.add(out1, out2));
        var out3 = _depthwiseSeparableConv.depthwiseSeparableConv(in3, denseBlockParams.conv2, [
            1,
            1
        ]);
        return _tfjsCore.relu(_tfjsCore.add(out1, _tfjsCore.add(out2, out3)));
    });
}
function denseBlock4(x, denseBlockParams, isFirstLayer, isScaleDown) {
    if (isFirstLayer === void 0) isFirstLayer = false;
    if (isScaleDown === void 0) isScaleDown = true;
    return _tfjsCore.tidy(function() {
        var out1 = _tfjsCore.relu(isFirstLayer ? _tfjsCore.add(_tfjsCore.conv2d(x, denseBlockParams.conv0.filters, isScaleDown ? [
            2,
            2
        ] : [
            1,
            1
        ], 'same'), denseBlockParams.conv0.bias) : _depthwiseSeparableConv.depthwiseSeparableConv(x, denseBlockParams.conv0, isScaleDown ? [
            2,
            2
        ] : [
            1,
            1
        ]));
        var out2 = _depthwiseSeparableConv.depthwiseSeparableConv(out1, denseBlockParams.conv1, [
            1,
            1
        ]);
        var in3 = _tfjsCore.relu(_tfjsCore.add(out1, out2));
        var out3 = _depthwiseSeparableConv.depthwiseSeparableConv(in3, denseBlockParams.conv2, [
            1,
            1
        ]);
        var in4 = _tfjsCore.relu(_tfjsCore.add(out1, _tfjsCore.add(out2, out3)));
        var out4 = _depthwiseSeparableConv.depthwiseSeparableConv(in4, denseBlockParams.conv3, [
            1,
            1
        ]);
        return _tfjsCore.relu(_tfjsCore.add(out1, _tfjsCore.add(out2, _tfjsCore.add(out3, out4))));
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common/depthwiseSeparableConv":"7Aiha","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7Aiha":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "depthwiseSeparableConv", ()=>depthwiseSeparableConv
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function depthwiseSeparableConv(x, params, stride) {
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same');
        out = _tfjsCore.add(out, params.bias);
        return out;
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lvrRU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _common = require("../common");
var _extractorsFactory = require("./extractorsFactory");
function extractParams(weights) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock4Params = _extractorsFactory.extractorsFactory(extractWeights, paramMappings).extractDenseBlock4Params;
    var dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock4Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock4Params(64, 128, 'dense2');
    var dense3 = extractDenseBlock4Params(128, 256, 'dense3');
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        paramMappings: paramMappings,
        params: {
            dense0: dense0,
            dense1: dense1,
            dense2: dense2,
            dense3: dense3
        }
    };
}

},{"../common":"iFr5j","./extractorsFactory":"kjx5y","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iFr5j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _convLayer = require("./convLayer");
parcelHelpers.exportAll(_convLayer, exports);
var _depthwiseSeparableConv = require("./depthwiseSeparableConv");
parcelHelpers.exportAll(_depthwiseSeparableConv, exports);
var _disposeUnusedWeightTensors = require("./disposeUnusedWeightTensors");
parcelHelpers.exportAll(_disposeUnusedWeightTensors, exports);
var _extractConvParamsFactory = require("./extractConvParamsFactory");
parcelHelpers.exportAll(_extractConvParamsFactory, exports);
var _extractFCParamsFactory = require("./extractFCParamsFactory");
parcelHelpers.exportAll(_extractFCParamsFactory, exports);
var _extractSeparableConvParamsFactory = require("./extractSeparableConvParamsFactory");
parcelHelpers.exportAll(_extractSeparableConvParamsFactory, exports);
var _extractWeightEntryFactory = require("./extractWeightEntryFactory");
parcelHelpers.exportAll(_extractWeightEntryFactory, exports);
var _extractWeightsFactory = require("./extractWeightsFactory");
parcelHelpers.exportAll(_extractWeightsFactory, exports);
var _getModelUris = require("./getModelUris");
parcelHelpers.exportAll(_getModelUris, exports);
var _types = require("./types");
parcelHelpers.exportAll(_types, exports);

},{"./convLayer":"5hXPo","./depthwiseSeparableConv":"7Aiha","./disposeUnusedWeightTensors":"1Ca5I","./extractConvParamsFactory":"lxgFO","./extractFCParamsFactory":"7oibK","./extractSeparableConvParamsFactory":"iqrvI","./extractWeightEntryFactory":"32aWV","./extractWeightsFactory":"6cLIi","./getModelUris":"gHelh","./types":"fUyyq","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5hXPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convLayer", ()=>convLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function convLayer(x, params, padding, withRelu) {
    if (padding === void 0) padding = 'same';
    if (withRelu === void 0) withRelu = false;
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.add(_tfjsCore.conv2d(x, params.filters, [
            1,
            1
        ], padding), params.bias);
        return withRelu ? _tfjsCore.relu(out) : out;
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1Ca5I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "disposeUnusedWeightTensors", ()=>disposeUnusedWeightTensors
);
function disposeUnusedWeightTensors(weightMap, paramMappings) {
    Object.keys(weightMap).forEach(function(path) {
        if (!paramMappings.some(function(pm) {
            return pm.originalPath === path;
        })) weightMap[path].dispose();
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lxgFO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractConvParamsFactory", ()=>extractConvParamsFactory
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function extractConvParamsFactory(extractWeights, paramMappings) {
    return function(channelsIn, channelsOut, filterSize, mappedPrefix) {
        var filters = _tfjsCore.tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [
            filterSize,
            filterSize,
            channelsIn,
            channelsOut
        ]);
        var bias = _tfjsCore.tensor1d(extractWeights(channelsOut));
        paramMappings.push({
            paramPath: mappedPrefix + "/filters"
        }, {
            paramPath: mappedPrefix + "/bias"
        });
        return {
            filters: filters,
            bias: bias
        };
    };
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7oibK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractFCParamsFactory", ()=>extractFCParamsFactory
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function extractFCParamsFactory(extractWeights, paramMappings) {
    return function(channelsIn, channelsOut, mappedPrefix) {
        var fc_weights = _tfjsCore.tensor2d(extractWeights(channelsIn * channelsOut), [
            channelsIn,
            channelsOut
        ]);
        var fc_bias = _tfjsCore.tensor1d(extractWeights(channelsOut));
        paramMappings.push({
            paramPath: mappedPrefix + "/weights"
        }, {
            paramPath: mappedPrefix + "/bias"
        });
        return {
            weights: fc_weights,
            bias: fc_bias
        };
    };
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iqrvI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractSeparableConvParamsFactory", ()=>extractSeparableConvParamsFactory
);
parcelHelpers.export(exports, "loadSeparableConvParamsFactory", ()=>loadSeparableConvParamsFactory
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _types = require("./types");
function extractSeparableConvParamsFactory(extractWeights, paramMappings) {
    return function(channelsIn, channelsOut, mappedPrefix) {
        var depthwise_filter = _tfjsCore.tensor4d(extractWeights(9 * channelsIn), [
            3,
            3,
            channelsIn,
            1
        ]);
        var pointwise_filter = _tfjsCore.tensor4d(extractWeights(channelsIn * channelsOut), [
            1,
            1,
            channelsIn,
            channelsOut
        ]);
        var bias = _tfjsCore.tensor1d(extractWeights(channelsOut));
        paramMappings.push({
            paramPath: mappedPrefix + "/depthwise_filter"
        }, {
            paramPath: mappedPrefix + "/pointwise_filter"
        }, {
            paramPath: mappedPrefix + "/bias"
        });
        return new _types.SeparableConvParams(depthwise_filter, pointwise_filter, bias);
    };
}
function loadSeparableConvParamsFactory(extractWeightEntry) {
    return function(prefix) {
        var depthwise_filter = extractWeightEntry(prefix + "/depthwise_filter", 4);
        var pointwise_filter = extractWeightEntry(prefix + "/pointwise_filter", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return new _types.SeparableConvParams(depthwise_filter, pointwise_filter, bias);
    };
}

},{"@tensorflow/tfjs-core":"82lJf","./types":"fUyyq","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fUyyq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SeparableConvParams", ()=>SeparableConvParams
);
var SeparableConvParams = function() {
    function SeparableConvParams1(depthwise_filter, pointwise_filter, bias) {
        this.depthwise_filter = depthwise_filter;
        this.pointwise_filter = pointwise_filter;
        this.bias = bias;
    }
    return SeparableConvParams1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"32aWV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractWeightEntryFactory", ()=>extractWeightEntryFactory
);
var _utils = require("../utils");
function extractWeightEntryFactory(weightMap, paramMappings) {
    return function(originalPath, paramRank, mappedPath) {
        var tensor = weightMap[originalPath];
        if (!_utils.isTensor(tensor, paramRank)) throw new Error("expected weightMap[" + originalPath + "] to be a Tensor" + paramRank + "D, instead have " + tensor);
        paramMappings.push({
            originalPath: originalPath,
            paramPath: mappedPath || originalPath
        });
        return tensor;
    };
}

},{"../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6cLIi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractWeightsFactory", ()=>extractWeightsFactory
);
function extractWeightsFactory(weights) {
    var remainingWeights = weights;
    function extractWeights(numWeights) {
        var ret = remainingWeights.slice(0, numWeights);
        remainingWeights = remainingWeights.slice(numWeights);
        return ret;
    }
    function getRemainingWeights() {
        return remainingWeights;
    }
    return {
        extractWeights: extractWeights,
        getRemainingWeights: getRemainingWeights
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kjx5y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractorsFactory", ()=>extractorsFactory
);
var _common = require("../common");
function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = _common.extractConvParamsFactory(extractWeights, paramMappings);
    var extractSeparableConvParams = _common.extractSeparableConvParamsFactory(extractWeights, paramMappings);
    function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) isFirstLayer = false;
        var conv0 = isFirstLayer ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv0") : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/conv0");
        var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv1");
        var conv2 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv2");
        return {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2
        };
    }
    function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) isFirstLayer = false;
        var _a = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer), conv0 = _a.conv0, conv1 = _a.conv1, conv2 = _a.conv2;
        var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv3");
        return {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2,
            conv3: conv3
        };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}

},{"../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bjOvZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
var _loadParamsFactory = require("./loadParamsFactory");
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractDenseBlock4Params = _loadParamsFactory.loadParamsFactory(weightMap, paramMappings).extractDenseBlock4Params;
    var params = {
        dense0: extractDenseBlock4Params('dense0', true),
        dense1: extractDenseBlock4Params('dense1'),
        dense2: extractDenseBlock4Params('dense2'),
        dense3: extractDenseBlock4Params('dense3')
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","./loadParamsFactory":"bN6Cu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bN6Cu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadParamsFactory", ()=>loadParamsFactory
);
var _common = require("../common");
var _loadConvParamsFactory = require("../common/loadConvParamsFactory");
function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    var extractConvParams = _loadConvParamsFactory.loadConvParamsFactory(extractWeightEntry);
    var extractSeparableConvParams = _common.loadSeparableConvParamsFactory(extractWeightEntry);
    function extractDenseBlock3Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) isFirstLayer = false;
        var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        return {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2
        };
    }
    function extractDenseBlock4Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) isFirstLayer = false;
        var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        var conv3 = extractSeparableConvParams(prefix + "/conv3");
        return {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2,
            conv3: conv3
        };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}

},{"../common":"iFr5j","../common/loadConvParamsFactory":"giQpk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"giQpk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadConvParamsFactory", ()=>loadConvParamsFactory
);
function loadConvParamsFactory(extractWeightEntry) {
    return function(prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            filters: filters,
            bias: bias
        };
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9R6YA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceProcessor", ()=>FaceProcessor1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _fullyConnectedLayer = require("../common/fullyConnectedLayer");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _util = require("./util");
var FaceProcessor1 = function(_super) {
    _tslib.__extends(FaceProcessor2, _super);
    function FaceProcessor2(_name, faceFeatureExtractor) {
        var _this = _super.call(this, _name) || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(FaceProcessor2.prototype, "faceFeatureExtractor", {
        get: function() {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    FaceProcessor2.prototype.runNet = function(input) {
        var _this = this;
        var params = this.params;
        if (!params) throw new Error(this._name + " - load model before inference");
        return _tfjsCore.tidy(function() {
            var bottleneckFeatures = input instanceof _dom.NetInput ? _this.faceFeatureExtractor.forwardInput(input) : input;
            return _fullyConnectedLayer.fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);
        });
    };
    FaceProcessor2.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) throwOnRedispose = true;
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    FaceProcessor2.prototype.loadClassifierParams = function(weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    FaceProcessor2.prototype.extractClassifierParams = function(weights) {
        return _extractParams.extractParams(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
    };
    FaceProcessor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        var _a = _util.seperateWeightMaps(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(classifierMap);
    };
    FaceProcessor2.prototype.extractParams = function(weights) {
        var cIn = this.getClassifierChannelsIn();
        var cOut = this.getClassifierChannelsOut();
        var classifierWeightSize = cOut * cIn + cOut;
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return FaceProcessor2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../common/fullyConnectedLayer":"1o20S","../dom":"eQw1p","../NeuralNetwork":"lrDwN","./extractParams":"7wb3o","./extractParamsFromWeigthMap":"goqlc","./util":"5qZTX","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1o20S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fullyConnectedLayer", ()=>fullyConnectedLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function fullyConnectedLayer(x, params) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.add(_tfjsCore.matMul(x, params.weights), params.bias);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7wb3o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _common = require("../common");
function extractParams(weights, channelsIn, channelsOut) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = _common.extractFCParamsFactory(extractWeights, paramMappings);
    var fc = extractFCParams(channelsIn, channelsOut, 'fc');
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        paramMappings: paramMappings,
        params: {
            fc: fc
        }
    };
}

},{"../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"goqlc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            weights: weights,
            bias: bias
        };
    }
    var params = {
        fc: extractFcParams('fc')
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5qZTX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "seperateWeightMaps", ()=>seperateWeightMaps
);
function seperateWeightMaps(weightMap) {
    var featureExtractorMap = {
    };
    var classifierMap = {
    };
    Object.keys(weightMap).forEach(function(key) {
        var map = key.startsWith('fc') ? classifierMap : featureExtractorMap;
        map[key] = weightMap[key];
    });
    return {
        featureExtractorMap: featureExtractorMap,
        classifierMap: classifierMap
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"loD35":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FACE_EXPRESSION_LABELS", ()=>FACE_EXPRESSION_LABELS
);
parcelHelpers.export(exports, "FaceExpressions", ()=>FaceExpressions
);
var FACE_EXPRESSION_LABELS = [
    'neutral',
    'happy',
    'sad',
    'angry',
    'fearful',
    'disgusted',
    'surprised'
];
var FaceExpressions = function() {
    function FaceExpressions1(probabilities) {
        var _this = this;
        if (probabilities.length !== 7) throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + probabilities.length);
        FACE_EXPRESSION_LABELS.forEach(function(expression, idx) {
            _this[expression] = probabilities[idx];
        });
    }
    FaceExpressions1.prototype.asSortedArray = function() {
        var _this = this;
        return FACE_EXPRESSION_LABELS.map(function(expression) {
            return {
                expression: expression,
                probability: _this[expression]
            };
        }).sort(function(e0, e1) {
            return e1.probability - e0.probability;
        });
    };
    return FaceExpressions1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eO705":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWithFaceExpressions", ()=>isWithFaceExpressions
);
parcelHelpers.export(exports, "extendWithFaceExpressions", ()=>extendWithFaceExpressions
);
var _faceExpressions = require("../faceExpressionNet/FaceExpressions");
function isWithFaceExpressions(obj) {
    return obj['expressions'] instanceof _faceExpressions.FaceExpressions;
}
function extendWithFaceExpressions(sourceObj, expressions) {
    var extension = {
        expressions: expressions
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"../faceExpressionNet/FaceExpressions":"loD35","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jUad3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DrawFaceLandmarksOptions", ()=>DrawFaceLandmarksOptions
);
parcelHelpers.export(exports, "DrawFaceLandmarks", ()=>DrawFaceLandmarks
);
parcelHelpers.export(exports, "drawFaceLandmarks", ()=>drawFaceLandmarks
);
var _faceLandmarks = require("../classes/FaceLandmarks");
var _faceLandmarks68 = require("../classes/FaceLandmarks68");
var _getContext2DOrThrow = require("../dom/getContext2dOrThrow");
var _withFaceLandmarks = require("../factories/WithFaceLandmarks");
var _drawContour = require("./drawContour");
var DrawFaceLandmarksOptions = function() {
    function DrawFaceLandmarksOptions1(options) {
        if (options === void 0) options = {
        };
        var _a = options.drawLines, drawLines = _a === void 0 ? true : _a, _b = options.drawPoints, drawPoints = _b === void 0 ? true : _b, lineWidth = options.lineWidth, lineColor = options.lineColor, pointSize = options.pointSize, pointColor = options.pointColor;
        this.drawLines = drawLines;
        this.drawPoints = drawPoints;
        this.lineWidth = lineWidth || 1;
        this.pointSize = pointSize || 2;
        this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';
        this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';
    }
    return DrawFaceLandmarksOptions1;
}();
var DrawFaceLandmarks = function() {
    function DrawFaceLandmarks1(faceLandmarks, options) {
        if (options === void 0) options = {
        };
        this.faceLandmarks = faceLandmarks;
        this.options = new DrawFaceLandmarksOptions(options);
    }
    DrawFaceLandmarks1.prototype.draw = function(canvasArg) {
        var ctx = _getContext2DOrThrow.getContext2dOrThrow(canvasArg);
        var _a = this.options, drawLines = _a.drawLines, drawPoints = _a.drawPoints, lineWidth = _a.lineWidth, lineColor = _a.lineColor, pointSize = _a.pointSize, pointColor = _a.pointColor;
        if (drawLines && this.faceLandmarks instanceof _faceLandmarks68.FaceLandmarks68) {
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;
            _drawContour.drawContour(ctx, this.faceLandmarks.getJawOutline());
            _drawContour.drawContour(ctx, this.faceLandmarks.getLeftEyeBrow());
            _drawContour.drawContour(ctx, this.faceLandmarks.getRightEyeBrow());
            _drawContour.drawContour(ctx, this.faceLandmarks.getNose());
            _drawContour.drawContour(ctx, this.faceLandmarks.getLeftEye(), true);
            _drawContour.drawContour(ctx, this.faceLandmarks.getRightEye(), true);
            _drawContour.drawContour(ctx, this.faceLandmarks.getMouth(), true);
        }
        if (drawPoints) {
            ctx.strokeStyle = pointColor;
            ctx.fillStyle = pointColor;
            var drawPoint = function(pt) {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);
                ctx.fill();
            };
            this.faceLandmarks.positions.forEach(drawPoint);
        }
    };
    return DrawFaceLandmarks1;
}();
function drawFaceLandmarks(canvasArg, faceLandmarks) {
    var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [
        faceLandmarks
    ];
    faceLandmarksArray.forEach(function(f) {
        var landmarks = f instanceof _faceLandmarks.FaceLandmarks ? f : _withFaceLandmarks.isWithFaceLandmarks(f) ? f.landmarks : undefined;
        if (!landmarks) throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');
        new DrawFaceLandmarks(landmarks).draw(canvasArg);
    });
}

},{"../classes/FaceLandmarks":"bin8I","../classes/FaceLandmarks68":"3c9t5","../dom/getContext2dOrThrow":"trz3D","../factories/WithFaceLandmarks":"136nl","./drawContour":"6cgKF","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"136nl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWithFaceLandmarks", ()=>isWithFaceLandmarks
);
parcelHelpers.export(exports, "extendWithFaceLandmarks", ()=>extendWithFaceLandmarks
);
var _faceDetection = require("../classes/FaceDetection");
var _faceLandmarks = require("../classes/FaceLandmarks");
var _withFaceDetection = require("./WithFaceDetection");
function isWithFaceLandmarks(obj) {
    return _withFaceDetection.isWithFaceDetection(obj) && obj['landmarks'] instanceof _faceLandmarks.FaceLandmarks && obj['unshiftedLandmarks'] instanceof _faceLandmarks.FaceLandmarks && obj['alignedRect'] instanceof _faceDetection.FaceDetection;
}
function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {
    var shift = sourceObj.detection.box;
    var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);
    var rect = landmarks.align();
    var imageDims = sourceObj.detection.imageDims;
    var alignedRect = new _faceDetection.FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);
    var extension = {
        landmarks: landmarks,
        unshiftedLandmarks: unshiftedLandmarks,
        alignedRect: alignedRect
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"../classes/FaceDetection":"f78Si","../classes/FaceLandmarks":"bin8I","./WithFaceDetection":"bFfpU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jgWeC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ageGenderNet = require("./AgeGenderNet");
parcelHelpers.exportAll(_ageGenderNet, exports);
var _types = require("./types");
parcelHelpers.exportAll(_types, exports);

},{"./AgeGenderNet":"kpblP","./types":"fLh7S","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kpblP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AgeGenderNet", ()=>AgeGenderNet1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _fullyConnectedLayer = require("../common/fullyConnectedLayer");
var _util = require("../faceProcessor/util");
var _tinyXception = require("../xception/TinyXception");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _types = require("./types");
var _neuralNetwork = require("../NeuralNetwork");
var _dom = require("../dom");
var AgeGenderNet1 = function(_super) {
    _tslib.__extends(AgeGenderNet2, _super);
    function AgeGenderNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) faceFeatureExtractor = new _tinyXception.TinyXception(2);
        var _this = _super.call(this, 'AgeGenderNet') || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(AgeGenderNet2.prototype, "faceFeatureExtractor", {
        get: function() {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    AgeGenderNet2.prototype.runNet = function(input) {
        var _this = this;
        var params = this.params;
        if (!params) throw new Error(this._name + " - load model before inference");
        return _tfjsCore.tidy(function() {
            var bottleneckFeatures = input instanceof _dom.NetInput ? _this.faceFeatureExtractor.forwardInput(input) : input;
            var pooled = _tfjsCore.avgPool(bottleneckFeatures, [
                7,
                7
            ], [
                2,
                2
            ], 'valid').as2D(bottleneckFeatures.shape[0], -1);
            var age = _fullyConnectedLayer.fullyConnectedLayer(pooled, params.fc.age).as1D();
            var gender = _fullyConnectedLayer.fullyConnectedLayer(pooled, params.fc.gender);
            return {
                age: age,
                gender: gender
            };
        });
    };
    AgeGenderNet2.prototype.forwardInput = function(input) {
        var _this = this;
        return _tfjsCore.tidy(function() {
            var _a = _this.runNet(input), age = _a.age, gender = _a.gender;
            return {
                age: age,
                gender: _tfjsCore.softmax(gender)
            };
        });
    };
    AgeGenderNet2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    AgeGenderNet2.prototype.predictAgeAndGender = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var netInput, out, ages, genders, ageAndGenderTensors, predictionsByBatch;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.forwardInput(netInput)
                        ];
                    case 2:
                        out = _a.sent();
                        ages = _tfjsCore.unstack(out.age);
                        genders = _tfjsCore.unstack(out.gender);
                        ageAndGenderTensors = ages.map(function(ageTensor, i) {
                            return {
                                ageTensor: ageTensor,
                                genderTensor: genders[i]
                            };
                        });
                        return [
                            4 /*yield*/ ,
                            Promise.all(ageAndGenderTensors.map(function(_a1) {
                                var ageTensor = _a1.ageTensor, genderTensor = _a1.genderTensor;
                                return _tslib.__awaiter(_this, void 0, void 0, function() {
                                    var age, probMale, isMale, gender, genderProbability;
                                    return _tslib.__generator(this, function(_b) {
                                        switch(_b.label){
                                            case 0:
                                                return [
                                                    4 /*yield*/ ,
                                                    ageTensor.data()
                                                ];
                                            case 1:
                                                age = _b.sent()[0];
                                                return [
                                                    4 /*yield*/ ,
                                                    genderTensor.data()
                                                ];
                                            case 2:
                                                probMale = _b.sent()[0];
                                                isMale = probMale > 0.5;
                                                gender = isMale ? _types.Gender.MALE : _types.Gender.FEMALE;
                                                genderProbability = isMale ? probMale : 1 - probMale;
                                                ageTensor.dispose();
                                                genderTensor.dispose();
                                                return [
                                                    2 /*return*/ ,
                                                    {
                                                        age: age,
                                                        gender: gender,
                                                        genderProbability: genderProbability
                                                    }
                                                ];
                                        }
                                    });
                                });
                            }))
                        ];
                    case 3:
                        predictionsByBatch = _a.sent();
                        out.age.dispose();
                        out.gender.dispose();
                        return [
                            2 /*return*/ ,
                            netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]
                        ];
                }
            });
        });
    };
    AgeGenderNet2.prototype.getDefaultModelName = function() {
        return 'age_gender_model';
    };
    AgeGenderNet2.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) throwOnRedispose = true;
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    AgeGenderNet2.prototype.loadClassifierParams = function(weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    AgeGenderNet2.prototype.extractClassifierParams = function(weights) {
        return _extractParams.extractParams(weights);
    };
    AgeGenderNet2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        var _a = _util.seperateWeightMaps(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(classifierMap);
    };
    AgeGenderNet2.prototype.extractParams = function(weights) {
        var classifierWeightSize = 1539;
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return AgeGenderNet2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../common/fullyConnectedLayer":"1o20S","../faceProcessor/util":"5qZTX","../xception/TinyXception":"ahLdR","./extractParams":"jNVTD","./extractParamsFromWeigthMap":"yNECb","./types":"fLh7S","../NeuralNetwork":"lrDwN","../dom":"eQw1p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ahLdR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyXception", ()=>TinyXception1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _ops = require("../ops");
var _utils = require("../utils");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
function conv(x, params, stride) {
    return _tfjsCore.add(_tfjsCore.conv2d(x, params.filters, stride, 'same'), params.bias);
}
function reductionBlock(x, params, isActivateInput) {
    if (isActivateInput === void 0) isActivateInput = true;
    var out = isActivateInput ? _tfjsCore.relu(x) : x;
    out = _common.depthwiseSeparableConv(out, params.separable_conv0, [
        1,
        1
    ]);
    out = _common.depthwiseSeparableConv(_tfjsCore.relu(out), params.separable_conv1, [
        1,
        1
    ]);
    out = _tfjsCore.maxPool(out, [
        3,
        3
    ], [
        2,
        2
    ], 'same');
    out = _tfjsCore.add(out, conv(x, params.expansion_conv, [
        2,
        2
    ]));
    return out;
}
function mainBlock(x, params) {
    var out = _common.depthwiseSeparableConv(_tfjsCore.relu(x), params.separable_conv0, [
        1,
        1
    ]);
    out = _common.depthwiseSeparableConv(_tfjsCore.relu(out), params.separable_conv1, [
        1,
        1
    ]);
    out = _common.depthwiseSeparableConv(_tfjsCore.relu(out), params.separable_conv2, [
        1,
        1
    ]);
    out = _tfjsCore.add(out, x);
    return out;
}
var TinyXception1 = function(_super) {
    _tslib.__extends(TinyXception2, _super);
    function TinyXception2(numMainBlocks) {
        var _this = _super.call(this, 'TinyXception') || this;
        _this._numMainBlocks = numMainBlocks;
        return _this;
    }
    TinyXception2.prototype.forwardInput = function(input) {
        var _this = this;
        var params = this.params;
        if (!params) throw new Error('TinyXception - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [
                122.782,
                117.001,
                104.298
            ];
            var normalized = _ops.normalize(batchTensor, meanRgb).div(_tfjsCore.scalar(256));
            var out = _tfjsCore.relu(conv(normalized, params.entry_flow.conv_in, [
                2,
                2
            ]));
            out = reductionBlock(out, params.entry_flow.reduction_block_0, false);
            out = reductionBlock(out, params.entry_flow.reduction_block_1);
            _utils.range(_this._numMainBlocks, 0, 1).forEach(function(idx) {
                out = mainBlock(out, params.middle_flow["main_block_" + idx]);
            });
            out = reductionBlock(out, params.exit_flow.reduction_block);
            out = _tfjsCore.relu(_common.depthwiseSeparableConv(out, params.exit_flow.separable_conv, [
                1,
                1
            ]));
            return out;
        });
    };
    TinyXception2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    TinyXception2.prototype.getDefaultModelName = function() {
        return 'tiny_xception_model';
    };
    TinyXception2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap, this._numMainBlocks);
    };
    TinyXception2.prototype.extractParams = function(weights) {
        return _extractParams.extractParams(weights, this._numMainBlocks);
    };
    return TinyXception2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","../dom":"eQw1p","../NeuralNetwork":"lrDwN","../ops":"cSYle","../utils":"1iSuU","./extractParams":"lpiPB","./extractParamsFromWeigthMap":"eXCeA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lpiPB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _common = require("../common");
var _utils = require("../utils");
function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = _common.extractConvParamsFactory(extractWeights, paramMappings);
    var extractSeparableConvParams = _common.extractSeparableConvParamsFactory(extractWeights, paramMappings);
    function extractReductionBlockParams(channelsIn, channelsOut, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/expansion_conv");
        return {
            separable_conv0: separable_conv0,
            separable_conv1: separable_conv1,
            expansion_conv: expansion_conv
        };
    }
    function extractMainBlockParams(channels, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv2");
        return {
            separable_conv0: separable_conv0,
            separable_conv1: separable_conv1,
            separable_conv2: separable_conv2
        };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParams(weights, numMainBlocks) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractSeparableConvParams = _b.extractSeparableConvParams, extractReductionBlockParams = _b.extractReductionBlockParams, extractMainBlockParams = _b.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {
    };
    _utils.range(numMainBlocks, 0, 1).forEach(function(idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams(128, "middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        paramMappings: paramMappings,
        params: {
            entry_flow: entry_flow,
            middle_flow: middle_flow,
            exit_flow: exit_flow
        }
    };
}

},{"../common":"iFr5j","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eXCeA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
var _loadConvParamsFactory = require("../common/loadConvParamsFactory");
var _utils = require("../utils");
function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    var extractConvParams = _loadConvParamsFactory.loadConvParamsFactory(extractWeightEntry);
    var extractSeparableConvParams = _common.loadSeparableConvParamsFactory(extractWeightEntry);
    function extractReductionBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(mappedPrefix + "/expansion_conv");
        return {
            separable_conv0: separable_conv0,
            separable_conv1: separable_conv1,
            expansion_conv: expansion_conv
        };
    }
    function extractMainBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(mappedPrefix + "/separable_conv2");
        return {
            separable_conv0: separable_conv0,
            separable_conv1: separable_conv1,
            separable_conv2: separable_conv2
        };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParamsFromWeigthMap(weightMap, numMainBlocks) {
    var paramMappings = [];
    var _a = loadParamsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractSeparableConvParams = _a.extractSeparableConvParams, extractReductionBlockParams = _a.extractReductionBlockParams, extractMainBlockParams = _a.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams('entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {
    };
    _utils.range(numMainBlocks, 0, 1).forEach(function(idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams("middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: {
            entry_flow: entry_flow,
            middle_flow: middle_flow,
            exit_flow: exit_flow
        },
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","../common/loadConvParamsFactory":"giQpk","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jNVTD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _common = require("../common");
function extractParams(weights) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = _common.extractFCParamsFactory(extractWeights, paramMappings);
    var age = extractFCParams(512, 1, 'fc/age');
    var gender = extractFCParams(512, 2, 'fc/gender');
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        paramMappings: paramMappings,
        params: {
            fc: {
                age: age,
                gender: gender
            }
        }
    };
}

},{"../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"yNECb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            weights: weights,
            bias: bias
        };
    }
    var params = {
        fc: {
            age: extractFcParams('fc/age'),
            gender: extractFcParams('fc/gender')
        }
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fLh7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Gender", ()=>Gender
);
var Gender;
(function(Gender1) {
    Gender1["FEMALE"] = "female";
    Gender1["MALE"] = "male";
})(Gender || (Gender = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3vPhu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmarkNet", ()=>FaceLandmarkNet1
);
var _tslib = require("tslib");
var _faceLandmark68Net = require("./FaceLandmark68Net");
parcelHelpers.exportAll(_faceLandmark68Net, exports);
var _faceLandmark68TinyNet = require("./FaceLandmark68TinyNet");
parcelHelpers.exportAll(_faceLandmark68TinyNet, exports);
var FaceLandmarkNet1 = function(_super) {
    _tslib.__extends(FaceLandmarkNet2, _super);
    function FaceLandmarkNet2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceLandmarkNet2;
}(_faceLandmark68Net.FaceLandmark68Net);

},{"tslib":"bjkXk","./FaceLandmark68Net":"wkF9f","./FaceLandmark68TinyNet":"dtdzn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"wkF9f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmark68Net", ()=>FaceLandmark68Net1
);
var _tslib = require("tslib");
var _faceFeatureExtractor = require("../faceFeatureExtractor/FaceFeatureExtractor");
var _faceLandmark68NetBase = require("./FaceLandmark68NetBase");
var FaceLandmark68Net1 = function(_super) {
    _tslib.__extends(FaceLandmark68Net2, _super);
    function FaceLandmark68Net2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) faceFeatureExtractor = new _faceFeatureExtractor.FaceFeatureExtractor();
        return _super.call(this, 'FaceLandmark68Net', faceFeatureExtractor) || this;
    }
    FaceLandmark68Net2.prototype.getDefaultModelName = function() {
        return 'face_landmark_68_model';
    };
    FaceLandmark68Net2.prototype.getClassifierChannelsIn = function() {
        return 256;
    };
    return FaceLandmark68Net2;
}(_faceLandmark68NetBase.FaceLandmark68NetBase);

},{"tslib":"bjkXk","../faceFeatureExtractor/FaceFeatureExtractor":"3l1PF","./FaceLandmark68NetBase":"5tQPd","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5tQPd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmark68NetBase", ()=>FaceLandmark68NetBase1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _faceLandmarks68 = require("../classes/FaceLandmarks68");
var _dom = require("../dom");
var _faceProcessor = require("../faceProcessor/FaceProcessor");
var _utils = require("../utils");
var FaceLandmark68NetBase1 = function(_super) {
    _tslib.__extends(FaceLandmark68NetBase2, _super);
    function FaceLandmark68NetBase2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmark68NetBase2.prototype.postProcess = function(output, inputSize, originalDimensions) {
        var inputDimensions = originalDimensions.map(function(_a) {
            var width = _a.width, height = _a.height;
            var scale = inputSize / Math.max(height, width);
            return {
                width: width * scale,
                height: height * scale
            };
        });
        var batchSize = inputDimensions.length;
        return _tfjsCore.tidy(function() {
            var createInterleavedTensor = function(fillX, fillY) {
                return _tfjsCore.stack([
                    _tfjsCore.fill([
                        68
                    ], fillX),
                    _tfjsCore.fill([
                        68
                    ], fillY)
                ], 1).as2D(1, 136).as1D();
            };
            var getPadding = function(batchIdx, cond) {
                var _a = inputDimensions[batchIdx], width = _a.width, height = _a.height;
                return cond(width, height) ? Math.abs(width - height) / 2 : 0;
            };
            var getPaddingX = function(batchIdx) {
                return getPadding(batchIdx, function(w, h) {
                    return w < h;
                });
            };
            var getPaddingY = function(batchIdx) {
                return getPadding(batchIdx, function(w, h) {
                    return h < w;
                });
            };
            var landmarkTensors = output.mul(_tfjsCore.fill([
                batchSize,
                136
            ], inputSize)).sub(_tfjsCore.stack(Array.from(Array(batchSize), function(_, batchIdx) {
                return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));
            }))).div(_tfjsCore.stack(Array.from(Array(batchSize), function(_, batchIdx) {
                return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);
            })));
            return landmarkTensors;
        });
    };
    FaceLandmark68NetBase2.prototype.forwardInput = function(input) {
        var _this = this;
        return _tfjsCore.tidy(function() {
            var out = _this.runNet(input);
            return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function(_a) {
                var height = _a[0], width = _a[1];
                return {
                    height: height,
                    width: width
                };
            }));
        });
    };
    FaceLandmark68NetBase2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    FaceLandmark68NetBase2.prototype.detectLandmarks = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var netInput, landmarkTensors, landmarksForBatch;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _a.sent();
                        landmarkTensors = _tfjsCore.tidy(function() {
                            return _tfjsCore.unstack(_this.forwardInput(netInput));
                        });
                        return [
                            4 /*yield*/ ,
                            Promise.all(landmarkTensors.map(function(landmarkTensor, batchIdx) {
                                return _tslib.__awaiter(_this, void 0, void 0, function() {
                                    var landmarksArray, _a1, _b, xCoords, yCoords;
                                    return _tslib.__generator(this, function(_c) {
                                        switch(_c.label){
                                            case 0:
                                                _b = (_a1 = Array).from;
                                                return [
                                                    4 /*yield*/ ,
                                                    landmarkTensor.data()
                                                ];
                                            case 1:
                                                landmarksArray = _b.apply(_a1, [
                                                    _c.sent()
                                                ]);
                                                xCoords = landmarksArray.filter(function(_, i) {
                                                    return _utils.isEven(i);
                                                });
                                                yCoords = landmarksArray.filter(function(_, i) {
                                                    return !_utils.isEven(i);
                                                });
                                                return [
                                                    2 /*return*/ ,
                                                    new _faceLandmarks68.FaceLandmarks68(Array(68).fill(0).map(function(_, i) {
                                                        return new _classes.Point(xCoords[i], yCoords[i]);
                                                    }), {
                                                        height: netInput.getInputHeight(batchIdx),
                                                        width: netInput.getInputWidth(batchIdx)
                                                    })
                                                ];
                                        }
                                    });
                                });
                            }))
                        ];
                    case 2:
                        landmarksForBatch = _a.sent();
                        landmarkTensors.forEach(function(t) {
                            return t.dispose();
                        });
                        return [
                            2 /*return*/ ,
                            netInput.isBatchInput ? landmarksForBatch : landmarksForBatch[0]
                        ];
                }
            });
        });
    };
    FaceLandmark68NetBase2.prototype.getClassifierChannelsOut = function() {
        return 136;
    };
    return FaceLandmark68NetBase2;
}(_faceProcessor.FaceProcessor);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../classes/FaceLandmarks68":"3c9t5","../dom":"eQw1p","../faceProcessor/FaceProcessor":"9R6YA","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dtdzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceLandmark68TinyNet", ()=>FaceLandmark68TinyNet1
);
var _tslib = require("tslib");
var _tinyFaceFeatureExtractor = require("../faceFeatureExtractor/TinyFaceFeatureExtractor");
var _faceLandmark68NetBase = require("./FaceLandmark68NetBase");
var FaceLandmark68TinyNet1 = function(_super) {
    _tslib.__extends(FaceLandmark68TinyNet2, _super);
    function FaceLandmark68TinyNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) faceFeatureExtractor = new _tinyFaceFeatureExtractor.TinyFaceFeatureExtractor();
        return _super.call(this, 'FaceLandmark68TinyNet', faceFeatureExtractor) || this;
    }
    FaceLandmark68TinyNet2.prototype.getDefaultModelName = function() {
        return 'face_landmark_68_tiny_model';
    };
    FaceLandmark68TinyNet2.prototype.getClassifierChannelsIn = function() {
        return 128;
    };
    return FaceLandmark68TinyNet2;
}(_faceLandmark68NetBase.FaceLandmark68NetBase);

},{"tslib":"bjkXk","../faceFeatureExtractor/TinyFaceFeatureExtractor":"6OsYT","./FaceLandmark68NetBase":"5tQPd","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6OsYT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyFaceFeatureExtractor", ()=>TinyFaceFeatureExtractor1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _ops = require("../ops");
var _denseBlock = require("./denseBlock");
var _extractParamsFromWeigthMapTiny = require("./extractParamsFromWeigthMapTiny");
var _extractParamsTiny = require("./extractParamsTiny");
var TinyFaceFeatureExtractor1 = function(_super) {
    _tslib.__extends(TinyFaceFeatureExtractor2, _super);
    function TinyFaceFeatureExtractor2() {
        return _super.call(this, 'TinyFaceFeatureExtractor') || this;
    }
    TinyFaceFeatureExtractor2.prototype.forwardInput = function(input) {
        var params = this.params;
        if (!params) throw new Error('TinyFaceFeatureExtractor - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [
                122.782,
                117.001,
                104.298
            ];
            var normalized = _ops.normalize(batchTensor, meanRgb).div(_tfjsCore.scalar(255));
            var out = _denseBlock.denseBlock3(normalized, params.dense0, true);
            out = _denseBlock.denseBlock3(out, params.dense1);
            out = _denseBlock.denseBlock3(out, params.dense2);
            out = _tfjsCore.avgPool(out, [
                14,
                14
            ], [
                2,
                2
            ], 'valid');
            return out;
        });
    };
    TinyFaceFeatureExtractor2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    TinyFaceFeatureExtractor2.prototype.getDefaultModelName = function() {
        return 'face_feature_extractor_tiny_model';
    };
    TinyFaceFeatureExtractor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMapTiny.extractParamsFromWeigthMapTiny(weightMap);
    };
    TinyFaceFeatureExtractor2.prototype.extractParams = function(weights) {
        return _extractParamsTiny.extractParamsTiny(weights);
    };
    return TinyFaceFeatureExtractor2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../NeuralNetwork":"lrDwN","../ops":"cSYle","./denseBlock":"15857","./extractParamsFromWeigthMapTiny":"hc3ll","./extractParamsTiny":"1HNbw","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hc3ll":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMapTiny", ()=>extractParamsFromWeigthMapTiny
);
var _common = require("../common");
var _loadParamsFactory = require("./loadParamsFactory");
function extractParamsFromWeigthMapTiny(weightMap) {
    var paramMappings = [];
    var extractDenseBlock3Params = _loadParamsFactory.loadParamsFactory(weightMap, paramMappings).extractDenseBlock3Params;
    var params = {
        dense0: extractDenseBlock3Params('dense0', true),
        dense1: extractDenseBlock3Params('dense1'),
        dense2: extractDenseBlock3Params('dense2')
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","./loadParamsFactory":"bN6Cu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1HNbw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsTiny", ()=>extractParamsTiny
);
var _common = require("../common");
var _extractorsFactory = require("./extractorsFactory");
function extractParamsTiny(weights) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock3Params = _extractorsFactory.extractorsFactory(extractWeights, paramMappings).extractDenseBlock3Params;
    var dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock3Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock3Params(64, 128, 'dense2');
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        paramMappings: paramMappings,
        params: {
            dense0: dense0,
            dense1: dense1,
            dense2: dense2
        }
    };
}

},{"../common":"iFr5j","./extractorsFactory":"kjx5y","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jiEYF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFaceRecognitionNet", ()=>createFaceRecognitionNet
);
var _faceRecognitionNet = require("./FaceRecognitionNet");
parcelHelpers.exportAll(_faceRecognitionNet, exports);
function createFaceRecognitionNet(weights) {
    var net = new _faceRecognitionNet.FaceRecognitionNet();
    net.extractWeights(weights);
    return net;
}

},{"./FaceRecognitionNet":"aOWlf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aOWlf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceRecognitionNet", ()=>FaceRecognitionNet1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _ops = require("../ops");
var _convLayer = require("./convLayer");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _residualLayer = require("./residualLayer");
var FaceRecognitionNet1 = function(_super) {
    _tslib.__extends(FaceRecognitionNet2, _super);
    function FaceRecognitionNet2() {
        return _super.call(this, 'FaceRecognitionNet') || this;
    }
    FaceRecognitionNet2.prototype.forwardInput = function(input) {
        var params = this.params;
        if (!params) throw new Error('FaceRecognitionNet - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(150, true).toFloat();
            var meanRgb = [
                122.782,
                117.001,
                104.298
            ];
            var normalized = _ops.normalize(batchTensor, meanRgb).div(_tfjsCore.scalar(256));
            var out = _convLayer.convDown(normalized, params.conv32_down);
            out = _tfjsCore.maxPool(out, 3, 2, 'valid');
            out = _residualLayer.residual(out, params.conv32_1);
            out = _residualLayer.residual(out, params.conv32_2);
            out = _residualLayer.residual(out, params.conv32_3);
            out = _residualLayer.residualDown(out, params.conv64_down);
            out = _residualLayer.residual(out, params.conv64_1);
            out = _residualLayer.residual(out, params.conv64_2);
            out = _residualLayer.residual(out, params.conv64_3);
            out = _residualLayer.residualDown(out, params.conv128_down);
            out = _residualLayer.residual(out, params.conv128_1);
            out = _residualLayer.residual(out, params.conv128_2);
            out = _residualLayer.residualDown(out, params.conv256_down);
            out = _residualLayer.residual(out, params.conv256_1);
            out = _residualLayer.residual(out, params.conv256_2);
            out = _residualLayer.residualDown(out, params.conv256_down_out);
            var globalAvg = out.mean([
                1,
                2
            ]);
            var fullyConnected = _tfjsCore.matMul(globalAvg, params.fc);
            return fullyConnected;
        });
    };
    FaceRecognitionNet2.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    FaceRecognitionNet2.prototype.computeFaceDescriptor = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var netInput, faceDescriptorTensors, faceDescriptorsForBatch;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _a.sent();
                        faceDescriptorTensors = _tfjsCore.tidy(function() {
                            return _tfjsCore.unstack(_this.forwardInput(netInput));
                        });
                        return [
                            4 /*yield*/ ,
                            Promise.all(faceDescriptorTensors.map(function(t) {
                                return t.data();
                            }))
                        ];
                    case 2:
                        faceDescriptorsForBatch = _a.sent();
                        faceDescriptorTensors.forEach(function(t) {
                            return t.dispose();
                        });
                        return [
                            2 /*return*/ ,
                            netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0]
                        ];
                }
            });
        });
    };
    FaceRecognitionNet2.prototype.getDefaultModelName = function() {
        return 'face_recognition_model';
    };
    FaceRecognitionNet2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap);
    };
    FaceRecognitionNet2.prototype.extractParams = function(weights) {
        return _extractParams.extractParams(weights);
    };
    return FaceRecognitionNet2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../NeuralNetwork":"lrDwN","../ops":"cSYle","./convLayer":"hMkmD","./extractParams":"fThbU","./extractParamsFromWeigthMap":"kW4yk","./residualLayer":"4STDD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hMkmD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "conv", ()=>conv
);
parcelHelpers.export(exports, "convNoRelu", ()=>convNoRelu
);
parcelHelpers.export(exports, "convDown", ()=>convDown
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _scaleLayer = require("./scaleLayer");
function convLayer(x, params, strides, withRelu, padding) {
    if (padding === void 0) padding = 'same';
    var _a = params.conv, filters = _a.filters, bias = _a.bias;
    var out = _tfjsCore.conv2d(x, filters, strides, padding);
    out = _tfjsCore.add(out, bias);
    out = _scaleLayer.scale(out, params.scale);
    return withRelu ? _tfjsCore.relu(out) : out;
}
function conv(x, params) {
    return convLayer(x, params, [
        1,
        1
    ], true);
}
function convNoRelu(x, params) {
    return convLayer(x, params, [
        1,
        1
    ], false);
}
function convDown(x, params) {
    return convLayer(x, params, [
        2,
        2
    ], true, 'valid');
}

},{"@tensorflow/tfjs-core":"82lJf","./scaleLayer":"iMefV","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iMefV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scale", ()=>scale
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function scale(x, params) {
    return _tfjsCore.add(_tfjsCore.mul(x, params.weights), params.biases);
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fThbU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _utils = require("../utils");
function extractorsFactory(extractWeights, paramMappings) {
    function extractFilterValues(numFilterValues, numFilters, filterSize) {
        var weights = extractWeights(numFilterValues);
        var depth = weights.length / (numFilters * filterSize * filterSize);
        if (_utils.isFloat(depth)) throw new Error("depth has to be an integer: " + depth + ", weights.length: " + weights.length + ", numFilters: " + numFilters + ", filterSize: " + filterSize);
        return _tfjsCore.tidy(function() {
            return _tfjsCore.transpose(_tfjsCore.tensor4d(weights, [
                numFilters,
                depth,
                filterSize,
                filterSize
            ]), [
                2,
                3,
                1,
                0
            ]);
        });
    }
    function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var filters = extractFilterValues(numFilterValues, numFilters, filterSize);
        var bias = _tfjsCore.tensor1d(extractWeights(numFilters));
        paramMappings.push({
            paramPath: mappedPrefix + "/filters"
        }, {
            paramPath: mappedPrefix + "/bias"
        });
        return {
            filters: filters,
            bias: bias
        };
    }
    function extractScaleLayerParams(numWeights, mappedPrefix) {
        var weights = _tfjsCore.tensor1d(extractWeights(numWeights));
        var biases = _tfjsCore.tensor1d(extractWeights(numWeights));
        paramMappings.push({
            paramPath: mappedPrefix + "/weights"
        }, {
            paramPath: mappedPrefix + "/biases"
        });
        return {
            weights: weights,
            biases: biases
        };
    }
    function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var conv = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv");
        var scale = extractScaleLayerParams(numFilters, mappedPrefix + "/scale");
        return {
            conv: conv,
            scale: scale
        };
    }
    function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {
        if (isDown === void 0) isDown = false;
        var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + "/conv1");
        var conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv2");
        return {
            conv1: conv1,
            conv2: conv2
        };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParams(weights) {
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvLayerParams = _b.extractConvLayerParams, extractResidualLayerParams = _b.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');
    var conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');
    var conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');
    var conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');
    var conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);
    var conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');
    var conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');
    var conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');
    var conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);
    var conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');
    var conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');
    var conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);
    var conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');
    var conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');
    var conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');
    var fc = _tfjsCore.tidy(function() {
        return _tfjsCore.transpose(_tfjsCore.tensor2d(extractWeights(32768), [
            128,
            256
        ]), [
            1,
            0
        ]);
    });
    paramMappings.push({
        paramPath: "fc"
    });
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kW4yk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
var _utils = require("../utils");
function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    function extractScaleLayerParams(prefix) {
        var weights = extractWeightEntry(prefix + "/scale/weights", 1);
        var biases = extractWeightEntry(prefix + "/scale/biases", 1);
        return {
            weights: weights,
            biases: biases
        };
    }
    function extractConvLayerParams(prefix) {
        var filters = extractWeightEntry(prefix + "/conv/filters", 4);
        var bias = extractWeightEntry(prefix + "/conv/bias", 1);
        var scale = extractScaleLayerParams(prefix);
        return {
            conv: {
                filters: filters,
                bias: bias
            },
            scale: scale
        };
    }
    function extractResidualLayerParams(prefix) {
        return {
            conv1: extractConvLayerParams(prefix + "/conv1"),
            conv2: extractConvLayerParams(prefix + "/conv2")
        };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvLayerParams = _a.extractConvLayerParams, extractResidualLayerParams = _a.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams('conv32_down');
    var conv32_1 = extractResidualLayerParams('conv32_1');
    var conv32_2 = extractResidualLayerParams('conv32_2');
    var conv32_3 = extractResidualLayerParams('conv32_3');
    var conv64_down = extractResidualLayerParams('conv64_down');
    var conv64_1 = extractResidualLayerParams('conv64_1');
    var conv64_2 = extractResidualLayerParams('conv64_2');
    var conv64_3 = extractResidualLayerParams('conv64_3');
    var conv128_down = extractResidualLayerParams('conv128_down');
    var conv128_1 = extractResidualLayerParams('conv128_1');
    var conv128_2 = extractResidualLayerParams('conv128_2');
    var conv256_down = extractResidualLayerParams('conv256_down');
    var conv256_1 = extractResidualLayerParams('conv256_1');
    var conv256_2 = extractResidualLayerParams('conv256_2');
    var conv256_down_out = extractResidualLayerParams('conv256_down_out');
    var fc = weightMap['fc'];
    paramMappings.push({
        originalPath: 'fc',
        paramPath: 'fc'
    });
    if (!_utils.isTensor2D(fc)) throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + fc);
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4STDD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "residual", ()=>residual
);
parcelHelpers.export(exports, "residualDown", ()=>residualDown
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _convLayer = require("./convLayer");
function residual(x, params) {
    var out = _convLayer.conv(x, params.conv1);
    out = _convLayer.convNoRelu(out, params.conv2);
    out = _tfjsCore.add(out, x);
    out = _tfjsCore.relu(out);
    return out;
}
function residualDown(x, params) {
    var out = _convLayer.convDown(x, params.conv1);
    out = _convLayer.convNoRelu(out, params.conv2);
    var pooled = _tfjsCore.avgPool(x, 2, 2, 'valid');
    var zeros = _tfjsCore.zeros(pooled.shape);
    var isPad = pooled.shape[3] !== out.shape[3];
    var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];
    if (isAdjustShape) {
        var padShapeX = _tslib.__spreadArrays(out.shape);
        padShapeX[1] = 1;
        var zerosW = _tfjsCore.zeros(padShapeX);
        out = _tfjsCore.concat([
            out,
            zerosW
        ], 1);
        var padShapeY = _tslib.__spreadArrays(out.shape);
        padShapeY[2] = 1;
        var zerosH = _tfjsCore.zeros(padShapeY);
        out = _tfjsCore.concat([
            out,
            zerosH
        ], 2);
    }
    pooled = isPad ? _tfjsCore.concat([
        pooled,
        zeros
    ], 3) : pooled;
    out = _tfjsCore.add(pooled, out);
    out = _tfjsCore.relu(out);
    return out;
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","./convLayer":"hMkmD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aAWYN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _withFaceDescriptor = require("./WithFaceDescriptor");
parcelHelpers.exportAll(_withFaceDescriptor, exports);
var _withFaceDetection = require("./WithFaceDetection");
parcelHelpers.exportAll(_withFaceDetection, exports);
var _withFaceExpressions = require("./WithFaceExpressions");
parcelHelpers.exportAll(_withFaceExpressions, exports);
var _withFaceLandmarks = require("./WithFaceLandmarks");
parcelHelpers.exportAll(_withFaceLandmarks, exports);
var _withAge = require("./WithAge");
parcelHelpers.exportAll(_withAge, exports);
var _withGender = require("./WithGender");
parcelHelpers.exportAll(_withGender, exports);

},{"./WithFaceDescriptor":"1TZn6","./WithFaceDetection":"bFfpU","./WithFaceExpressions":"eO705","./WithFaceLandmarks":"136nl","./WithAge":"2QX0z","./WithGender":"hgC3o","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1TZn6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extendWithFaceDescriptor", ()=>extendWithFaceDescriptor
);
function extendWithFaceDescriptor(sourceObj, descriptor) {
    var extension = {
        descriptor: descriptor
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2QX0z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWithAge", ()=>isWithAge
);
parcelHelpers.export(exports, "extendWithAge", ()=>extendWithAge
);
function isWithAge(obj) {
    return typeof obj['age'] === 'number';
}
function extendWithAge(sourceObj, age) {
    var extension = {
        age: age
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hgC3o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWithGender", ()=>isWithGender
);
parcelHelpers.export(exports, "extendWithGender", ()=>extendWithGender
);
var _types = require("../ageGenderNet/types");
var _utils = require("../utils");
function isWithGender(obj) {
    return (obj['gender'] === _types.Gender.MALE || obj['gender'] === _types.Gender.FEMALE) && _utils.isValidProbablitiy(obj['genderProbability']);
}
function extendWithGender(sourceObj, gender, genderProbability) {
    var extension = {
        gender: gender,
        genderProbability: genderProbability
    };
    return Object.assign({
    }, sourceObj, extension);
}

},{"../ageGenderNet/types":"fLh7S","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bkc93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _allFaces = require("./allFaces");
parcelHelpers.exportAll(_allFaces, exports);
var _composableTask = require("./ComposableTask");
parcelHelpers.exportAll(_composableTask, exports);
var _computeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");
parcelHelpers.exportAll(_computeFaceDescriptorsTasks, exports);
var _detectFaces = require("./detectFaces");
parcelHelpers.exportAll(_detectFaces, exports);
var _detectFacesTasks = require("./DetectFacesTasks");
parcelHelpers.exportAll(_detectFacesTasks, exports);
var _detectFaceLandmarksTasks = require("./DetectFaceLandmarksTasks");
parcelHelpers.exportAll(_detectFaceLandmarksTasks, exports);
var _faceMatcher = require("./FaceMatcher");
parcelHelpers.exportAll(_faceMatcher, exports);
var _nets = require("./nets");
parcelHelpers.exportAll(_nets, exports);

},{"./allFaces":"3XuDo","./ComposableTask":"fBnBt","./ComputeFaceDescriptorsTasks":"3I4nd","./detectFaces":"9zIwW","./DetectFacesTasks":"eRvJA","./DetectFaceLandmarksTasks":"h8WTa","./FaceMatcher":"27MNd","./nets":"7WlCP","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3XuDo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// export allFaces API for backward compatibility
parcelHelpers.export(exports, "allFacesSsdMobilenetv1", ()=>allFacesSsdMobilenetv1
);
parcelHelpers.export(exports, "allFacesTinyYolov2", ()=>allFacesTinyYolov2
);
parcelHelpers.export(exports, "allFacesMtcnn", ()=>allFacesMtcnn
);
parcelHelpers.export(exports, "allFaces", ()=>allFaces
);
var _tslib = require("tslib");
var _mtcnnOptions = require("../mtcnn/MtcnnOptions");
var _ssdMobilenetv1 = require("../ssdMobilenetv1");
var _tinyYolov2 = require("../tinyYolov2");
var _detectFaces = require("./detectFaces");
function allFacesSsdMobilenetv1(input, minConfidence) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    console.warn('allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead');
                    return [
                        4 /*yield*/ ,
                        _detectFaces.detectAllFaces(input, new _ssdMobilenetv1.SsdMobilenetv1Options(minConfidence ? {
                            minConfidence: minConfidence
                        } : {
                        })).withFaceLandmarks().withFaceDescriptors()
                    ];
                case 1:
                    return [
                        2 /*return*/ ,
                        _a.sent()
                    ];
            }
        });
    });
}
function allFacesTinyYolov2(input, forwardParams) {
    if (forwardParams === void 0) forwardParams = {
    };
    return _tslib.__awaiter(this, void 0, void 0, function() {
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    console.warn('allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead');
                    return [
                        4 /*yield*/ ,
                        _detectFaces.detectAllFaces(input, new _tinyYolov2.TinyYolov2Options(forwardParams)).withFaceLandmarks().withFaceDescriptors()
                    ];
                case 1:
                    return [
                        2 /*return*/ ,
                        _a.sent()
                    ];
            }
        });
    });
}
function allFacesMtcnn(input, forwardParams) {
    if (forwardParams === void 0) forwardParams = {
    };
    return _tslib.__awaiter(this, void 0, void 0, function() {
        return _tslib.__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    console.warn('allFacesMtcnn is deprecated and will be removed soon, use the high level api instead');
                    return [
                        4 /*yield*/ ,
                        _detectFaces.detectAllFaces(input, new _mtcnnOptions.MtcnnOptions(forwardParams)).withFaceLandmarks().withFaceDescriptors()
                    ];
                case 1:
                    return [
                        2 /*return*/ ,
                        _a.sent()
                    ];
            }
        });
    });
}
var allFaces = allFacesSsdMobilenetv1;

},{"tslib":"bjkXk","../mtcnn/MtcnnOptions":"wQQ5R","../ssdMobilenetv1":"5kiyG","../tinyYolov2":"3qveU","./detectFaces":"9zIwW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"wQQ5R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MtcnnOptions", ()=>MtcnnOptions
);
var MtcnnOptions = function() {
    function MtcnnOptions1(_a) {
        var _b = _a === void 0 ? {
        } : _a, minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
        this._name = 'MtcnnOptions';
        this._minFaceSize = minFaceSize || 20;
        this._scaleFactor = scaleFactor || 0.709;
        this._maxNumScales = maxNumScales || 10;
        this._scoreThresholds = scoreThresholds || [
            0.6,
            0.7,
            0.7
        ];
        this._scaleSteps = scaleSteps;
        if (typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) throw new Error(this._name + " - expected minFaceSize to be a number > 0");
        if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
        if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) throw new Error(this._name + " - expected maxNumScales to be a number > 0");
        if (!Array.isArray(this._scoreThresholds) || this._scoreThresholds.length !== 3 || this._scoreThresholds.some(function(th) {
            return typeof th !== 'number';
        })) throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
        if (this._scaleSteps && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function(th) {
            return typeof th !== 'number';
        }))) throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
    }
    Object.defineProperty(MtcnnOptions1.prototype, "minFaceSize", {
        get: function() {
            return this._minFaceSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions1.prototype, "scaleFactor", {
        get: function() {
            return this._scaleFactor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions1.prototype, "maxNumScales", {
        get: function() {
            return this._maxNumScales;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions1.prototype, "scoreThresholds", {
        get: function() {
            return this._scoreThresholds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions1.prototype, "scaleSteps", {
        get: function() {
            return this._scaleSteps;
        },
        enumerable: true,
        configurable: true
    });
    return MtcnnOptions1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5kiyG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSsdMobilenetv1", ()=>createSsdMobilenetv1
);
parcelHelpers.export(exports, "createFaceDetectionNet", ()=>createFaceDetectionNet
);
parcelHelpers.export(exports, "FaceDetectionNet", ()=>FaceDetectionNet1
);
var _tslib = require("tslib");
var _ssdMobilenetv1 = require("./SsdMobilenetv1");
parcelHelpers.exportAll(_ssdMobilenetv1, exports);
var _ssdMobilenetv1Options = require("./SsdMobilenetv1Options");
parcelHelpers.exportAll(_ssdMobilenetv1Options, exports);
function createSsdMobilenetv1(weights) {
    var net = new _ssdMobilenetv1.SsdMobilenetv1();
    net.extractWeights(weights);
    return net;
}
function createFaceDetectionNet(weights) {
    return createSsdMobilenetv1(weights);
}
// alias for backward compatibily
var FaceDetectionNet1 = function(_super) {
    _tslib.__extends(FaceDetectionNet2, _super);
    function FaceDetectionNet2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceDetectionNet2;
}(_ssdMobilenetv1.SsdMobilenetv1);

},{"tslib":"bjkXk","./SsdMobilenetv1":"dav1V","./SsdMobilenetv1Options":"ch8ze","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dav1V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SsdMobilenetv1", ()=>SsdMobilenetv11
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _faceDetection = require("../classes/FaceDetection");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _mobileNetV1 = require("./mobileNetV1");
var _nonMaxSuppression = require("./nonMaxSuppression");
var _outputLayer = require("./outputLayer");
var _predictionLayer = require("./predictionLayer");
var _ssdMobilenetv1Options = require("./SsdMobilenetv1Options");
var SsdMobilenetv11 = function(_super) {
    _tslib.__extends(SsdMobilenetv12, _super);
    function SsdMobilenetv12() {
        return _super.call(this, 'SsdMobilenetv1') || this;
    }
    SsdMobilenetv12.prototype.forwardInput = function(input) {
        var params = this.params;
        if (!params) throw new Error('SsdMobilenetv1 - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(512, false).toFloat();
            var x = _tfjsCore.sub(_tfjsCore.mul(batchTensor, _tfjsCore.scalar(0.007843137718737125)), _tfjsCore.scalar(1));
            var features = _mobileNetV1.mobileNetV1(x, params.mobilenetv1);
            var _a = _predictionLayer.predictionLayer(features.out, features.conv11, params.prediction_layer), boxPredictions = _a.boxPredictions, classPredictions = _a.classPredictions;
            return _outputLayer.outputLayer(boxPredictions, classPredictions, params.output_layer);
        });
    };
    SsdMobilenetv12.prototype.forward = function(input) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    SsdMobilenetv12.prototype.locateFaces = function(input, options) {
        if (options === void 0) options = {
        };
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;
            return _tslib.__generator(this, function(_e) {
                switch(_e.label){
                    case 0:
                        _a = new _ssdMobilenetv1Options.SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _e.sent();
                        _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;
                        boxes = _boxes[0];
                        scores = _scores[0];
                        for(i = 1; i < _boxes.length; i++){
                            _boxes[i].dispose();
                            _scores[i].dispose();
                        }
                        _d = (_c = Array).from;
                        return [
                            4 /*yield*/ ,
                            scores.data()
                        ];
                    case 2:
                        scoresData = _d.apply(_c, [
                            _e.sent()
                        ]);
                        iouThreshold = 0.5;
                        indices = _nonMaxSuppression.nonMaxSuppression(boxes, scoresData, maxResults, iouThreshold, minConfidence);
                        reshapedDims = netInput.getReshapedInputDimensions(0);
                        inputSize = netInput.inputSize;
                        padX = inputSize / reshapedDims.width;
                        padY = inputSize / reshapedDims.height;
                        boxesData = boxes.arraySync();
                        results = indices.map(function(idx) {
                            var _a1 = [
                                Math.max(0, boxesData[idx][0]),
                                Math.min(1, boxesData[idx][2])
                            ].map(function(val) {
                                return val * padY;
                            }), top = _a1[0], bottom = _a1[1];
                            var _b1 = [
                                Math.max(0, boxesData[idx][1]),
                                Math.min(1, boxesData[idx][3])
                            ].map(function(val) {
                                return val * padX;
                            }), left = _b1[0], right = _b1[1];
                            return new _faceDetection.FaceDetection(scoresData[idx], new _classes.Rect(left, top, right - left, bottom - top), {
                                height: netInput.getInputHeight(0),
                                width: netInput.getInputWidth(0)
                            });
                        });
                        boxes.dispose();
                        scores.dispose();
                        return [
                            2 /*return*/ ,
                            results
                        ];
                }
            });
        });
    };
    SsdMobilenetv12.prototype.getDefaultModelName = function() {
        return 'ssd_mobilenetv1_model';
    };
    SsdMobilenetv12.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap);
    };
    SsdMobilenetv12.prototype.extractParams = function(weights) {
        return _extractParams.extractParams(weights);
    };
    return SsdMobilenetv12;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../classes/FaceDetection":"f78Si","../dom":"eQw1p","../NeuralNetwork":"lrDwN","./extractParams":"iQRfT","./extractParamsFromWeigthMap":"7pTSh","./mobileNetV1":"5djaY","./nonMaxSuppression":"1wEG7","./outputLayer":"6udEQ","./predictionLayer":"83hwU","./SsdMobilenetv1Options":"ch8ze","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iQRfT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
function extractorsFactory(extractWeights, paramMappings) {
    function extractDepthwiseConvParams(numChannels, mappedPrefix) {
        var filters = _tfjsCore.tensor4d(extractWeights(9 * numChannels), [
            3,
            3,
            numChannels,
            1
        ]);
        var batch_norm_scale = _tfjsCore.tensor1d(extractWeights(numChannels));
        var batch_norm_offset = _tfjsCore.tensor1d(extractWeights(numChannels));
        var batch_norm_mean = _tfjsCore.tensor1d(extractWeights(numChannels));
        var batch_norm_variance = _tfjsCore.tensor1d(extractWeights(numChannels));
        paramMappings.push({
            paramPath: mappedPrefix + "/filters"
        }, {
            paramPath: mappedPrefix + "/batch_norm_scale"
        }, {
            paramPath: mappedPrefix + "/batch_norm_offset"
        }, {
            paramPath: mappedPrefix + "/batch_norm_mean"
        }, {
            paramPath: mappedPrefix + "/batch_norm_variance"
        });
        return {
            filters: filters,
            batch_norm_scale: batch_norm_scale,
            batch_norm_offset: batch_norm_offset,
            batch_norm_mean: batch_norm_mean,
            batch_norm_variance: batch_norm_variance
        };
    }
    function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {
        var filters = _tfjsCore.tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [
            filterSize,
            filterSize,
            channelsIn,
            channelsOut
        ]);
        var bias = _tfjsCore.tensor1d(extractWeights(channelsOut));
        paramMappings.push({
            paramPath: mappedPrefix + "/filters"
        }, {
            paramPath: mappedPrefix + "/" + (isPointwiseConv ? 'batch_norm_offset' : 'bias')
        });
        return {
            filters: filters,
            bias: bias
        };
    }
    function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {
        var _a = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true), filters = _a.filters, bias = _a.bias;
        return {
            filters: filters,
            batch_norm_offset: bias
        };
    }
    function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {
        var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + "/depthwise_conv");
        var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/pointwise_conv");
        return {
            depthwise_conv: depthwise_conv,
            pointwise_conv: pointwise_conv
        };
    }
    function extractMobilenetV1Params() {
        var conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');
        var conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');
        var conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');
        var conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');
        var conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');
        var conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');
        var conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');
        var conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');
        var conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');
        var conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');
        var conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');
        var conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');
        var conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');
        var conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            conv_8: conv_8,
            conv_9: conv_9,
            conv_10: conv_10,
            conv_11: conv_11,
            conv_12: conv_12,
            conv_13: conv_13
        };
    }
    function extractPredictionLayerParams() {
        var conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');
        var conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');
        var conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');
        var conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');
        var conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');
        var conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');
        var conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');
        var conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');
        var box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');
        var class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');
        var box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');
        var class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');
        var box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');
        var class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');
        var box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');
        var class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');
        var box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');
        var class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');
        var box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');
        var class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');
        var box_predictor_0 = {
            box_encoding_predictor: box_encoding_0_predictor,
            class_predictor: class_predictor_0
        };
        var box_predictor_1 = {
            box_encoding_predictor: box_encoding_1_predictor,
            class_predictor: class_predictor_1
        };
        var box_predictor_2 = {
            box_encoding_predictor: box_encoding_2_predictor,
            class_predictor: class_predictor_2
        };
        var box_predictor_3 = {
            box_encoding_predictor: box_encoding_3_predictor,
            class_predictor: class_predictor_3
        };
        var box_predictor_4 = {
            box_encoding_predictor: box_encoding_4_predictor,
            class_predictor: class_predictor_4
        };
        var box_predictor_5 = {
            box_encoding_predictor: box_encoding_5_predictor,
            class_predictor: class_predictor_5
        };
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            box_predictor_0: box_predictor_0,
            box_predictor_1: box_predictor_1,
            box_predictor_2: box_predictor_2,
            box_predictor_3: box_predictor_3,
            box_predictor_4: box_predictor_4,
            box_predictor_5: box_predictor_5
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParams(weights) {
    var paramMappings = [];
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractMobilenetV1Params = _b.extractMobilenetV1Params, extractPredictionLayerParams = _b.extractPredictionLayerParams;
    var mobilenetv1 = extractMobilenetV1Params();
    var prediction_layer = extractPredictionLayerParams();
    var extra_dim = _tfjsCore.tensor3d(extractWeights(20472), [
        1,
        5118,
        4
    ]);
    var output_layer = {
        extra_dim: extra_dim
    };
    paramMappings.push({
        paramPath: 'output_layer/extra_dim'
    });
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        params: {
            mobilenetv1: mobilenetv1,
            prediction_layer: prediction_layer,
            output_layer: output_layer
        },
        paramMappings: paramMappings
    };
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7pTSh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _common = require("../common");
var _utils = require("../utils");
function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    function extractPointwiseConvParams(prefix, idx, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/weights", 4, mappedPrefix + "/filters");
        var batch_norm_offset = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/convolution_bn_offset", 1, mappedPrefix + "/batch_norm_offset");
        return {
            filters: filters,
            batch_norm_offset: batch_norm_offset
        };
    }
    function extractConvPairParams(idx) {
        var mappedPrefix = "mobilenetv1/conv_" + idx;
        var prefixDepthwiseConv = "MobilenetV1/Conv2d_" + idx + "_depthwise";
        var mappedPrefixDepthwiseConv = mappedPrefix + "/depthwise_conv";
        var mappedPrefixPointwiseConv = mappedPrefix + "/pointwise_conv";
        var filters = extractWeightEntry(prefixDepthwiseConv + "/depthwise_weights", 4, mappedPrefixDepthwiseConv + "/filters");
        var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/gamma", 1, mappedPrefixDepthwiseConv + "/batch_norm_scale");
        var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/beta", 1, mappedPrefixDepthwiseConv + "/batch_norm_offset");
        var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_mean", 1, mappedPrefixDepthwiseConv + "/batch_norm_mean");
        var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_variance", 1, mappedPrefixDepthwiseConv + "/batch_norm_variance");
        return {
            depthwise_conv: {
                filters: filters,
                batch_norm_scale: batch_norm_scale,
                batch_norm_offset: batch_norm_offset,
                batch_norm_mean: batch_norm_mean,
                batch_norm_variance: batch_norm_variance
            },
            pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)
        };
    }
    function extractMobilenetV1Params() {
        return {
            conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),
            conv_1: extractConvPairParams(1),
            conv_2: extractConvPairParams(2),
            conv_3: extractConvPairParams(3),
            conv_4: extractConvPairParams(4),
            conv_5: extractConvPairParams(5),
            conv_6: extractConvPairParams(6),
            conv_7: extractConvPairParams(7),
            conv_8: extractConvPairParams(8),
            conv_9: extractConvPairParams(9),
            conv_10: extractConvPairParams(10),
            conv_11: extractConvPairParams(11),
            conv_12: extractConvPairParams(12),
            conv_13: extractConvPairParams(13)
        };
    }
    function extractConvParams(prefix, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, mappedPrefix + "/filters");
        var bias = extractWeightEntry(prefix + "/biases", 1, mappedPrefix + "/bias");
        return {
            filters: filters,
            bias: bias
        };
    }
    function extractBoxPredictorParams(idx) {
        var box_encoding_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + idx + "/box_encoding_predictor");
        var class_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/ClassPredictor", "prediction_layer/box_predictor_" + idx + "/class_predictor");
        return {
            box_encoding_predictor: box_encoding_predictor,
            class_predictor: class_predictor
        };
    }
    function extractPredictionLayerParams() {
        return {
            conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),
            conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),
            conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),
            conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),
            conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),
            conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),
            conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),
            conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),
            box_predictor_0: extractBoxPredictorParams(0),
            box_predictor_1: extractBoxPredictorParams(1),
            box_predictor_2: extractBoxPredictorParams(2),
            box_predictor_3: extractBoxPredictorParams(3),
            box_predictor_4: extractBoxPredictorParams(4),
            box_predictor_5: extractBoxPredictorParams(5)
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractMobilenetV1Params = _a.extractMobilenetV1Params, extractPredictionLayerParams = _a.extractPredictionLayerParams;
    var extra_dim = weightMap['Output/extra_dim'];
    paramMappings.push({
        originalPath: 'Output/extra_dim',
        paramPath: 'output_layer/extra_dim'
    });
    if (!_utils.isTensor3D(extra_dim)) throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + extra_dim);
    var params = {
        mobilenetv1: extractMobilenetV1Params(),
        prediction_layer: extractPredictionLayerParams(),
        output_layer: {
            extra_dim: extra_dim
        }
    };
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common":"iFr5j","../utils":"1iSuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5djaY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mobileNetV1", ()=>mobileNetV1
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _pointwiseConvLayer = require("./pointwiseConvLayer");
var epsilon = 0.0010000000474974513;
function depthwiseConvLayer(x, params, strides) {
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.depthwiseConv2d(x, params.filters, strides, 'same');
        out = _tfjsCore.batchNorm(out, params.batch_norm_mean, params.batch_norm_variance, params.batch_norm_offset, params.batch_norm_scale, epsilon);
        return _tfjsCore.clipByValue(out, 0, 6);
    });
}
function getStridesForLayerIdx(layerIdx) {
    return [
        2,
        4,
        6,
        12
    ].some(function(idx) {
        return idx === layerIdx;
    }) ? [
        2,
        2
    ] : [
        1,
        1
    ];
}
function mobileNetV1(x, params) {
    return _tfjsCore.tidy(function() {
        var conv11 = null;
        var out = _pointwiseConvLayer.pointwiseConvLayer(x, params.conv_0, [
            2,
            2
        ]);
        var convPairParams = [
            params.conv_1,
            params.conv_2,
            params.conv_3,
            params.conv_4,
            params.conv_5,
            params.conv_6,
            params.conv_7,
            params.conv_8,
            params.conv_9,
            params.conv_10,
            params.conv_11,
            params.conv_12,
            params.conv_13
        ];
        convPairParams.forEach(function(param, i) {
            var layerIdx = i + 1;
            var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);
            out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);
            out = _pointwiseConvLayer.pointwiseConvLayer(out, param.pointwise_conv, [
                1,
                1
            ]);
            if (layerIdx === 11) conv11 = out;
        });
        if (conv11 === null) throw new Error('mobileNetV1 - output of conv layer 11 is null');
        return {
            out: out,
            conv11: conv11
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","./pointwiseConvLayer":"63gXH","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"63gXH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pointwiseConvLayer", ()=>pointwiseConvLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function pointwiseConvLayer(x, params, strides) {
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.conv2d(x, params.filters, strides, 'same');
        out = _tfjsCore.add(out, params.batch_norm_offset);
        return _tfjsCore.clipByValue(out, 0, 6);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1wEG7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nonMaxSuppression", ()=>nonMaxSuppression
);
function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    var numBoxes = boxes.shape[0];
    var outputSize = Math.min(maxOutputSize, numBoxes);
    var candidates = scores.map(function(score, boxIndex) {
        return {
            score: score,
            boxIndex: boxIndex
        };
    }).filter(function(c) {
        return c.score > scoreThreshold;
    }).sort(function(c1, c2) {
        return c2.score - c1.score;
    });
    var suppressFunc = function(x) {
        return x <= iouThreshold ? 1 : 0;
    };
    var selected = [];
    candidates.forEach(function(c) {
        if (selected.length >= outputSize) return;
        var originalScore = c.score;
        for(var j = selected.length - 1; j >= 0; --j){
            var iou = IOU(boxes, c.boxIndex, selected[j]);
            if (iou === 0) continue;
            c.score *= suppressFunc(iou);
            if (c.score <= scoreThreshold) break;
        }
        if (originalScore === c.score) selected.push(c.boxIndex);
    });
    return selected;
}
function IOU(boxes, i, j) {
    var boxesData = boxes.arraySync();
    var yminI = Math.min(boxesData[i][0], boxesData[i][2]);
    var xminI = Math.min(boxesData[i][1], boxesData[i][3]);
    var ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);
    var xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);
    var yminJ = Math.min(boxesData[j][0], boxesData[j][2]);
    var xminJ = Math.min(boxesData[j][1], boxesData[j][3]);
    var ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);
    var xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);
    var areaI = (ymaxI - yminI) * (xmaxI - xminI);
    var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) return 0;
    var intersectionYmin = Math.max(yminI, yminJ);
    var intersectionXmin = Math.max(xminI, xminJ);
    var intersectionYmax = Math.min(ymaxI, ymaxJ);
    var intersectionXmax = Math.min(xmaxI, xmaxJ);
    var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6udEQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "outputLayer", ()=>outputLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function getCenterCoordinatesAndSizesLayer(x) {
    var vec = _tfjsCore.unstack(_tfjsCore.transpose(x, [
        1,
        0
    ]));
    var sizes = [
        _tfjsCore.sub(vec[2], vec[0]),
        _tfjsCore.sub(vec[3], vec[1])
    ];
    var centers = [
        _tfjsCore.add(vec[0], _tfjsCore.div(sizes[0], _tfjsCore.scalar(2))),
        _tfjsCore.add(vec[1], _tfjsCore.div(sizes[1], _tfjsCore.scalar(2)))
    ];
    return {
        sizes: sizes,
        centers: centers
    };
}
function decodeBoxesLayer(x0, x1) {
    var _a = getCenterCoordinatesAndSizesLayer(x0), sizes = _a.sizes, centers = _a.centers;
    var vec = _tfjsCore.unstack(_tfjsCore.transpose(x1, [
        1,
        0
    ]));
    var div0_out = _tfjsCore.div(_tfjsCore.mul(_tfjsCore.exp(_tfjsCore.div(vec[2], _tfjsCore.scalar(5))), sizes[0]), _tfjsCore.scalar(2));
    var add0_out = _tfjsCore.add(_tfjsCore.mul(_tfjsCore.div(vec[0], _tfjsCore.scalar(10)), sizes[0]), centers[0]);
    var div1_out = _tfjsCore.div(_tfjsCore.mul(_tfjsCore.exp(_tfjsCore.div(vec[3], _tfjsCore.scalar(5))), sizes[1]), _tfjsCore.scalar(2));
    var add1_out = _tfjsCore.add(_tfjsCore.mul(_tfjsCore.div(vec[1], _tfjsCore.scalar(10)), sizes[1]), centers[1]);
    return _tfjsCore.transpose(_tfjsCore.stack([
        _tfjsCore.sub(add0_out, div0_out),
        _tfjsCore.sub(add1_out, div1_out),
        _tfjsCore.add(add0_out, div0_out),
        _tfjsCore.add(add1_out, div1_out)
    ]), [
        1,
        0
    ]);
}
function outputLayer(boxPredictions, classPredictions, params) {
    return _tfjsCore.tidy(function() {
        var batchSize = boxPredictions.shape[0];
        var boxes = decodeBoxesLayer(_tfjsCore.reshape(_tfjsCore.tile(params.extra_dim, [
            batchSize,
            1,
            1
        ]), [
            -1,
            4
        ]), _tfjsCore.reshape(boxPredictions, [
            -1,
            4
        ]));
        boxes = _tfjsCore.reshape(boxes, [
            batchSize,
            boxes.shape[0] / batchSize,
            4
        ]);
        var scoresAndClasses = _tfjsCore.sigmoid(_tfjsCore.slice(classPredictions, [
            0,
            0,
            1
        ], [
            -1,
            -1,
            -1
        ]));
        var scores = _tfjsCore.slice(scoresAndClasses, [
            0,
            0,
            0
        ], [
            -1,
            -1,
            1
        ]);
        scores = _tfjsCore.reshape(scores, [
            batchSize,
            scores.shape[1]
        ]);
        var boxesByBatch = _tfjsCore.unstack(boxes);
        var scoresByBatch = _tfjsCore.unstack(scores);
        return {
            boxes: boxesByBatch,
            scores: scoresByBatch
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"83hwU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "predictionLayer", ()=>predictionLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _boxPredictionLayer = require("./boxPredictionLayer");
var _pointwiseConvLayer = require("./pointwiseConvLayer");
function predictionLayer(x, conv11, params) {
    return _tfjsCore.tidy(function() {
        var conv0 = _pointwiseConvLayer.pointwiseConvLayer(x, params.conv_0, [
            1,
            1
        ]);
        var conv1 = _pointwiseConvLayer.pointwiseConvLayer(conv0, params.conv_1, [
            2,
            2
        ]);
        var conv2 = _pointwiseConvLayer.pointwiseConvLayer(conv1, params.conv_2, [
            1,
            1
        ]);
        var conv3 = _pointwiseConvLayer.pointwiseConvLayer(conv2, params.conv_3, [
            2,
            2
        ]);
        var conv4 = _pointwiseConvLayer.pointwiseConvLayer(conv3, params.conv_4, [
            1,
            1
        ]);
        var conv5 = _pointwiseConvLayer.pointwiseConvLayer(conv4, params.conv_5, [
            2,
            2
        ]);
        var conv6 = _pointwiseConvLayer.pointwiseConvLayer(conv5, params.conv_6, [
            1,
            1
        ]);
        var conv7 = _pointwiseConvLayer.pointwiseConvLayer(conv6, params.conv_7, [
            2,
            2
        ]);
        var boxPrediction0 = _boxPredictionLayer.boxPredictionLayer(conv11, params.box_predictor_0);
        var boxPrediction1 = _boxPredictionLayer.boxPredictionLayer(x, params.box_predictor_1);
        var boxPrediction2 = _boxPredictionLayer.boxPredictionLayer(conv1, params.box_predictor_2);
        var boxPrediction3 = _boxPredictionLayer.boxPredictionLayer(conv3, params.box_predictor_3);
        var boxPrediction4 = _boxPredictionLayer.boxPredictionLayer(conv5, params.box_predictor_4);
        var boxPrediction5 = _boxPredictionLayer.boxPredictionLayer(conv7, params.box_predictor_5);
        var boxPredictions = _tfjsCore.concat([
            boxPrediction0.boxPredictionEncoding,
            boxPrediction1.boxPredictionEncoding,
            boxPrediction2.boxPredictionEncoding,
            boxPrediction3.boxPredictionEncoding,
            boxPrediction4.boxPredictionEncoding,
            boxPrediction5.boxPredictionEncoding
        ], 1);
        var classPredictions = _tfjsCore.concat([
            boxPrediction0.classPrediction,
            boxPrediction1.classPrediction,
            boxPrediction2.classPrediction,
            boxPrediction3.classPrediction,
            boxPrediction4.classPrediction,
            boxPrediction5.classPrediction
        ], 1);
        return {
            boxPredictions: boxPredictions,
            classPredictions: classPredictions
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","./boxPredictionLayer":"bXllr","./pointwiseConvLayer":"63gXH","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bXllr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "boxPredictionLayer", ()=>boxPredictionLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
function boxPredictionLayer(x, params) {
    return _tfjsCore.tidy(function() {
        var batchSize = x.shape[0];
        var boxPredictionEncoding = _tfjsCore.reshape(_common.convLayer(x, params.box_encoding_predictor), [
            batchSize,
            -1,
            1,
            4
        ]);
        var classPrediction = _tfjsCore.reshape(_common.convLayer(x, params.class_predictor), [
            batchSize,
            -1,
            3
        ]);
        return {
            boxPredictionEncoding: boxPredictionEncoding,
            classPrediction: classPrediction
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ch8ze":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SsdMobilenetv1Options", ()=>SsdMobilenetv1Options
);
var SsdMobilenetv1Options = function() {
    function SsdMobilenetv1Options1(_a) {
        var _b = _a === void 0 ? {
        } : _a, minConfidence = _b.minConfidence, maxResults = _b.maxResults;
        this._name = 'SsdMobilenetv1Options';
        this._minConfidence = minConfidence || 0.5;
        this._maxResults = maxResults || 100;
        if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
        if (typeof this._maxResults !== 'number') throw new Error(this._name + " - expected maxResults to be a number");
    }
    Object.defineProperty(SsdMobilenetv1Options1.prototype, "minConfidence", {
        get: function() {
            return this._minConfidence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SsdMobilenetv1Options1.prototype, "maxResults", {
        get: function() {
            return this._maxResults;
        },
        enumerable: true,
        configurable: true
    });
    return SsdMobilenetv1Options1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3qveU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyYolov2", ()=>_tinyYolov2.TinyYolov2
);
parcelHelpers.export(exports, "createTinyYolov2", ()=>createTinyYolov2
);
var _tinyYolov2 = require("./TinyYolov2");
var _tinyYolov2Options = require("./TinyYolov2Options");
parcelHelpers.exportAll(_tinyYolov2Options, exports);
var _config = require("./config");
parcelHelpers.exportAll(_config, exports);
function createTinyYolov2(weights, withSeparableConvs) {
    if (withSeparableConvs === void 0) withSeparableConvs = true;
    var net = new _tinyYolov2.TinyYolov2(withSeparableConvs);
    net.extractWeights(weights);
    return net;
}

},{"./TinyYolov2":"lK2Vh","./TinyYolov2Options":"9ji9a","./config":"aLpEn","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lK2Vh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyYolov2", ()=>TinyYolov21
);
var _tslib = require("tslib");
var _classes = require("../classes");
var _const = require("./const");
var _tinyYolov2Base = require("./TinyYolov2Base");
var TinyYolov21 = function(_super) {
    _tslib.__extends(TinyYolov22, _super);
    function TinyYolov22(withSeparableConvs) {
        if (withSeparableConvs === void 0) withSeparableConvs = true;
        var _this = this;
        var config = Object.assign({
        }, {
            withSeparableConvs: withSeparableConvs,
            iouThreshold: _const.IOU_THRESHOLD,
            classes: [
                'face'
            ]
        }, withSeparableConvs ? {
            anchors: _const.BOX_ANCHORS_SEPARABLE,
            meanRgb: _const.MEAN_RGB_SEPARABLE
        } : {
            anchors: _const.BOX_ANCHORS,
            withClassScores: true
        });
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyYolov22.prototype, "withSeparableConvs", {
        get: function() {
            return this.config.withSeparableConvs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov22.prototype, "anchors", {
        get: function() {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov22.prototype.locateFaces = function(input, forwardParams) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var objectDetections;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.detect(input, forwardParams)
                        ];
                    case 1:
                        objectDetections = _a.sent();
                        return [
                            2 /*return*/ ,
                            objectDetections.map(function(det) {
                                return new _classes.FaceDetection(det.score, det.relativeBox, {
                                    width: det.imageWidth,
                                    height: det.imageHeight
                                });
                            })
                        ];
                }
            });
        });
    };
    TinyYolov22.prototype.getDefaultModelName = function() {
        return this.withSeparableConvs ? _const.DEFAULT_MODEL_NAME_SEPARABLE_CONV : _const.DEFAULT_MODEL_NAME;
    };
    TinyYolov22.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyYolov22;
}(_tinyYolov2Base.TinyYolov2Base);

},{"tslib":"bjkXk","../classes":"6Yf93","./const":"8AVJd","./TinyYolov2Base":"8TvEA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8AVJd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IOU_THRESHOLD", ()=>IOU_THRESHOLD
);
parcelHelpers.export(exports, "BOX_ANCHORS", ()=>BOX_ANCHORS
);
parcelHelpers.export(exports, "BOX_ANCHORS_SEPARABLE", ()=>BOX_ANCHORS_SEPARABLE
);
parcelHelpers.export(exports, "MEAN_RGB_SEPARABLE", ()=>MEAN_RGB_SEPARABLE
);
parcelHelpers.export(exports, "DEFAULT_MODEL_NAME", ()=>DEFAULT_MODEL_NAME
);
parcelHelpers.export(exports, "DEFAULT_MODEL_NAME_SEPARABLE_CONV", ()=>DEFAULT_MODEL_NAME_SEPARABLE_CONV
);
var _classes = require("../classes");
var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes.Point(0.738768, 0.874946),
    new _classes.Point(2.42204, 2.65704),
    new _classes.Point(4.30971, 7.04493),
    new _classes.Point(10.246, 4.59428),
    new _classes.Point(12.6868, 11.8741)
];
var BOX_ANCHORS_SEPARABLE = [
    new _classes.Point(1.603231, 2.094468),
    new _classes.Point(6.041143, 7.080126),
    new _classes.Point(2.882459, 3.518061),
    new _classes.Point(4.266906, 5.178857),
    new _classes.Point(9.041765, 10.66308)
];
var MEAN_RGB_SEPARABLE = [
    117.001,
    114.697,
    97.404
];
var DEFAULT_MODEL_NAME = 'tiny_yolov2_model';
var DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';

},{"../classes":"6Yf93","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8TvEA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyYolov2Base", ()=>TinyYolov2Base1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _boundingBox = require("../classes/BoundingBox");
var _objectDetection = require("../classes/ObjectDetection");
var _common = require("../common");
var _dom = require("../dom");
var _neuralNetwork = require("../NeuralNetwork");
var _ops = require("../ops");
var _nonMaxSuppression = require("../ops/nonMaxSuppression");
var _normalize = require("../ops/normalize");
var _config = require("./config");
var _convWithBatchNorm = require("./convWithBatchNorm");
var _depthwiseSeparableConv = require("./depthwiseSeparableConv");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _leaky = require("./leaky");
var _tinyYolov2Options = require("./TinyYolov2Options");
var TinyYolov2Base1 = function(_super) {
    _tslib.__extends(TinyYolov2Base2, _super);
    function TinyYolov2Base2(config) {
        var _this = _super.call(this, 'TinyYolov2') || this;
        _config.validateConfig(config);
        _this._config = config;
        return _this;
    }
    Object.defineProperty(TinyYolov2Base2.prototype, "config", {
        get: function() {
            return this._config;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base2.prototype, "withClassScores", {
        get: function() {
            return this.config.withClassScores || this.config.classes.length > 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base2.prototype, "boxEncodingSize", {
        get: function() {
            return 5 + (this.withClassScores ? this.config.classes.length : 0);
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov2Base2.prototype.runTinyYolov2 = function(x, params) {
        var out = _convWithBatchNorm.convWithBatchNorm(x, params.conv0);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv1);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv2);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv3);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv4);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv5);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            1,
            1
        ], 'same');
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv6);
        out = _convWithBatchNorm.convWithBatchNorm(out, params.conv7);
        return _common.convLayer(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base2.prototype.runMobilenet = function(x, params) {
        var out = this.config.isFirstLayerConv2d ? _leaky.leaky(_common.convLayer(x, params.conv0, 'valid', false)) : _depthwiseSeparableConv.depthwiseSeparableConv(x, params.conv0);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv1);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv2);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv3);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv4);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv5);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            1,
            1
        ], 'same');
        out = params.conv6 ? _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv6) : out;
        out = params.conv7 ? _depthwiseSeparableConv.depthwiseSeparableConv(out, params.conv7) : out;
        return _common.convLayer(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base2.prototype.forwardInput = function(input, inputSize) {
        var _this = this;
        var params = this.params;
        if (!params) throw new Error('TinyYolov2 - load model before inference');
        return _tfjsCore.tidy(function() {
            var batchTensor = input.toBatchTensor(inputSize, false).toFloat();
            batchTensor = _this.config.meanRgb ? _normalize.normalize(batchTensor, _this.config.meanRgb) : batchTensor;
            batchTensor = batchTensor.div(_tfjsCore.scalar(256));
            return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);
        });
    };
    TinyYolov2Base2.prototype.forward = function(input, inputSize) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            4 /*yield*/ ,
                            _a.apply(this, [
                                _b.sent(),
                                inputSize
                            ])
                        ];
                    case 2:
                        return [
                            2 /*return*/ ,
                            _b.sent()
                        ];
                }
            });
        });
    };
    TinyYolov2Base2.prototype.detect = function(input, forwardParams) {
        if (forwardParams === void 0) forwardParams = {
        };
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;
            var _this = this;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = new _tinyYolov2Options.TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        netInput = _b.sent();
                        return [
                            4 /*yield*/ ,
                            this.forwardInput(netInput, inputSize)
                        ];
                    case 2:
                        out = _b.sent();
                        out0 = _tfjsCore.tidy(function() {
                            return _tfjsCore.unstack(out)[0].expandDims();
                        });
                        inputDimensions = {
                            width: netInput.getInputWidth(0),
                            height: netInput.getInputHeight(0)
                        };
                        return [
                            4 /*yield*/ ,
                            this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)
                        ];
                    case 3:
                        results = _b.sent();
                        out.dispose();
                        out0.dispose();
                        boxes = results.map(function(res) {
                            return res.box;
                        });
                        scores = results.map(function(res) {
                            return res.score;
                        });
                        classScores = results.map(function(res) {
                            return res.classScore;
                        });
                        classNames = results.map(function(res) {
                            return _this.config.classes[res.label];
                        });
                        indices = _nonMaxSuppression.nonMaxSuppression(boxes.map(function(box) {
                            return box.rescale(inputSize);
                        }), scores, this.config.iouThreshold, true);
                        detections = indices.map(function(idx) {
                            return new _objectDetection.ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);
                        });
                        return [
                            2 /*return*/ ,
                            detections
                        ];
                }
            });
        });
    };
    TinyYolov2Base2.prototype.getDefaultModelName = function() {
        return '';
    };
    TinyYolov2Base2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap, this.config);
    };
    TinyYolov2Base2.prototype.extractParams = function(weights) {
        var filterSizes = this.config.filterSizes || TinyYolov2Base2.DEFAULT_FILTER_SIZES;
        var numFilters = filterSizes ? filterSizes.length : undefined;
        if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + numFilters + " filterSizes in config");
        return _extractParams.extractParams(weights, this.config, this.boxEncodingSize, filterSizes);
    };
    TinyYolov2Base2.prototype.extractBoxes = function(outputTensor, inputBlobDimensions, scoreThreshold) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;
            var _this = this;
            return _tslib.__generator(this, function(_d) {
                switch(_d.label){
                    case 0:
                        width = inputBlobDimensions.width, height = inputBlobDimensions.height;
                        inputSize = Math.max(width, height);
                        correctionFactorX = inputSize / width;
                        correctionFactorY = inputSize / height;
                        numCells = outputTensor.shape[1];
                        numBoxes = this.config.anchors.length;
                        _a = _tfjsCore.tidy(function() {
                            var reshaped = outputTensor.reshape([
                                numCells,
                                numCells,
                                numBoxes,
                                _this.boxEncodingSize
                            ]);
                            var boxes = reshaped.slice([
                                0,
                                0,
                                0,
                                0
                            ], [
                                numCells,
                                numCells,
                                numBoxes,
                                4
                            ]);
                            var scores = reshaped.slice([
                                0,
                                0,
                                0,
                                4
                            ], [
                                numCells,
                                numCells,
                                numBoxes,
                                1
                            ]);
                            var classScores = _this.withClassScores ? _tfjsCore.softmax(reshaped.slice([
                                0,
                                0,
                                0,
                                5
                            ], [
                                numCells,
                                numCells,
                                numBoxes,
                                _this.config.classes.length
                            ]), 3) : _tfjsCore.scalar(0);
                            return [
                                boxes,
                                scores,
                                classScores
                            ];
                        }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];
                        results = [];
                        return [
                            4 /*yield*/ ,
                            scoresTensor.array()
                        ];
                    case 1:
                        scoresData = _d.sent();
                        return [
                            4 /*yield*/ ,
                            boxesTensor.array()
                        ];
                    case 2:
                        boxesData = _d.sent();
                        row = 0;
                        _d.label = 3;
                    case 3:
                        if (!(row < numCells)) return [
                            3 /*break*/ ,
                            12
                        ];
                        col = 0;
                        _d.label = 4;
                    case 4:
                        if (!(col < numCells)) return [
                            3 /*break*/ ,
                            11
                        ];
                        anchor = 0;
                        _d.label = 5;
                    case 5:
                        if (!(anchor < numBoxes)) return [
                            3 /*break*/ ,
                            10
                        ];
                        score = _ops.sigmoid(scoresData[row][col][anchor][0]);
                        if (!(!scoreThreshold || score > scoreThreshold)) return [
                            3 /*break*/ ,
                            9
                        ];
                        ctX = (col + _ops.sigmoid(boxesData[row][col][anchor][0])) / numCells * correctionFactorX;
                        ctY = (row + _ops.sigmoid(boxesData[row][col][anchor][1])) / numCells * correctionFactorY;
                        width_1 = Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x / numCells * correctionFactorX;
                        height_1 = Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y / numCells * correctionFactorY;
                        x = ctX - width_1 / 2;
                        y = ctY - height_1 / 2;
                        pos = {
                            row: row,
                            col: col,
                            anchor: anchor
                        };
                        if (!this.withClassScores) return [
                            3 /*break*/ ,
                            7
                        ];
                        return [
                            4 /*yield*/ ,
                            this.extractPredictedClass(classScoresTensor, pos)
                        ];
                    case 6:
                        _c = _d.sent();
                        return [
                            3 /*break*/ ,
                            8
                        ];
                    case 7:
                        _c = {
                            classScore: 1,
                            label: 0
                        };
                        _d.label = 8;
                    case 8:
                        _b = _c, classScore = _b.classScore, label = _b.label;
                        results.push(_tslib.__assign({
                            box: new _boundingBox.BoundingBox(x, y, x + width_1, y + height_1),
                            score: score,
                            classScore: score * classScore,
                            label: label
                        }, pos));
                        _d.label = 9;
                    case 9:
                        anchor++;
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 10:
                        col++;
                        return [
                            3 /*break*/ ,
                            4
                        ];
                    case 11:
                        row++;
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 12:
                        boxesTensor.dispose();
                        scoresTensor.dispose();
                        classScoresTensor.dispose();
                        return [
                            2 /*return*/ ,
                            results
                        ];
                }
            });
        });
    };
    TinyYolov2Base2.prototype.extractPredictedClass = function(classesTensor, pos) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var row, col, anchor, classesData;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        row = pos.row, col = pos.col, anchor = pos.anchor;
                        return [
                            4 /*yield*/ ,
                            classesTensor.array()
                        ];
                    case 1:
                        classesData = _a.sent();
                        return [
                            2 /*return*/ ,
                            Array(this.config.classes.length).fill(0).map(function(_, i) {
                                return classesData[row][col][anchor][i];
                            }).map(function(classScore, label) {
                                return {
                                    classScore: classScore,
                                    label: label
                                };
                            }).reduce(function(max, curr) {
                                return max.classScore > curr.classScore ? max : curr;
                            })
                        ];
                }
            });
        });
    };
    TinyYolov2Base2.DEFAULT_FILTER_SIZES = [
        3,
        16,
        32,
        64,
        128,
        256,
        512,
        1024,
        1024
    ];
    return TinyYolov2Base2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes/BoundingBox":"kCX5I","../classes/ObjectDetection":"fGpww","../common":"iFr5j","../dom":"eQw1p","../NeuralNetwork":"lrDwN","../ops":"cSYle","../ops/nonMaxSuppression":"eCKOv","../ops/normalize":"jTWUd","./config":"aLpEn","./convWithBatchNorm":"j7lwH","./depthwiseSeparableConv":"61p4p","./extractParams":"feI9i","./extractParamsFromWeigthMap":"jdN89","./leaky":"cJUjf","./TinyYolov2Options":"9ji9a","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aLpEn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateConfig", ()=>validateConfig
);
var isNumber = function(arg) {
    return typeof arg === 'number';
};
function validateConfig(config) {
    if (!config) throw new Error("invalid config: " + config);
    if (typeof config.withSeparableConvs !== 'boolean') throw new Error("config.withSeparableConvs has to be a boolean, have: " + config.withSeparableConvs);
    if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1) throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + config.iouThreshold);
    if (!Array.isArray(config.classes) || !config.classes.length || !config.classes.every(function(c) {
        return typeof c === 'string';
    })) throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(config.classes));
    if (!Array.isArray(config.anchors) || !config.anchors.length || !config.anchors.map(function(a) {
        return a || {
        };
    }).every(function(a) {
        return isNumber(a.x) && isNumber(a.y);
    })) throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(config.anchors));
    if (config.meanRgb && (!Array.isArray(config.meanRgb) || config.meanRgb.length !== 3 || !config.meanRgb.every(isNumber))) throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(config.meanRgb));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j7lwH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convWithBatchNorm", ()=>convWithBatchNorm
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _leaky = require("./leaky");
function convWithBatchNorm(x, params) {
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.pad(x, [
            [
                0,
                0
            ],
            [
                1,
                1
            ],
            [
                1,
                1
            ],
            [
                0,
                0
            ]
        ]);
        out = _tfjsCore.conv2d(out, params.conv.filters, [
            1,
            1
        ], 'valid');
        out = _tfjsCore.sub(out, params.bn.sub);
        out = _tfjsCore.mul(out, params.bn.truediv);
        out = _tfjsCore.add(out, params.conv.bias);
        return _leaky.leaky(out);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","./leaky":"cJUjf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cJUjf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "leaky", ()=>leaky
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function leaky(x) {
    return _tfjsCore.tidy(function() {
        var min = _tfjsCore.mul(x, _tfjsCore.scalar(0.10000000149011612));
        return _tfjsCore.add(_tfjsCore.relu(_tfjsCore.sub(x, min)), min);
    //return tf.maximum(x, min)
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"61p4p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "depthwiseSeparableConv", ()=>depthwiseSeparableConv
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _leaky = require("./leaky");
function depthwiseSeparableConv(x, params) {
    return _tfjsCore.tidy(function() {
        var out = _tfjsCore.pad(x, [
            [
                0,
                0
            ],
            [
                1,
                1
            ],
            [
                1,
                1
            ],
            [
                0,
                0
            ]
        ]);
        out = _tfjsCore.separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [
            1,
            1
        ], 'valid');
        out = _tfjsCore.add(out, params.bias);
        return _leaky.leaky(out);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","./leaky":"cJUjf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"feI9i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _extractSeparableConvParamsFactory = require("../common/extractSeparableConvParamsFactory");
var _extractWeightsFactory = require("../common/extractWeightsFactory");
function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = _common.extractConvParamsFactory(extractWeights, paramMappings);
    function extractBatchNormParams(size, mappedPrefix) {
        var sub = _tfjsCore.tensor1d(extractWeights(size));
        var truediv = _tfjsCore.tensor1d(extractWeights(size));
        paramMappings.push({
            paramPath: mappedPrefix + "/sub"
        }, {
            paramPath: mappedPrefix + "/truediv"
        });
        return {
            sub: sub,
            truediv: truediv
        };
    }
    function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {
        var conv = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv");
        var bn = extractBatchNormParams(channelsOut, mappedPrefix + "/bn");
        return {
            conv: conv,
            bn: bn
        };
    }
    var extractSeparableConvParams = _extractSeparableConvParamsFactory.extractSeparableConvParamsFactory(extractWeights, paramMappings);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParams(weights, config, boxEncodingSize, filterSizes) {
    var _a = _extractWeightsFactory.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams, extractSeparableConvParams = _b.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = config.isFirstLayerConv2d ? extractConvParams(s0, s1, 3, 'conv0') : extractSeparableConvParams(s0, s1, 'conv0');
        var conv1 = extractSeparableConvParams(s1, s2, 'conv1');
        var conv2 = extractSeparableConvParams(s2, s3, 'conv2');
        var conv3 = extractSeparableConvParams(s3, s4, 'conv3');
        var conv4 = extractSeparableConvParams(s4, s5, 'conv4');
        var conv5 = extractSeparableConvParams(s5, s6, 'conv5');
        var conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;
        var conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;
        var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');
        params = {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2,
            conv3: conv3,
            conv4: conv4,
            conv5: conv5,
            conv6: conv6,
            conv7: conv7,
            conv8: conv8
        };
    } else {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');
        var conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');
        var conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');
        var conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');
        var conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');
        var conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');
        var conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');
        var conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');
        var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');
        params = {
            conv0: conv0,
            conv1: conv1,
            conv2: conv2,
            conv3: conv3,
            conv4: conv4,
            conv5: conv5,
            conv6: conv6,
            conv7: conv7,
            conv8: conv8
        };
    }
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","../common/extractSeparableConvParamsFactory":"iqrvI","../common/extractWeightsFactory":"6cLIi","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jdN89":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _disposeUnusedWeightTensors = require("../common/disposeUnusedWeightTensors");
var _extractSeparableConvParamsFactory = require("../common/extractSeparableConvParamsFactory");
var _extractWeightEntryFactory = require("../common/extractWeightEntryFactory");
function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _extractWeightEntryFactory.extractWeightEntryFactory(weightMap, paramMappings);
    function extractBatchNormParams(prefix) {
        var sub = extractWeightEntry(prefix + "/sub", 1);
        var truediv = extractWeightEntry(prefix + "/truediv", 1);
        return {
            sub: sub,
            truediv: truediv
        };
    }
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            filters: filters,
            bias: bias
        };
    }
    function extractConvWithBatchNormParams(prefix) {
        var conv = extractConvParams(prefix + "/conv");
        var bn = extractBatchNormParams(prefix + "/bn");
        return {
            conv: conv,
            bn: bn
        };
    }
    var extractSeparableConvParams = _extractSeparableConvParamsFactory.loadSeparableConvParamsFactory(extractWeightEntry);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParamsFromWeigthMap(weightMap, config) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractConvWithBatchNormParams = _a.extractConvWithBatchNormParams, extractSeparableConvParams = _a.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var numFilters = config.filterSizes && config.filterSizes.length || 9;
        params = {
            conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),
            conv1: extractSeparableConvParams('conv1'),
            conv2: extractSeparableConvParams('conv2'),
            conv3: extractSeparableConvParams('conv3'),
            conv4: extractSeparableConvParams('conv4'),
            conv5: extractSeparableConvParams('conv5'),
            conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,
            conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,
            conv8: extractConvParams('conv8')
        };
    } else params = {
        conv0: extractConvWithBatchNormParams('conv0'),
        conv1: extractConvWithBatchNormParams('conv1'),
        conv2: extractConvWithBatchNormParams('conv2'),
        conv3: extractConvWithBatchNormParams('conv3'),
        conv4: extractConvWithBatchNormParams('conv4'),
        conv5: extractConvWithBatchNormParams('conv5'),
        conv6: extractConvWithBatchNormParams('conv6'),
        conv7: extractConvWithBatchNormParams('conv7'),
        conv8: extractConvParams('conv8')
    };
    _disposeUnusedWeightTensors.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: params,
        paramMappings: paramMappings
    };
}

},{"../common/disposeUnusedWeightTensors":"1Ca5I","../common/extractSeparableConvParamsFactory":"iqrvI","../common/extractWeightEntryFactory":"32aWV","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9ji9a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyYolov2SizeType", ()=>TinyYolov2SizeType
);
parcelHelpers.export(exports, "TinyYolov2Options", ()=>TinyYolov2Options
);
var TinyYolov2SizeType;
(function(TinyYolov2SizeType1) {
    TinyYolov2SizeType1[TinyYolov2SizeType1["XS"] = 224] = "XS";
    TinyYolov2SizeType1[TinyYolov2SizeType1["SM"] = 320] = "SM";
    TinyYolov2SizeType1[TinyYolov2SizeType1["MD"] = 416] = "MD";
    TinyYolov2SizeType1[TinyYolov2SizeType1["LG"] = 608] = "LG";
})(TinyYolov2SizeType || (TinyYolov2SizeType = {
}));
var TinyYolov2Options = function() {
    function TinyYolov2Options1(_a) {
        var _b = _a === void 0 ? {
        } : _a, inputSize = _b.inputSize, scoreThreshold = _b.scoreThreshold;
        this._name = 'TinyYolov2Options';
        this._inputSize = inputSize || 416;
        this._scoreThreshold = scoreThreshold || 0.5;
        if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
        if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
    }
    Object.defineProperty(TinyYolov2Options1.prototype, "inputSize", {
        get: function() {
            return this._inputSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Options1.prototype, "scoreThreshold", {
        get: function() {
            return this._scoreThreshold;
        },
        enumerable: true,
        configurable: true
    });
    return TinyYolov2Options1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9zIwW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "detectSingleFace", ()=>detectSingleFace
);
parcelHelpers.export(exports, "detectAllFaces", ()=>detectAllFaces
);
var _ssdMobilenetv1Options = require("../ssdMobilenetv1/SsdMobilenetv1Options");
var _detectFacesTasks = require("./DetectFacesTasks");
function detectSingleFace(input, options) {
    if (options === void 0) options = new _ssdMobilenetv1Options.SsdMobilenetv1Options();
    return new _detectFacesTasks.DetectSingleFaceTask(input, options);
}
function detectAllFaces(input, options) {
    if (options === void 0) options = new _ssdMobilenetv1Options.SsdMobilenetv1Options();
    return new _detectFacesTasks.DetectAllFacesTask(input, options);
}

},{"../ssdMobilenetv1/SsdMobilenetv1Options":"ch8ze","./DetectFacesTasks":"eRvJA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eRvJA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DetectFacesTaskBase", ()=>DetectFacesTaskBase1
);
parcelHelpers.export(exports, "DetectAllFacesTask", ()=>DetectAllFacesTask1
);
parcelHelpers.export(exports, "DetectSingleFaceTask", ()=>DetectSingleFaceTask1
);
var _tslib = require("tslib");
var _withFaceDetection = require("../factories/WithFaceDetection");
var _mtcnnOptions = require("../mtcnn/MtcnnOptions");
var _ssdMobilenetv1Options = require("../ssdMobilenetv1/SsdMobilenetv1Options");
var _tinyFaceDetectorOptions = require("../tinyFaceDetector/TinyFaceDetectorOptions");
var _tinyYolov2 = require("../tinyYolov2");
var _composableTask = require("./ComposableTask");
var _detectFaceLandmarksTasks = require("./DetectFaceLandmarksTasks");
var _nets = require("./nets");
var _predictAgeAndGenderTask = require("./PredictAgeAndGenderTask");
var _predictFaceExpressionsTask = require("./PredictFaceExpressionsTask");
var DetectFacesTaskBase1 = function(_super) {
    _tslib.__extends(DetectFacesTaskBase2, _super);
    function DetectFacesTaskBase2(input, options) {
        if (options === void 0) options = new _ssdMobilenetv1Options.SsdMobilenetv1Options();
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.options = options;
        return _this;
    }
    return DetectFacesTaskBase2;
}(_composableTask.ComposableTask);
var DetectAllFacesTask1 = function(_super) {
    _tslib.__extends(DetectAllFacesTask2, _super);
    function DetectAllFacesTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFacesTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a, input, options, faceDetectionFunction;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this, input = _a.input, options = _a.options;
                        if (!(options instanceof _mtcnnOptions.MtcnnOptions)) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            _nets.nets.mtcnn.forward(input, options)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _b.sent().map(function(result) {
                                return result.detection;
                            })
                        ];
                    case 2:
                        faceDetectionFunction = options instanceof _tinyFaceDetectorOptions.TinyFaceDetectorOptions ? function(input1) {
                            return _nets.nets.tinyFaceDetector.locateFaces(input1, options);
                        } : options instanceof _ssdMobilenetv1Options.SsdMobilenetv1Options ? function(input1) {
                            return _nets.nets.ssdMobilenetv1.locateFaces(input1, options);
                        } : options instanceof _tinyYolov2.TinyYolov2Options ? function(input1) {
                            return _nets.nets.tinyYolov2.locateFaces(input1, options);
                        } : null;
                        if (!faceDetectionFunction) throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');
                        return [
                            2 /*return*/ ,
                            faceDetectionFunction(input)
                        ];
                }
            });
        });
    };
    DetectAllFacesTask2.prototype.runAndExtendWithFaceDetections = function() {
        var _this = this;
        return new Promise(function(res) {
            return _tslib.__awaiter(_this, void 0, void 0, function() {
                var detections;
                return _tslib.__generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            return [
                                4 /*yield*/ ,
                                this.run()
                            ];
                        case 1:
                            detections = _a.sent();
                            return [
                                2 /*return*/ ,
                                res(detections.map(function(detection) {
                                    return _withFaceDetection.extendWithFaceDetection({
                                    }, detection);
                                }))
                            ];
                    }
                });
            });
        });
    };
    DetectAllFacesTask2.prototype.withFaceLandmarks = function(useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) useTinyLandmarkNet = false;
        return new _detectFaceLandmarksTasks.DetectAllFaceLandmarksTask(this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);
    };
    DetectAllFacesTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictAllFaceExpressionsTask(this.runAndExtendWithFaceDetections(), this.input);
    };
    DetectAllFacesTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictAllAgeAndGenderTask(this.runAndExtendWithFaceDetections(), this.input);
    };
    return DetectAllFacesTask2;
}(DetectFacesTaskBase1);
var DetectSingleFaceTask1 = function(_super) {
    _tslib.__extends(DetectSingleFaceTask2, _super);
    function DetectSingleFaceTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var faceDetections, faceDetectionWithHighestScore;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            new DetectAllFacesTask1(this.input, this.options)
                        ];
                    case 1:
                        faceDetections = _a.sent();
                        faceDetectionWithHighestScore = faceDetections[0];
                        faceDetections.forEach(function(faceDetection) {
                            if (faceDetection.score > faceDetectionWithHighestScore.score) faceDetectionWithHighestScore = faceDetection;
                        });
                        return [
                            2 /*return*/ ,
                            faceDetectionWithHighestScore
                        ];
                }
            });
        });
    };
    DetectSingleFaceTask2.prototype.runAndExtendWithFaceDetection = function() {
        var _this = this;
        return new Promise(function(res) {
            return _tslib.__awaiter(_this, void 0, void 0, function() {
                var detection;
                return _tslib.__generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            return [
                                4 /*yield*/ ,
                                this.run()
                            ];
                        case 1:
                            detection = _a.sent();
                            return [
                                2 /*return*/ ,
                                res(detection ? _withFaceDetection.extendWithFaceDetection({
                                }, detection) : undefined)
                            ];
                    }
                });
            });
        });
    };
    DetectSingleFaceTask2.prototype.withFaceLandmarks = function(useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) useTinyLandmarkNet = false;
        return new _detectFaceLandmarksTasks.DetectSingleFaceLandmarksTask(this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);
    };
    DetectSingleFaceTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictSingleFaceExpressionsTask(this.runAndExtendWithFaceDetection(), this.input);
    };
    DetectSingleFaceTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictSingleAgeAndGenderTask(this.runAndExtendWithFaceDetection(), this.input);
    };
    return DetectSingleFaceTask2;
}(DetectFacesTaskBase1);

},{"tslib":"bjkXk","../factories/WithFaceDetection":"bFfpU","../mtcnn/MtcnnOptions":"wQQ5R","../ssdMobilenetv1/SsdMobilenetv1Options":"ch8ze","../tinyFaceDetector/TinyFaceDetectorOptions":"2HlQx","../tinyYolov2":"3qveU","./ComposableTask":"fBnBt","./DetectFaceLandmarksTasks":"h8WTa","./nets":"7WlCP","./PredictAgeAndGenderTask":"j1bsJ","./PredictFaceExpressionsTask":"iUlxW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2HlQx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyFaceDetectorOptions", ()=>TinyFaceDetectorOptions1
);
var _tslib = require("tslib");
var _tinyYolov2 = require("../tinyYolov2");
var TinyFaceDetectorOptions1 = function(_super) {
    _tslib.__extends(TinyFaceDetectorOptions2, _super);
    function TinyFaceDetectorOptions2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._name = 'TinyFaceDetectorOptions';
        return _this;
    }
    return TinyFaceDetectorOptions2;
}(_tinyYolov2.TinyYolov2Options);

},{"tslib":"bjkXk","../tinyYolov2":"3qveU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fBnBt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ComposableTask", ()=>ComposableTask
);
var _tslib = require("tslib");
var ComposableTask = function() {
    function ComposableTask1() {
    }
    ComposableTask1.prototype.then = function(onfulfilled) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = onfulfilled;
                        return [
                            4 /*yield*/ ,
                            this.run()
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(void 0, [
                                _b.sent()
                            ])
                        ];
                }
            });
        });
    };
    ComposableTask1.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            return _tslib.__generator(this, function(_a) {
                throw new Error('ComposableTask - run is not implemented');
            });
        });
    };
    return ComposableTask1;
}();

},{"tslib":"bjkXk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"h8WTa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DetectFaceLandmarksTaskBase", ()=>DetectFaceLandmarksTaskBase1
);
parcelHelpers.export(exports, "DetectAllFaceLandmarksTask", ()=>DetectAllFaceLandmarksTask1
);
parcelHelpers.export(exports, "DetectSingleFaceLandmarksTask", ()=>DetectSingleFaceLandmarksTask1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _withFaceLandmarks = require("../factories/WithFaceLandmarks");
var _composableTask = require("./ComposableTask");
var _computeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");
var _nets = require("./nets");
var _predictAgeAndGenderTask = require("./PredictAgeAndGenderTask");
var _predictFaceExpressionsTask = require("./PredictFaceExpressionsTask");
var DetectFaceLandmarksTaskBase1 = function(_super) {
    _tslib.__extends(DetectFaceLandmarksTaskBase2, _super);
    function DetectFaceLandmarksTaskBase2(parentTask, input, useTinyLandmarkNet) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.useTinyLandmarkNet = useTinyLandmarkNet;
        return _this;
    }
    Object.defineProperty(DetectFaceLandmarksTaskBase2.prototype, "landmarkNet", {
        get: function() {
            return this.useTinyLandmarkNet ? _nets.nets.faceLandmark68TinyNet : _nets.nets.faceLandmark68Net;
        },
        enumerable: true,
        configurable: true
    });
    return DetectFaceLandmarksTaskBase2;
}(_composableTask.ComposableTask);
var DetectAllFaceLandmarksTask1 = function(_super) {
    _tslib.__extends(DetectAllFaceLandmarksTask2, _super);
    function DetectAllFaceLandmarksTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFaceLandmarksTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResults, detections, faces, _a, faceLandmarksByFace;
            var _this = this;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResults = _b.sent();
                        detections = parentResults.map(function(res) {
                            return res.detection;
                        });
                        if (!(this.input instanceof _tfjsCore.Tensor)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            _dom.extractFaceTensors(this.input, detections)
                        ];
                    case 2:
                        _a = _b.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 3:
                        return [
                            4 /*yield*/ ,
                            _dom.extractFaces(this.input, detections)
                        ];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [
                            4 /*yield*/ ,
                            Promise.all(faces.map(function(face) {
                                return _this.landmarkNet.detectLandmarks(face);
                            }))
                        ];
                    case 6:
                        faceLandmarksByFace = _b.sent();
                        faces.forEach(function(f) {
                            return f instanceof _tfjsCore.Tensor && f.dispose();
                        });
                        return [
                            2 /*return*/ ,
                            parentResults.map(function(parentResult, i) {
                                return _withFaceLandmarks.extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i]);
                            })
                        ];
                }
            });
        });
    };
    DetectAllFaceLandmarksTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    DetectAllFaceLandmarksTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    DetectAllFaceLandmarksTask2.prototype.withFaceDescriptors = function() {
        return new _computeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
    };
    return DetectAllFaceLandmarksTask2;
}(DetectFaceLandmarksTaskBase1);
var DetectSingleFaceLandmarksTask1 = function(_super) {
    _tslib.__extends(DetectSingleFaceLandmarksTask2, _super);
    function DetectSingleFaceLandmarksTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceLandmarksTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResult, detection, faces, _a, landmarks;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) return [
                            2 /*return*/ 
                        ];
                        detection = parentResult.detection;
                        if (!(this.input instanceof _tfjsCore.Tensor)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            _dom.extractFaceTensors(this.input, [
                                detection
                            ])
                        ];
                    case 2:
                        _a = _b.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 3:
                        return [
                            4 /*yield*/ ,
                            _dom.extractFaces(this.input, [
                                detection
                            ])
                        ];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [
                            4 /*yield*/ ,
                            this.landmarkNet.detectLandmarks(faces[0])
                        ];
                    case 6:
                        landmarks = _b.sent();
                        faces.forEach(function(f) {
                            return f instanceof _tfjsCore.Tensor && f.dispose();
                        });
                        return [
                            2 /*return*/ ,
                            _withFaceLandmarks.extendWithFaceLandmarks(parentResult, landmarks)
                        ];
                }
            });
        });
    };
    DetectSingleFaceLandmarksTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    DetectSingleFaceLandmarksTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    DetectSingleFaceLandmarksTask2.prototype.withFaceDescriptor = function() {
        return new _computeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
    };
    return DetectSingleFaceLandmarksTask2;
}(DetectFaceLandmarksTaskBase1);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../factories/WithFaceLandmarks":"136nl","./ComposableTask":"fBnBt","./ComputeFaceDescriptorsTasks":"3I4nd","./nets":"7WlCP","./PredictAgeAndGenderTask":"j1bsJ","./PredictFaceExpressionsTask":"iUlxW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3I4nd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ComputeFaceDescriptorsTaskBase", ()=>ComputeFaceDescriptorsTaskBase1
);
parcelHelpers.export(exports, "ComputeAllFaceDescriptorsTask", ()=>ComputeAllFaceDescriptorsTask1
);
parcelHelpers.export(exports, "ComputeSingleFaceDescriptorTask", ()=>ComputeSingleFaceDescriptorTask1
);
var _tslib = require("tslib");
var _withFaceDescriptor = require("../factories/WithFaceDescriptor");
var _composableTask = require("./ComposableTask");
var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");
var _nets = require("./nets");
var _predictAgeAndGenderTask = require("./PredictAgeAndGenderTask");
var _predictFaceExpressionsTask = require("./PredictFaceExpressionsTask");
var ComputeFaceDescriptorsTaskBase1 = function(_super) {
    _tslib.__extends(ComputeFaceDescriptorsTaskBase2, _super);
    function ComputeFaceDescriptorsTaskBase2(parentTask, input) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        return _this;
    }
    return ComputeFaceDescriptorsTaskBase2;
}(_composableTask.ComposableTask);
var ComputeAllFaceDescriptorsTask1 = function(_super) {
    _tslib.__extends(ComputeAllFaceDescriptorsTask2, _super);
    function ComputeAllFaceDescriptorsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeAllFaceDescriptorsTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResults, descriptors;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResults = _a.sent();
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                                return Promise.all(faces.map(function(face) {
                                    return _nets.nets.faceRecognitionNet.computeFaceDescriptor(face);
                                }));
                            }, null, function(parentResult) {
                                return parentResult.landmarks.align(null, {
                                    useDlibAlignment: true
                                });
                            })
                        ];
                    case 2:
                        descriptors = _a.sent();
                        return [
                            2 /*return*/ ,
                            descriptors.map(function(descriptor, i) {
                                return _withFaceDescriptor.extendWithFaceDescriptor(parentResults[i], descriptor);
                            })
                        ];
                }
            });
        });
    };
    ComputeAllFaceDescriptorsTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    ComputeAllFaceDescriptorsTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    return ComputeAllFaceDescriptorsTask2;
}(ComputeFaceDescriptorsTaskBase1);
var ComputeSingleFaceDescriptorTask1 = function(_super) {
    _tslib.__extends(ComputeSingleFaceDescriptorTask2, _super);
    function ComputeSingleFaceDescriptorTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeSingleFaceDescriptorTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResult, descriptor;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) return [
                            2 /*return*/ 
                        ];
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                                return _nets.nets.faceRecognitionNet.computeFaceDescriptor(face);
                            }, null, function(parentResult1) {
                                return parentResult1.landmarks.align(null, {
                                    useDlibAlignment: true
                                });
                            })
                        ];
                    case 2:
                        descriptor = _a.sent();
                        return [
                            2 /*return*/ ,
                            _withFaceDescriptor.extendWithFaceDescriptor(parentResult, descriptor)
                        ];
                }
            });
        });
    };
    ComputeSingleFaceDescriptorTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    ComputeSingleFaceDescriptorTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    return ComputeSingleFaceDescriptorTask2;
}(ComputeFaceDescriptorsTaskBase1);

},{"tslib":"bjkXk","../factories/WithFaceDescriptor":"1TZn6","./ComposableTask":"fBnBt","./extractFacesAndComputeResults":"3JU0N","./nets":"7WlCP","./PredictAgeAndGenderTask":"j1bsJ","./PredictFaceExpressionsTask":"iUlxW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3JU0N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractAllFacesAndComputeResults", ()=>extractAllFacesAndComputeResults
);
parcelHelpers.export(exports, "extractSingleFaceAndComputeResult", ()=>extractSingleFaceAndComputeResult
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _withFaceLandmarks = require("../factories/WithFaceLandmarks");
function extractAllFacesAndComputeResults(parentResults, input, computeResults, extractedFaces, getRectForAlignment) {
    if (getRectForAlignment === void 0) getRectForAlignment = function(_a) {
        var alignedRect = _a.alignedRect;
        return alignedRect;
    };
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var faceBoxes, faces, _a, _b, results;
        return _tslib.__generator(this, function(_c) {
            switch(_c.label){
                case 0:
                    faceBoxes = parentResults.map(function(parentResult) {
                        return _withFaceLandmarks.isWithFaceLandmarks(parentResult) ? getRectForAlignment(parentResult) : parentResult.detection;
                    });
                    _a = extractedFaces;
                    if (_a) return [
                        3 /*break*/ ,
                        5
                    ];
                    if (!(input instanceof _tfjsCore.Tensor)) return [
                        3 /*break*/ ,
                        2
                    ];
                    return [
                        4 /*yield*/ ,
                        _dom.extractFaceTensors(input, faceBoxes)
                    ];
                case 1:
                    _b = _c.sent();
                    return [
                        3 /*break*/ ,
                        4
                    ];
                case 2:
                    return [
                        4 /*yield*/ ,
                        _dom.extractFaces(input, faceBoxes)
                    ];
                case 3:
                    _b = _c.sent();
                    _c.label = 4;
                case 4:
                    _a = _b;
                    _c.label = 5;
                case 5:
                    faces = _a;
                    return [
                        4 /*yield*/ ,
                        computeResults(faces)
                    ];
                case 6:
                    results = _c.sent();
                    faces.forEach(function(f) {
                        return f instanceof _tfjsCore.Tensor && f.dispose();
                    });
                    return [
                        2 /*return*/ ,
                        results
                    ];
            }
        });
    });
}
function extractSingleFaceAndComputeResult(parentResult, input, computeResult, extractedFaces, getRectForAlignment) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return _tslib.__generator(this, function(_a) {
            return [
                2 /*return*/ ,
                extractAllFacesAndComputeResults([
                    parentResult
                ], input, function(faces) {
                    return _tslib.__awaiter(_this, void 0, void 0, function() {
                        return _tslib.__generator(this, function(_a1) {
                            return [
                                2 /*return*/ ,
                                computeResult(faces[0])
                            ];
                        });
                    });
                }, extractedFaces, getRectForAlignment)
            ];
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../factories/WithFaceLandmarks":"136nl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7WlCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nets", ()=>nets
);
parcelHelpers.export(exports, "ssdMobilenetv1", ()=>ssdMobilenetv1
);
parcelHelpers.export(exports, "tinyFaceDetector", ()=>tinyFaceDetector
);
parcelHelpers.export(exports, "tinyYolov2", ()=>tinyYolov2
);
parcelHelpers.export(exports, "mtcnn", ()=>mtcnn
);
parcelHelpers.export(exports, "detectFaceLandmarks", ()=>detectFaceLandmarks
);
parcelHelpers.export(exports, "detectFaceLandmarksTiny", ()=>detectFaceLandmarksTiny
);
parcelHelpers.export(exports, "computeFaceDescriptor", ()=>computeFaceDescriptor
);
parcelHelpers.export(exports, "recognizeFaceExpressions", ()=>recognizeFaceExpressions
);
parcelHelpers.export(exports, "predictAgeAndGender", ()=>predictAgeAndGender
);
parcelHelpers.export(exports, "loadSsdMobilenetv1Model", ()=>loadSsdMobilenetv1Model
);
parcelHelpers.export(exports, "loadTinyFaceDetectorModel", ()=>loadTinyFaceDetectorModel
);
parcelHelpers.export(exports, "loadMtcnnModel", ()=>loadMtcnnModel
);
parcelHelpers.export(exports, "loadTinyYolov2Model", ()=>loadTinyYolov2Model
);
parcelHelpers.export(exports, "loadFaceLandmarkModel", ()=>loadFaceLandmarkModel
);
parcelHelpers.export(exports, "loadFaceLandmarkTinyModel", ()=>loadFaceLandmarkTinyModel
);
parcelHelpers.export(exports, "loadFaceRecognitionModel", ()=>loadFaceRecognitionModel
);
parcelHelpers.export(exports, "loadFaceExpressionModel", ()=>loadFaceExpressionModel
);
parcelHelpers.export(exports, "loadAgeGenderModel", ()=>loadAgeGenderModel
);
parcelHelpers.export(exports, "loadFaceDetectionModel", ()=>loadFaceDetectionModel
);
parcelHelpers.export(exports, "locateFaces", ()=>locateFaces
);
parcelHelpers.export(exports, "detectLandmarks", ()=>detectLandmarks
);
var _ageGenderNet = require("../ageGenderNet/AgeGenderNet");
var _faceExpressionNet = require("../faceExpressionNet/FaceExpressionNet");
var _faceLandmark68Net = require("../faceLandmarkNet/FaceLandmark68Net");
var _faceLandmark68TinyNet = require("../faceLandmarkNet/FaceLandmark68TinyNet");
var _faceRecognitionNet = require("../faceRecognitionNet/FaceRecognitionNet");
var _mtcnn = require("../mtcnn/Mtcnn");
var _ssdMobilenetv1 = require("../ssdMobilenetv1/SsdMobilenetv1");
var _tinyFaceDetector = require("../tinyFaceDetector/TinyFaceDetector");
var _tinyYolov2 = require("../tinyYolov2");
var nets = {
    ssdMobilenetv1: new _ssdMobilenetv1.SsdMobilenetv1(),
    tinyFaceDetector: new _tinyFaceDetector.TinyFaceDetector(),
    tinyYolov2: new _tinyYolov2.TinyYolov2(),
    mtcnn: new _mtcnn.Mtcnn(),
    faceLandmark68Net: new _faceLandmark68Net.FaceLandmark68Net(),
    faceLandmark68TinyNet: new _faceLandmark68TinyNet.FaceLandmark68TinyNet(),
    faceRecognitionNet: new _faceRecognitionNet.FaceRecognitionNet(),
    faceExpressionNet: new _faceExpressionNet.FaceExpressionNet(),
    ageGenderNet: new _ageGenderNet.AgeGenderNet()
};
var ssdMobilenetv1 = function(input, options) {
    return nets.ssdMobilenetv1.locateFaces(input, options);
};
var tinyFaceDetector = function(input, options) {
    return nets.tinyFaceDetector.locateFaces(input, options);
};
var tinyYolov2 = function(input, options) {
    return nets.tinyYolov2.locateFaces(input, options);
};
var mtcnn = function(input, options) {
    return nets.mtcnn.forward(input, options);
};
var detectFaceLandmarks = function(input) {
    return nets.faceLandmark68Net.detectLandmarks(input);
};
var detectFaceLandmarksTiny = function(input) {
    return nets.faceLandmark68TinyNet.detectLandmarks(input);
};
var computeFaceDescriptor = function(input) {
    return nets.faceRecognitionNet.computeFaceDescriptor(input);
};
var recognizeFaceExpressions = function(input) {
    return nets.faceExpressionNet.predictExpressions(input);
};
var predictAgeAndGender = function(input) {
    return nets.ageGenderNet.predictAgeAndGender(input);
};
var loadSsdMobilenetv1Model = function(url) {
    return nets.ssdMobilenetv1.load(url);
};
var loadTinyFaceDetectorModel = function(url) {
    return nets.tinyFaceDetector.load(url);
};
var loadMtcnnModel = function(url) {
    return nets.mtcnn.load(url);
};
var loadTinyYolov2Model = function(url) {
    return nets.tinyYolov2.load(url);
};
var loadFaceLandmarkModel = function(url) {
    return nets.faceLandmark68Net.load(url);
};
var loadFaceLandmarkTinyModel = function(url) {
    return nets.faceLandmark68TinyNet.load(url);
};
var loadFaceRecognitionModel = function(url) {
    return nets.faceRecognitionNet.load(url);
};
var loadFaceExpressionModel = function(url) {
    return nets.faceExpressionNet.load(url);
};
var loadAgeGenderModel = function(url) {
    return nets.ageGenderNet.load(url);
};
var loadFaceDetectionModel = loadSsdMobilenetv1Model;
var locateFaces = ssdMobilenetv1;
var detectLandmarks = detectFaceLandmarks;

},{"../ageGenderNet/AgeGenderNet":"kpblP","../faceExpressionNet/FaceExpressionNet":"10BVg","../faceLandmarkNet/FaceLandmark68Net":"wkF9f","../faceLandmarkNet/FaceLandmark68TinyNet":"dtdzn","../faceRecognitionNet/FaceRecognitionNet":"aOWlf","../mtcnn/Mtcnn":"kqFxm","../ssdMobilenetv1/SsdMobilenetv1":"dav1V","../tinyFaceDetector/TinyFaceDetector":"a1PV6","../tinyYolov2":"3qveU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kqFxm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Mtcnn", ()=>Mtcnn1
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _faceDetection = require("../classes/FaceDetection");
var _faceLandmarks5 = require("../classes/FaceLandmarks5");
var _dom = require("../dom");
var _factories = require("../factories");
var _neuralNetwork = require("../NeuralNetwork");
var _bgrToRgbTensor = require("./bgrToRgbTensor");
var _config = require("./config");
var _extractParams = require("./extractParams");
var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");
var _getSizesForScale = require("./getSizesForScale");
var _mtcnnOptions = require("./MtcnnOptions");
var _pyramidDown = require("./pyramidDown");
var _stage1 = require("./stage1");
var _stage2 = require("./stage2");
var _stage3 = require("./stage3");
var Mtcnn1 = function(_super) {
    _tslib.__extends(Mtcnn2, _super);
    function Mtcnn2() {
        return _super.call(this, 'Mtcnn') || this;
    }
    Mtcnn2.prototype.load = function(weightsOrUrl) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            return _tslib.__generator(this, function(_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [
                    2 /*return*/ ,
                    _super.prototype.load.call(this, weightsOrUrl)
                ];
            });
        });
    };
    Mtcnn2.prototype.loadFromDisk = function(filePath) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            return _tslib.__generator(this, function(_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [
                    2 /*return*/ ,
                    _super.prototype.loadFromDisk.call(this, filePath)
                ];
            });
        });
    };
    Mtcnn2.prototype.forwardInput = function(input, forwardParams) {
        if (forwardParams === void 0) forwardParams = {
        };
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;
            return _tslib.__generator(this, function(_c) {
                switch(_c.label){
                    case 0:
                        params = this.params;
                        if (!params) throw new Error('Mtcnn - load model before inference');
                        inputCanvas = input.canvases[0];
                        if (!inputCanvas) throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');
                        stats = {
                        };
                        tsTotal = Date.now();
                        imgTensor = _tfjsCore.tidy(function() {
                            return _bgrToRgbTensor.bgrToRgbTensor(_tfjsCore.expandDims(_tfjsCore.browser.fromPixels(inputCanvas)).toFloat());
                        });
                        onReturn = function(results1) {
                            // dispose tensors on return
                            imgTensor.dispose();
                            stats.total = Date.now() - tsTotal;
                            return results1;
                        };
                        _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
                        _b = new _mtcnnOptions.MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
                        scales = (scaleSteps || _pyramidDown.pyramidDown(minFaceSize, scaleFactor, [
                            height,
                            width
                        ])).filter(function(scale) {
                            var sizes = _getSizesForScale.getSizesForScale(scale, [
                                height,
                                width
                            ]);
                            return Math.min(sizes.width, sizes.height) > _config.CELL_SIZE;
                        }).slice(0, maxNumScales);
                        stats.scales = scales;
                        stats.pyramid = scales.map(function(scale) {
                            return _getSizesForScale.getSizesForScale(scale, [
                                height,
                                width
                            ]);
                        });
                        ts = Date.now();
                        return [
                            4 /*yield*/ ,
                            _stage1.stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)
                        ];
                    case 1:
                        out1 = _c.sent();
                        stats.total_stage1 = Date.now() - ts;
                        if (!out1.boxes.length) return [
                            2 /*return*/ ,
                            onReturn({
                                results: [],
                                stats: stats
                            })
                        ];
                        stats.stage2_numInputBoxes = out1.boxes.length;
                        // using the inputCanvas to extract and resize the image patches, since it is faster
                        // than doing this on the gpu
                        ts = Date.now();
                        return [
                            4 /*yield*/ ,
                            _stage2.stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)
                        ];
                    case 2:
                        out2 = _c.sent();
                        stats.total_stage2 = Date.now() - ts;
                        if (!out2.boxes.length) return [
                            2 /*return*/ ,
                            onReturn({
                                results: [],
                                stats: stats
                            })
                        ];
                        stats.stage3_numInputBoxes = out2.boxes.length;
                        ts = Date.now();
                        return [
                            4 /*yield*/ ,
                            _stage3.stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)
                        ];
                    case 3:
                        out3 = _c.sent();
                        stats.total_stage3 = Date.now() - ts;
                        results = out3.boxes.map(function(box, idx) {
                            return _factories.extendWithFaceLandmarks(_factories.extendWithFaceDetection({
                            }, new _faceDetection.FaceDetection(out3.scores[idx], new _classes.Rect(box.left / width, box.top / height, box.width / width, box.height / height), {
                                height: height,
                                width: width
                            })), new _faceLandmarks5.FaceLandmarks5(out3.points[idx].map(function(pt) {
                                return pt.sub(new _classes.Point(box.left, box.top)).div(new _classes.Point(box.width, box.height));
                            }), {
                                width: box.width,
                                height: box.height
                            }));
                        });
                        return [
                            2 /*return*/ ,
                            onReturn({
                                results: results,
                                stats: stats
                            })
                        ];
                }
            });
        });
    };
    Mtcnn2.prototype.forward = function(input, forwardParams) {
        if (forwardParams === void 0) forwardParams = {
        };
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            4 /*yield*/ ,
                            _a.apply(this, [
                                _b.sent(),
                                forwardParams
                            ])
                        ];
                    case 2:
                        return [
                            2 /*return*/ ,
                            _b.sent().results
                        ];
                }
            });
        });
    };
    Mtcnn2.prototype.forwardWithStats = function(input, forwardParams) {
        if (forwardParams === void 0) forwardParams = {
        };
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var _a;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _a = this.forwardInput;
                        return [
                            4 /*yield*/ ,
                            _dom.toNetInput(input)
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.apply(this, [
                                _b.sent(),
                                forwardParams
                            ])
                        ];
                }
            });
        });
    };
    Mtcnn2.prototype.getDefaultModelName = function() {
        return 'mtcnn_model';
    };
    Mtcnn2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _extractParamsFromWeigthMap.extractParamsFromWeigthMap(weightMap);
    };
    Mtcnn2.prototype.extractParams = function(weights) {
        return _extractParams.extractParams(weights);
    };
    return Mtcnn2;
}(_neuralNetwork.NeuralNetwork);

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../classes/FaceDetection":"f78Si","../classes/FaceLandmarks5":"f4KYU","../dom":"eQw1p","../factories":"aAWYN","../NeuralNetwork":"lrDwN","./bgrToRgbTensor":"77hwS","./config":"eDnkv","./extractParams":"6NLCB","./extractParamsFromWeigthMap":"3PMG1","./getSizesForScale":"c8VNk","./MtcnnOptions":"wQQ5R","./pyramidDown":"25qY4","./stage1":"lg0PU","./stage2":"5F16W","./stage3":"14JQK","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"77hwS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bgrToRgbTensor", ()=>bgrToRgbTensor
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function bgrToRgbTensor(tensor) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.stack(_tfjsCore.unstack(tensor, 3).reverse(), 3);
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eDnkv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CELL_STRIDE", ()=>CELL_STRIDE
);
parcelHelpers.export(exports, "CELL_SIZE", ()=>CELL_SIZE
);
var CELL_STRIDE = 2;
var CELL_SIZE = 12;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6NLCB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParams", ()=>extractParams
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = _common.extractConvParamsFactory(extractWeights, paramMappings);
    var extractFCParams = _common.extractFCParamsFactory(extractWeights, paramMappings);
    function extractPReluParams(size, paramPath) {
        var alpha = _tfjsCore.tensor1d(extractWeights(size));
        paramMappings.push({
            paramPath: paramPath
        });
        return alpha;
    }
    function extractSharedParams(numFilters, mappedPrefix, isRnet) {
        if (isRnet === void 0) isRnet = false;
        var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + "/conv1");
        var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + "/prelu1_alpha");
        var conv2 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + "/conv2");
        var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + "/prelu2_alpha");
        var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + "/conv3");
        var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + "/prelu3_alpha");
        return {
            conv1: conv1,
            prelu1_alpha: prelu1_alpha,
            conv2: conv2,
            prelu2_alpha: prelu2_alpha,
            conv3: conv3,
            prelu3_alpha: prelu3_alpha
        };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams([
            3,
            10,
            16,
            32
        ], 'pnet');
        var conv4_1 = extractConvParams(32, 2, 1, 'pnet/conv4_1');
        var conv4_2 = extractConvParams(32, 4, 1, 'pnet/conv4_2');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            conv4_1: conv4_1,
            conv4_2: conv4_2
        });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams([
            3,
            28,
            48,
            64
        ], 'rnet', true);
        var fc1 = extractFCParams(576, 128, 'rnet/fc1');
        var prelu4_alpha = extractPReluParams(128, 'rnet/prelu4_alpha');
        var fc2_1 = extractFCParams(128, 2, 'rnet/fc2_1');
        var fc2_2 = extractFCParams(128, 4, 'rnet/fc2_2');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            fc1: fc1,
            prelu4_alpha: prelu4_alpha,
            fc2_1: fc2_1,
            fc2_2: fc2_2
        });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams([
            3,
            32,
            64,
            64
        ], 'onet');
        var conv4 = extractConvParams(64, 128, 2, 'onet/conv4');
        var prelu4_alpha = extractPReluParams(128, 'onet/prelu4_alpha');
        var fc1 = extractFCParams(1152, 256, 'onet/fc1');
        var prelu5_alpha = extractPReluParams(256, 'onet/prelu5_alpha');
        var fc2_1 = extractFCParams(256, 2, 'onet/fc2_1');
        var fc2_2 = extractFCParams(256, 4, 'onet/fc2_2');
        var fc2_3 = extractFCParams(256, 10, 'onet/fc2_3');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            conv4: conv4,
            prelu4_alpha: prelu4_alpha,
            fc1: fc1,
            prelu5_alpha: prelu5_alpha,
            fc2_1: fc2_1,
            fc2_2: fc2_2,
            fc2_3: fc2_3
        });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParams(weights) {
    var _a = _common.extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractPNetParams = _b.extractPNetParams, extractRNetParams = _b.extractRNetParams, extractONetParams = _b.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    if (getRemainingWeights().length !== 0) throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    return {
        params: {
            pnet: pnet,
            rnet: rnet,
            onet: onet
        },
        paramMappings: paramMappings
    };
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3PMG1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractParamsFromWeigthMap", ()=>extractParamsFromWeigthMap
);
var _tslib = require("tslib");
var _common = require("../common");
function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = _common.extractWeightEntryFactory(weightMap, paramMappings);
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, prefix + "/filters");
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            filters: filters,
            bias: bias
        };
    }
    function extractFCParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return {
            weights: weights,
            bias: bias
        };
    }
    function extractPReluParams(paramPath) {
        return extractWeightEntry(paramPath, 1);
    }
    function extractSharedParams(prefix) {
        var conv1 = extractConvParams(prefix + "/conv1");
        var prelu1_alpha = extractPReluParams(prefix + "/prelu1_alpha");
        var conv2 = extractConvParams(prefix + "/conv2");
        var prelu2_alpha = extractPReluParams(prefix + "/prelu2_alpha");
        var conv3 = extractConvParams(prefix + "/conv3");
        var prelu3_alpha = extractPReluParams(prefix + "/prelu3_alpha");
        return {
            conv1: conv1,
            prelu1_alpha: prelu1_alpha,
            conv2: conv2,
            prelu2_alpha: prelu2_alpha,
            conv3: conv3,
            prelu3_alpha: prelu3_alpha
        };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams('pnet');
        var conv4_1 = extractConvParams('pnet/conv4_1');
        var conv4_2 = extractConvParams('pnet/conv4_2');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            conv4_1: conv4_1,
            conv4_2: conv4_2
        });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams('rnet');
        var fc1 = extractFCParams('rnet/fc1');
        var prelu4_alpha = extractPReluParams('rnet/prelu4_alpha');
        var fc2_1 = extractFCParams('rnet/fc2_1');
        var fc2_2 = extractFCParams('rnet/fc2_2');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            fc1: fc1,
            prelu4_alpha: prelu4_alpha,
            fc2_1: fc2_1,
            fc2_2: fc2_2
        });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams('onet');
        var conv4 = extractConvParams('onet/conv4');
        var prelu4_alpha = extractPReluParams('onet/prelu4_alpha');
        var fc1 = extractFCParams('onet/fc1');
        var prelu5_alpha = extractPReluParams('onet/prelu5_alpha');
        var fc2_1 = extractFCParams('onet/fc2_1');
        var fc2_2 = extractFCParams('onet/fc2_2');
        var fc2_3 = extractFCParams('onet/fc2_3');
        return _tslib.__assign(_tslib.__assign({
        }, sharedParams), {
            conv4: conv4,
            prelu4_alpha: prelu4_alpha,
            fc1: fc1,
            prelu5_alpha: prelu5_alpha,
            fc2_1: fc2_1,
            fc2_2: fc2_2,
            fc2_3: fc2_3
        });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractPNetParams = _a.extractPNetParams, extractRNetParams = _a.extractRNetParams, extractONetParams = _a.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    _common.disposeUnusedWeightTensors(weightMap, paramMappings);
    return {
        params: {
            pnet: pnet,
            rnet: rnet,
            onet: onet
        },
        paramMappings: paramMappings
    };
}

},{"tslib":"bjkXk","../common":"iFr5j","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"c8VNk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSizesForScale", ()=>getSizesForScale
);
function getSizesForScale(scale, _a) {
    var height = _a[0], width = _a[1];
    return {
        height: Math.floor(height * scale),
        width: Math.floor(width * scale)
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"25qY4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pyramidDown", ()=>pyramidDown
);
var _config = require("./config");
function pyramidDown(minFaceSize, scaleFactor, dims) {
    var height = dims[0], width = dims[1];
    var m = _config.CELL_SIZE / minFaceSize;
    var scales = [];
    var minLayer = Math.min(height, width) * m;
    var exp = 0;
    while(minLayer >= 12){
        scales.push(m * Math.pow(scaleFactor, exp));
        minLayer = minLayer * scaleFactor;
        exp += 1;
    }
    return scales;
}

},{"./config":"eDnkv","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lg0PU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stage1", ()=>stage1
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _ops = require("../ops");
var _config = require("./config");
var _getSizesForScale = require("./getSizesForScale");
var _mtcnnBox = require("./MtcnnBox");
var _normalize = require("./normalize");
var _pnet = require("./PNet");
function rescaleAndNormalize(x, scale) {
    return _tfjsCore.tidy(function() {
        var _a = _getSizesForScale.getSizesForScale(scale, x.shape.slice(1)), height = _a.height, width = _a.width;
        var resized = _tfjsCore.image.resizeBilinear(x, [
            height,
            width
        ]);
        var normalized = _normalize.normalize(resized);
        return _tfjsCore.transpose(normalized, [
            0,
            2,
            1,
            3
        ]);
    });
}
function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {
    // TODO: fix this!, maybe better to use tf.gather here
    var indices = [];
    var scoresData = scoresTensor.arraySync();
    for(var y = 0; y < scoresTensor.shape[0]; y++){
        for(var x = 0; x < scoresTensor.shape[1]; x++)if (scoresData[y][x] >= scoreThreshold) indices.push(new _classes.Point(x, y));
    }
    var boundingBoxes = indices.map(function(idx) {
        var cell = new _classes.BoundingBox(Math.round((idx.y * _config.CELL_STRIDE + 1) / scale), Math.round((idx.x * _config.CELL_STRIDE + 1) / scale), Math.round((idx.y * _config.CELL_STRIDE + _config.CELL_SIZE) / scale), Math.round((idx.x * _config.CELL_STRIDE + _config.CELL_SIZE) / scale));
        var score = scoresData[idx.y][idx.x];
        var regionsData = regionsTensor.arraySync();
        var region = new _mtcnnBox.MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
        return {
            cell: cell,
            score: score,
            region: region
        };
    });
    return boundingBoxes;
}
function stage1(imgTensor, scales, scoreThreshold, params, stats) {
    stats.stage1 = [];
    var pnetOutputs = scales.map(function(scale) {
        return _tfjsCore.tidy(function() {
            var statsForScale = {
                scale: scale
            };
            var resized = rescaleAndNormalize(imgTensor, scale);
            var ts = Date.now();
            var _a = _pnet.PNet(resized, params), prob = _a.prob, regions = _a.regions;
            statsForScale.pnet = Date.now() - ts;
            var scoresTensor = _tfjsCore.unstack(_tfjsCore.unstack(prob, 3)[1])[0];
            var regionsTensor = _tfjsCore.unstack(regions)[0];
            return {
                scoresTensor: scoresTensor,
                regionsTensor: regionsTensor,
                scale: scale,
                statsForScale: statsForScale
            };
        });
    });
    var boxesForScale = pnetOutputs.map(function(_a) {
        var scoresTensor = _a.scoresTensor, regionsTensor = _a.regionsTensor, scale = _a.scale, statsForScale = _a.statsForScale;
        var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);
        scoresTensor.dispose();
        regionsTensor.dispose();
        if (!boundingBoxes.length) {
            stats.stage1.push(statsForScale);
            return [];
        }
        var ts = Date.now();
        var indices = _ops.nonMaxSuppression(boundingBoxes.map(function(bbox) {
            return bbox.cell;
        }), boundingBoxes.map(function(bbox) {
            return bbox.score;
        }), 0.5);
        statsForScale.nms = Date.now() - ts;
        statsForScale.numBoxes = indices.length;
        stats.stage1.push(statsForScale);
        return indices.map(function(boxIdx) {
            return boundingBoxes[boxIdx];
        });
    });
    var allBoxes = boxesForScale.reduce(function(all, boxes) {
        return all.concat(boxes);
    }, []);
    var finalBoxes = [];
    var finalScores = [];
    if (allBoxes.length > 0) {
        var ts = Date.now();
        var indices = _ops.nonMaxSuppression(allBoxes.map(function(bbox) {
            return bbox.cell;
        }), allBoxes.map(function(bbox) {
            return bbox.score;
        }), 0.7);
        stats.stage1_nms = Date.now() - ts;
        finalScores = indices.map(function(idx) {
            return allBoxes[idx].score;
        });
        finalBoxes = indices.map(function(idx) {
            return allBoxes[idx];
        }).map(function(_a) {
            var cell = _a.cell, region = _a.region;
            return new _classes.BoundingBox(cell.left + region.left * cell.width, cell.top + region.top * cell.height, cell.right + region.right * cell.width, cell.bottom + region.bottom * cell.height).toSquare().round();
        });
    }
    return {
        boxes: finalBoxes,
        scores: finalScores
    };
}

},{"@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../ops":"cSYle","./config":"eDnkv","./getSizesForScale":"c8VNk","./MtcnnBox":"jcna9","./normalize":"aPsZ7","./PNet":"esqyC","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jcna9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MtcnnBox", ()=>MtcnnBox1
);
var _tslib = require("tslib");
var _classes = require("../classes");
var MtcnnBox1 = function(_super) {
    _tslib.__extends(MtcnnBox2, _super);
    function MtcnnBox2(left, top, right, bottom) {
        return _super.call(this, {
            left: left,
            top: top,
            right: right,
            bottom: bottom
        }, true) || this;
    }
    return MtcnnBox2;
}(_classes.Box);

},{"tslib":"bjkXk","../classes":"6Yf93","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aPsZ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function normalize(x) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.mul(_tfjsCore.sub(x, _tfjsCore.scalar(127.5)), _tfjsCore.scalar(0.0078125));
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"esqyC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PNet", ()=>PNet
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _sharedLayers = require("./sharedLayers");
function PNet(x, params) {
    return _tfjsCore.tidy(function() {
        var out = _sharedLayers.sharedLayer(x, params, true);
        var conv = _common.convLayer(out, params.conv4_1, 'valid');
        var max = _tfjsCore.expandDims(_tfjsCore.max(conv, 3), 3);
        var prob = _tfjsCore.softmax(_tfjsCore.sub(conv, max), 3);
        var regions = _common.convLayer(out, params.conv4_2, 'valid');
        return {
            prob: prob,
            regions: regions
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","./sharedLayers":"cX8FA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cX8FA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sharedLayer", ()=>sharedLayer
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _prelu = require("./prelu");
function sharedLayer(x, params, isPnet) {
    if (isPnet === void 0) isPnet = false;
    return _tfjsCore.tidy(function() {
        var out = _common.convLayer(x, params.conv1, 'valid');
        out = _prelu.prelu(out, params.prelu1_alpha);
        out = _tfjsCore.maxPool(out, isPnet ? [
            2,
            2
        ] : [
            3,
            3
        ], [
            2,
            2
        ], 'same');
        out = _common.convLayer(out, params.conv2, 'valid');
        out = _prelu.prelu(out, params.prelu2_alpha);
        out = isPnet ? out : _tfjsCore.maxPool(out, [
            3,
            3
        ], [
            2,
            2
        ], 'valid');
        out = _common.convLayer(out, params.conv3, 'valid');
        out = _prelu.prelu(out, params.prelu3_alpha);
        return out;
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","./prelu":"lEavS","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lEavS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prelu", ()=>prelu
);
var _tfjsCore = require("@tensorflow/tfjs-core");
function prelu(x, alpha) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.add(_tfjsCore.relu(x), _tfjsCore.mul(alpha, _tfjsCore.neg(_tfjsCore.relu(_tfjsCore.neg(x)))));
    });
}

},{"@tensorflow/tfjs-core":"82lJf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5F16W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stage2", ()=>stage2
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _ops = require("../ops");
var _extractImagePatches = require("./extractImagePatches");
var _mtcnnBox = require("./MtcnnBox");
var _rnet = require("./RNet");
function stage2(img, inputBoxes, scoreThreshold, params, stats) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var ts, rnetInputs, rnetOuts, scoresTensor, scores, _a, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;
        return _tslib.__generator(this, function(_c) {
            switch(_c.label){
                case 0:
                    ts = Date.now();
                    return [
                        4 /*yield*/ ,
                        _extractImagePatches.extractImagePatches(img, inputBoxes, {
                            width: 24,
                            height: 24
                        })
                    ];
                case 1:
                    rnetInputs = _c.sent();
                    stats.stage2_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    rnetOuts = rnetInputs.map(function(rnetInput) {
                        var out = _rnet.RNet(rnetInput, params);
                        rnetInput.dispose();
                        return out;
                    });
                    stats.stage2_rnet = Date.now() - ts;
                    scoresTensor = rnetOuts.length > 1 ? _tfjsCore.concat(rnetOuts.map(function(out) {
                        return out.scores;
                    })) : rnetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [
                        4 /*yield*/ ,
                        scoresTensor.data()
                    ];
                case 2:
                    scores = _b.apply(_a, [
                        _c.sent()
                    ]);
                    scoresTensor.dispose();
                    indices = scores.map(function(score, idx) {
                        return {
                            score: score,
                            idx: idx
                        };
                    }).filter(function(c) {
                        return c.score > scoreThreshold;
                    }).map(function(_a1) {
                        var idx = _a1.idx;
                        return idx;
                    });
                    filteredBoxes = indices.map(function(idx) {
                        return inputBoxes[idx];
                    });
                    filteredScores = indices.map(function(idx) {
                        return scores[idx];
                    });
                    finalBoxes = [];
                    finalScores = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = _ops.nonMaxSuppression(filteredBoxes, filteredScores, 0.7);
                        stats.stage2_nms = Date.now() - ts;
                        regions_1 = indicesNms.map(function(idx) {
                            var regionsData = rnetOuts[indices[idx]].regions.arraySync();
                            return new _mtcnnBox.MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                        });
                        finalScores = indicesNms.map(function(idx) {
                            return filteredScores[idx];
                        });
                        finalBoxes = indicesNms.map(function(idx, i) {
                            return filteredBoxes[idx].calibrate(regions_1[i]);
                        });
                    }
                    rnetOuts.forEach(function(t) {
                        t.regions.dispose();
                        t.scores.dispose();
                    });
                    return [
                        2 /*return*/ ,
                        {
                            boxes: finalBoxes,
                            scores: finalScores
                        }
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../ops":"cSYle","./extractImagePatches":"hrf2y","./MtcnnBox":"jcna9","./RNet":"3RtvQ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hrf2y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractImagePatches", ()=>extractImagePatches
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _dom = require("../dom");
var _env = require("../env");
var _normalize = require("./normalize");
function extractImagePatches(img, boxes, _a) {
    var width = _a.width, height = _a.height;
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var imgCtx, bitmaps, imagePatchesDatas;
        var _this = this;
        return _tslib.__generator(this, function(_b) {
            switch(_b.label){
                case 0:
                    imgCtx = _dom.getContext2dOrThrow(img);
                    return [
                        4 /*yield*/ ,
                        Promise.all(boxes.map(function(box) {
                            return _tslib.__awaiter(_this, void 0, void 0, function() {
                                var _a1, y, ey, x, ex, fromX, fromY, imgData;
                                return _tslib.__generator(this, function(_b1) {
                                    _a1 = box.padAtBorders(img.height, img.width), y = _a1.y, ey = _a1.ey, x = _a1.x, ex = _a1.ex;
                                    fromX = x - 1;
                                    fromY = y - 1;
                                    imgData = imgCtx.getImageData(fromX, fromY, ex - fromX, ey - fromY);
                                    return [
                                        2 /*return*/ ,
                                        _env.env.isNodejs() ? _dom.createCanvasFromMedia(imgData) : createImageBitmap(imgData)
                                    ];
                                });
                            });
                        }))
                    ];
                case 1:
                    bitmaps = _b.sent();
                    imagePatchesDatas = [];
                    bitmaps.forEach(function(bmp) {
                        var patch = _dom.createCanvas({
                            width: width,
                            height: height
                        });
                        var patchCtx = _dom.getContext2dOrThrow(patch);
                        patchCtx.drawImage(bmp, 0, 0, width, height);
                        var data = patchCtx.getImageData(0, 0, width, height).data;
                        var currData = [];
                        // RGBA -> BGR
                        for(var i = 0; i < data.length; i += 4){
                            currData.push(data[i + 2]);
                            currData.push(data[i + 1]);
                            currData.push(data[i]);
                        }
                        imagePatchesDatas.push(currData);
                    });
                    return [
                        2 /*return*/ ,
                        imagePatchesDatas.map(function(data) {
                            var t = _tfjsCore.tidy(function() {
                                var imagePatchTensor = _tfjsCore.transpose(_tfjsCore.tensor4d(data, [
                                    1,
                                    width,
                                    height,
                                    3
                                ]), [
                                    0,
                                    2,
                                    1,
                                    3
                                ]).toFloat();
                                return _normalize.normalize(imagePatchTensor);
                            });
                            return t;
                        })
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../dom":"eQw1p","../env":"aqpPn","./normalize":"aPsZ7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3RtvQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RNet", ()=>RNet
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _fullyConnectedLayer = require("../common/fullyConnectedLayer");
var _prelu = require("./prelu");
var _sharedLayers = require("./sharedLayers");
function RNet(x, params) {
    return _tfjsCore.tidy(function() {
        var convOut = _sharedLayers.sharedLayer(x, params);
        var vectorized = _tfjsCore.reshape(convOut, [
            convOut.shape[0],
            params.fc1.weights.shape[0]
        ]);
        var fc1 = _fullyConnectedLayer.fullyConnectedLayer(vectorized, params.fc1);
        var prelu4 = _prelu.prelu(fc1, params.prelu4_alpha);
        var fc2_1 = _fullyConnectedLayer.fullyConnectedLayer(prelu4, params.fc2_1);
        var max = _tfjsCore.expandDims(_tfjsCore.max(fc2_1, 1), 1);
        var prob = _tfjsCore.softmax(_tfjsCore.sub(fc2_1, max), 1);
        var regions = _fullyConnectedLayer.fullyConnectedLayer(prelu4, params.fc2_2);
        var scores = _tfjsCore.unstack(prob, 1)[1];
        return {
            scores: scores,
            regions: regions
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common/fullyConnectedLayer":"1o20S","./prelu":"lEavS","./sharedLayers":"cX8FA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"14JQK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stage3", ()=>stage3
);
var _tslib = require("tslib");
var _tfjsCore = require("@tensorflow/tfjs-core");
var _classes = require("../classes");
var _ops = require("../ops");
var _extractImagePatches = require("./extractImagePatches");
var _mtcnnBox = require("./MtcnnBox");
var _onet = require("./ONet");
function stage3(img, inputBoxes, scoreThreshold, params, stats) {
    return _tslib.__awaiter(this, void 0, void 0, function() {
        var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;
        return _tslib.__generator(this, function(_c) {
            switch(_c.label){
                case 0:
                    ts = Date.now();
                    return [
                        4 /*yield*/ ,
                        _extractImagePatches.extractImagePatches(img, inputBoxes, {
                            width: 48,
                            height: 48
                        })
                    ];
                case 1:
                    onetInputs = _c.sent();
                    stats.stage3_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    onetOuts = onetInputs.map(function(onetInput) {
                        var out = _onet.ONet(onetInput, params);
                        onetInput.dispose();
                        return out;
                    });
                    stats.stage3_onet = Date.now() - ts;
                    scoresTensor = onetOuts.length > 1 ? _tfjsCore.concat(onetOuts.map(function(out) {
                        return out.scores;
                    })) : onetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [
                        4 /*yield*/ ,
                        scoresTensor.data()
                    ];
                case 2:
                    scores = _b.apply(_a, [
                        _c.sent()
                    ]);
                    scoresTensor.dispose();
                    indices = scores.map(function(score, idx) {
                        return {
                            score: score,
                            idx: idx
                        };
                    }).filter(function(c) {
                        return c.score > scoreThreshold;
                    }).map(function(_a1) {
                        var idx = _a1.idx;
                        return idx;
                    });
                    filteredRegions = indices.map(function(idx) {
                        var regionsData = onetOuts[idx].regions.arraySync();
                        return new _mtcnnBox.MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                    });
                    filteredBoxes = indices.map(function(idx, i) {
                        return inputBoxes[idx].calibrate(filteredRegions[i]);
                    });
                    filteredScores = indices.map(function(idx) {
                        return scores[idx];
                    });
                    finalBoxes = [];
                    finalScores = [];
                    points = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = _ops.nonMaxSuppression(filteredBoxes, filteredScores, 0.7, false);
                        stats.stage3_nms = Date.now() - ts;
                        finalBoxes = indicesNms.map(function(idx) {
                            return filteredBoxes[idx];
                        });
                        finalScores = indicesNms.map(function(idx) {
                            return filteredScores[idx];
                        });
                        points = indicesNms.map(function(idx, i) {
                            return Array(5).fill(0).map(function(_, ptIdx) {
                                var pointsData = onetOuts[idx].points.arraySync();
                                return new _classes.Point(pointsData[0][ptIdx] * (finalBoxes[i].width + 1) + finalBoxes[i].left, pointsData[0][ptIdx + 5] * (finalBoxes[i].height + 1) + finalBoxes[i].top);
                            });
                        });
                    }
                    onetOuts.forEach(function(t) {
                        t.regions.dispose();
                        t.scores.dispose();
                        t.points.dispose();
                    });
                    return [
                        2 /*return*/ ,
                        {
                            boxes: finalBoxes,
                            scores: finalScores,
                            points: points
                        }
                    ];
            }
        });
    });
}

},{"tslib":"bjkXk","@tensorflow/tfjs-core":"82lJf","../classes":"6Yf93","../ops":"cSYle","./extractImagePatches":"hrf2y","./MtcnnBox":"jcna9","./ONet":"bvqaf","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bvqaf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ONet", ()=>ONet
);
var _tfjsCore = require("@tensorflow/tfjs-core");
var _common = require("../common");
var _fullyConnectedLayer = require("../common/fullyConnectedLayer");
var _prelu = require("./prelu");
var _sharedLayers = require("./sharedLayers");
function ONet(x, params) {
    return _tfjsCore.tidy(function() {
        var out = _sharedLayers.sharedLayer(x, params);
        out = _tfjsCore.maxPool(out, [
            2,
            2
        ], [
            2,
            2
        ], 'same');
        out = _common.convLayer(out, params.conv4, 'valid');
        out = _prelu.prelu(out, params.prelu4_alpha);
        var vectorized = _tfjsCore.reshape(out, [
            out.shape[0],
            params.fc1.weights.shape[0]
        ]);
        var fc1 = _fullyConnectedLayer.fullyConnectedLayer(vectorized, params.fc1);
        var prelu5 = _prelu.prelu(fc1, params.prelu5_alpha);
        var fc2_1 = _fullyConnectedLayer.fullyConnectedLayer(prelu5, params.fc2_1);
        var max = _tfjsCore.expandDims(_tfjsCore.max(fc2_1, 1), 1);
        var prob = _tfjsCore.softmax(_tfjsCore.sub(fc2_1, max), 1);
        var regions = _fullyConnectedLayer.fullyConnectedLayer(prelu5, params.fc2_2);
        var points = _fullyConnectedLayer.fullyConnectedLayer(prelu5, params.fc2_3);
        var scores = _tfjsCore.unstack(prob, 1)[1];
        return {
            scores: scores,
            regions: regions,
            points: points
        };
    });
}

},{"@tensorflow/tfjs-core":"82lJf","../common":"iFr5j","../common/fullyConnectedLayer":"1o20S","./prelu":"lEavS","./sharedLayers":"cX8FA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"a1PV6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TinyFaceDetector", ()=>TinyFaceDetector1
);
var _tslib = require("tslib");
var _classes = require("../classes");
var _tinyYolov2Base = require("../tinyYolov2/TinyYolov2Base");
var _const = require("./const");
var TinyFaceDetector1 = function(_super) {
    _tslib.__extends(TinyFaceDetector2, _super);
    function TinyFaceDetector2() {
        var _this = this;
        var config = {
            withSeparableConvs: true,
            iouThreshold: _const.IOU_THRESHOLD,
            classes: [
                'face'
            ],
            anchors: _const.BOX_ANCHORS,
            meanRgb: _const.MEAN_RGB,
            isFirstLayerConv2d: true,
            filterSizes: [
                3,
                16,
                32,
                64,
                128,
                256,
                512
            ]
        };
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyFaceDetector2.prototype, "anchors", {
        get: function() {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyFaceDetector2.prototype.locateFaces = function(input, forwardParams) {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var objectDetections;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.detect(input, forwardParams)
                        ];
                    case 1:
                        objectDetections = _a.sent();
                        return [
                            2 /*return*/ ,
                            objectDetections.map(function(det) {
                                return new _classes.FaceDetection(det.score, det.relativeBox, {
                                    width: det.imageWidth,
                                    height: det.imageHeight
                                });
                            })
                        ];
                }
            });
        });
    };
    TinyFaceDetector2.prototype.getDefaultModelName = function() {
        return 'tiny_face_detector_model';
    };
    TinyFaceDetector2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyFaceDetector2;
}(_tinyYolov2Base.TinyYolov2Base);

},{"tslib":"bjkXk","../classes":"6Yf93","../tinyYolov2/TinyYolov2Base":"8TvEA","./const":"iRW1B","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iRW1B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IOU_THRESHOLD", ()=>IOU_THRESHOLD
);
parcelHelpers.export(exports, "BOX_ANCHORS", ()=>BOX_ANCHORS
);
parcelHelpers.export(exports, "MEAN_RGB", ()=>MEAN_RGB
);
var _classes = require("../classes");
var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes.Point(1.603231, 2.094468),
    new _classes.Point(6.041143, 7.080126),
    new _classes.Point(2.882459, 3.518061),
    new _classes.Point(4.266906, 5.178857),
    new _classes.Point(9.041765, 10.66308)
];
var MEAN_RGB = [
    117.001,
    114.697,
    97.404
];

},{"../classes":"6Yf93","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j1bsJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PredictAgeAndGenderTaskBase", ()=>PredictAgeAndGenderTaskBase1
);
parcelHelpers.export(exports, "PredictAllAgeAndGenderTask", ()=>PredictAllAgeAndGenderTask1
);
parcelHelpers.export(exports, "PredictSingleAgeAndGenderTask", ()=>PredictSingleAgeAndGenderTask1
);
parcelHelpers.export(exports, "PredictAllAgeAndGenderWithFaceAlignmentTask", ()=>PredictAllAgeAndGenderWithFaceAlignmentTask1
);
parcelHelpers.export(exports, "PredictSingleAgeAndGenderWithFaceAlignmentTask", ()=>PredictSingleAgeAndGenderWithFaceAlignmentTask1
);
var _tslib = require("tslib");
var _withAge = require("../factories/WithAge");
var _withGender = require("../factories/WithGender");
var _composableTask = require("./ComposableTask");
var _computeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");
var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");
var _nets = require("./nets");
var _predictFaceExpressionsTask = require("./PredictFaceExpressionsTask");
var PredictAgeAndGenderTaskBase1 = function(_super) {
    _tslib.__extends(PredictAgeAndGenderTaskBase2, _super);
    function PredictAgeAndGenderTaskBase2(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictAgeAndGenderTaskBase2;
}(_composableTask.ComposableTask);
var PredictAllAgeAndGenderTask1 = function(_super) {
    _tslib.__extends(PredictAllAgeAndGenderTask2, _super);
    function PredictAllAgeAndGenderTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResults, ageAndGenderByFace;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResults = _a.sent();
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                                return _tslib.__awaiter(_this, void 0, void 0, function() {
                                    return _tslib.__generator(this, function(_a1) {
                                        switch(_a1.label){
                                            case 0:
                                                return [
                                                    4 /*yield*/ ,
                                                    Promise.all(faces.map(function(face) {
                                                        return _nets.nets.ageGenderNet.predictAgeAndGender(face);
                                                    }))
                                                ];
                                            case 1:
                                                return [
                                                    2 /*return*/ ,
                                                    _a1.sent()
                                                ];
                                        }
                                    });
                                });
                            }, this.extractedFaces)
                        ];
                    case 2:
                        ageAndGenderByFace = _a.sent();
                        return [
                            2 /*return*/ ,
                            parentResults.map(function(parentResult, i) {
                                var _a1 = ageAndGenderByFace[i], age = _a1.age, gender = _a1.gender, genderProbability = _a1.genderProbability;
                                return _withAge.extendWithAge(_withGender.extendWithGender(parentResult, gender, genderProbability), age);
                            })
                        ];
                }
            });
        });
    };
    PredictAllAgeAndGenderTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictAllFaceExpressionsTask(this, this.input);
    };
    return PredictAllAgeAndGenderTask2;
}(PredictAgeAndGenderTaskBase1);
var PredictSingleAgeAndGenderTask1 = function(_super) {
    _tslib.__extends(PredictSingleAgeAndGenderTask2, _super);
    function PredictSingleAgeAndGenderTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResult, _a, age, gender, genderProbability;
            return _tslib.__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) return [
                            2 /*return*/ 
                        ];
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                                return _nets.nets.ageGenderNet.predictAgeAndGender(face);
                            }, this.extractedFaces)
                        ];
                    case 2:
                        _a = _b.sent(), age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
                        return [
                            2 /*return*/ ,
                            _withAge.extendWithAge(_withGender.extendWithGender(parentResult, gender, genderProbability), age)
                        ];
                }
            });
        });
    };
    PredictSingleAgeAndGenderTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictSingleFaceExpressionsTask(this, this.input);
    };
    return PredictSingleAgeAndGenderTask2;
}(PredictAgeAndGenderTaskBase1);
var PredictAllAgeAndGenderWithFaceAlignmentTask1 = function(_super) {
    _tslib.__extends(PredictAllAgeAndGenderWithFaceAlignmentTask2, _super);
    function PredictAllAgeAndGenderWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    PredictAllAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceDescriptors = function() {
        return new _computeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
    };
    return PredictAllAgeAndGenderWithFaceAlignmentTask2;
}(PredictAllAgeAndGenderTask1);
var PredictSingleAgeAndGenderWithFaceAlignmentTask1 = function(_super) {
    _tslib.__extends(PredictSingleAgeAndGenderWithFaceAlignmentTask2, _super);
    function PredictSingleAgeAndGenderWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceExpressions = function() {
        return new _predictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
    };
    PredictSingleAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceDescriptor = function() {
        return new _computeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
    };
    return PredictSingleAgeAndGenderWithFaceAlignmentTask2;
}(PredictSingleAgeAndGenderTask1);

},{"tslib":"bjkXk","../factories/WithAge":"2QX0z","../factories/WithGender":"hgC3o","./ComposableTask":"fBnBt","./ComputeFaceDescriptorsTasks":"3I4nd","./extractFacesAndComputeResults":"3JU0N","./nets":"7WlCP","./PredictFaceExpressionsTask":"iUlxW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iUlxW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PredictFaceExpressionsTaskBase", ()=>PredictFaceExpressionsTaskBase1
);
parcelHelpers.export(exports, "PredictAllFaceExpressionsTask", ()=>PredictAllFaceExpressionsTask1
);
parcelHelpers.export(exports, "PredictSingleFaceExpressionsTask", ()=>PredictSingleFaceExpressionsTask1
);
parcelHelpers.export(exports, "PredictAllFaceExpressionsWithFaceAlignmentTask", ()=>PredictAllFaceExpressionsWithFaceAlignmentTask1
);
parcelHelpers.export(exports, "PredictSingleFaceExpressionsWithFaceAlignmentTask", ()=>PredictSingleFaceExpressionsWithFaceAlignmentTask1
);
var _tslib = require("tslib");
var _withFaceExpressions = require("../factories/WithFaceExpressions");
var _composableTask = require("./ComposableTask");
var _computeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");
var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");
var _nets = require("./nets");
var _predictAgeAndGenderTask = require("./PredictAgeAndGenderTask");
var PredictFaceExpressionsTaskBase1 = function(_super) {
    _tslib.__extends(PredictFaceExpressionsTaskBase2, _super);
    function PredictFaceExpressionsTaskBase2(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictFaceExpressionsTaskBase2;
}(_composableTask.ComposableTask);
var PredictAllFaceExpressionsTask1 = function(_super) {
    _tslib.__extends(PredictAllFaceExpressionsTask2, _super);
    function PredictAllFaceExpressionsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResults, faceExpressionsByFace;
            var _this = this;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResults = _a.sent();
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                                return _tslib.__awaiter(_this, void 0, void 0, function() {
                                    return _tslib.__generator(this, function(_a1) {
                                        switch(_a1.label){
                                            case 0:
                                                return [
                                                    4 /*yield*/ ,
                                                    Promise.all(faces.map(function(face) {
                                                        return _nets.nets.faceExpressionNet.predictExpressions(face);
                                                    }))
                                                ];
                                            case 1:
                                                return [
                                                    2 /*return*/ ,
                                                    _a1.sent()
                                                ];
                                        }
                                    });
                                });
                            }, this.extractedFaces)
                        ];
                    case 2:
                        faceExpressionsByFace = _a.sent();
                        return [
                            2 /*return*/ ,
                            parentResults.map(function(parentResult, i) {
                                return _withFaceExpressions.extendWithFaceExpressions(parentResult, faceExpressionsByFace[i]);
                            })
                        ];
                }
            });
        });
    };
    PredictAllFaceExpressionsTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictAllAgeAndGenderTask(this, this.input);
    };
    return PredictAllFaceExpressionsTask2;
}(PredictFaceExpressionsTaskBase1);
var PredictSingleFaceExpressionsTask1 = function(_super) {
    _tslib.__extends(PredictSingleFaceExpressionsTask2, _super);
    function PredictSingleFaceExpressionsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsTask2.prototype.run = function() {
        return _tslib.__awaiter(this, void 0, void 0, function() {
            var parentResult, faceExpressions;
            return _tslib.__generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.parentTask
                        ];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) return [
                            2 /*return*/ 
                        ];
                        return [
                            4 /*yield*/ ,
                            _extractFacesAndComputeResults.extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                                return _nets.nets.faceExpressionNet.predictExpressions(face);
                            }, this.extractedFaces)
                        ];
                    case 2:
                        faceExpressions = _a.sent();
                        return [
                            2 /*return*/ ,
                            _withFaceExpressions.extendWithFaceExpressions(parentResult, faceExpressions)
                        ];
                }
            });
        });
    };
    PredictSingleFaceExpressionsTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictSingleAgeAndGenderTask(this, this.input);
    };
    return PredictSingleFaceExpressionsTask2;
}(PredictFaceExpressionsTaskBase1);
var PredictAllFaceExpressionsWithFaceAlignmentTask1 = function(_super) {
    _tslib.__extends(PredictAllFaceExpressionsWithFaceAlignmentTask2, _super);
    function PredictAllFaceExpressionsWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsWithFaceAlignmentTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    PredictAllFaceExpressionsWithFaceAlignmentTask2.prototype.withFaceDescriptors = function() {
        return new _computeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
    };
    return PredictAllFaceExpressionsWithFaceAlignmentTask2;
}(PredictAllFaceExpressionsTask1);
var PredictSingleFaceExpressionsWithFaceAlignmentTask1 = function(_super) {
    _tslib.__extends(PredictSingleFaceExpressionsWithFaceAlignmentTask2, _super);
    function PredictSingleFaceExpressionsWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsWithFaceAlignmentTask2.prototype.withAgeAndGender = function() {
        return new _predictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
    };
    PredictSingleFaceExpressionsWithFaceAlignmentTask2.prototype.withFaceDescriptor = function() {
        return new _computeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
    };
    return PredictSingleFaceExpressionsWithFaceAlignmentTask2;
}(PredictSingleFaceExpressionsTask1);

},{"tslib":"bjkXk","../factories/WithFaceExpressions":"eO705","./ComposableTask":"fBnBt","./ComputeFaceDescriptorsTasks":"3I4nd","./extractFacesAndComputeResults":"3JU0N","./nets":"7WlCP","./PredictAgeAndGenderTask":"j1bsJ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"27MNd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FaceMatcher", ()=>FaceMatcher
);
var _faceMatch = require("../classes/FaceMatch");
var _labeledFaceDescriptors = require("../classes/LabeledFaceDescriptors");
var _euclideanDistance = require("../euclideanDistance");
var FaceMatcher = function() {
    function FaceMatcher1(inputs, distanceThreshold) {
        if (distanceThreshold === void 0) distanceThreshold = 0.6;
        this._distanceThreshold = distanceThreshold;
        var inputArray = Array.isArray(inputs) ? inputs : [
            inputs
        ];
        if (!inputArray.length) throw new Error("FaceRecognizer.constructor - expected atleast one input");
        var count = 1;
        var createUniqueLabel = function() {
            return "person " + count++;
        };
        this._labeledDescriptors = inputArray.map(function(desc) {
            if (desc instanceof _labeledFaceDescriptors.LabeledFaceDescriptors) return desc;
            if (desc instanceof Float32Array) return new _labeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [
                desc
            ]);
            if (desc.descriptor && desc.descriptor instanceof Float32Array) return new _labeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [
                desc.descriptor
            ]);
            throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
        });
    }
    Object.defineProperty(FaceMatcher1.prototype, "labeledDescriptors", {
        get: function() {
            return this._labeledDescriptors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatcher1.prototype, "distanceThreshold", {
        get: function() {
            return this._distanceThreshold;
        },
        enumerable: true,
        configurable: true
    });
    FaceMatcher1.prototype.computeMeanDistance = function(queryDescriptor, descriptors) {
        return descriptors.map(function(d) {
            return _euclideanDistance.euclideanDistance(d, queryDescriptor);
        }).reduce(function(d1, d2) {
            return d1 + d2;
        }, 0) / (descriptors.length || 1);
    };
    FaceMatcher1.prototype.matchDescriptor = function(queryDescriptor) {
        var _this = this;
        return this.labeledDescriptors.map(function(_a) {
            var descriptors = _a.descriptors, label = _a.label;
            return new _faceMatch.FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));
        }).reduce(function(best, curr) {
            return best.distance < curr.distance ? best : curr;
        });
    };
    FaceMatcher1.prototype.findBestMatch = function(queryDescriptor) {
        var bestMatch = this.matchDescriptor(queryDescriptor);
        return bestMatch.distance < this.distanceThreshold ? bestMatch : new _faceMatch.FaceMatch('unknown', bestMatch.distance);
    };
    FaceMatcher1.prototype.toJSON = function() {
        return {
            distanceThreshold: this.distanceThreshold,
            labeledDescriptors: this.labeledDescriptors.map(function(ld) {
                return ld.toJSON();
            })
        };
    };
    FaceMatcher1.fromJSON = function(json) {
        var labeledDescriptors = json.labeledDescriptors.map(function(ld) {
            return _labeledFaceDescriptors.LabeledFaceDescriptors.fromJSON(ld);
        });
        return new FaceMatcher1(labeledDescriptors, json.distanceThreshold);
    };
    return FaceMatcher1;
}();

},{"../classes/FaceMatch":"49agE","../classes/LabeledFaceDescriptors":"9qjE9","../euclideanDistance":"7sP78","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7sP78":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "euclideanDistance", ()=>euclideanDistance
);
function euclideanDistance(arr1, arr2) {
    if (arr1.length !== arr2.length) throw new Error('euclideanDistance: arr1.length !== arr2.length');
    var desc1 = Array.from(arr1);
    var desc2 = Array.from(arr2);
    return Math.sqrt(desc1.map(function(val, i) {
        return val - desc2[i];
    }).reduce(function(res, diff) {
        return res + Math.pow(diff, 2);
    }, 0));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2tQQl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createMtcnn", ()=>createMtcnn
);
var _mtcnn = require("./Mtcnn");
parcelHelpers.exportAll(_mtcnn, exports);
var _mtcnnOptions = require("./MtcnnOptions");
parcelHelpers.exportAll(_mtcnnOptions, exports);
function createMtcnn(weights) {
    var net = new _mtcnn.Mtcnn();
    net.extractWeights(weights);
    return net;
}

},{"./Mtcnn":"kqFxm","./MtcnnOptions":"wQQ5R","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1SiVg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTinyFaceDetector", ()=>createTinyFaceDetector
);
var _tinyFaceDetector = require("./TinyFaceDetector");
parcelHelpers.exportAll(_tinyFaceDetector, exports);
var _tinyFaceDetectorOptions = require("./TinyFaceDetectorOptions");
parcelHelpers.exportAll(_tinyFaceDetectorOptions, exports);
function createTinyFaceDetector(weights) {
    var net = new _tinyFaceDetector.TinyFaceDetector();
    net.extractWeights(weights);
    return net;
}

},{"./TinyFaceDetector":"a1PV6","./TinyFaceDetectorOptions":"2HlQx","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7hGCC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resizeResults", ()=>resizeResults
);
var _classes = require("./classes");
var _faceDetection = require("./classes/FaceDetection");
var _faceLandmarks = require("./classes/FaceLandmarks");
var _withFaceDetection = require("./factories/WithFaceDetection");
var _withFaceLandmarks = require("./factories/WithFaceLandmarks");
function resizeResults(results, dimensions) {
    var _a = new _classes.Dimensions(dimensions.width, dimensions.height), width = _a.width, height = _a.height;
    if (width <= 0 || height <= 0) throw new Error("resizeResults - invalid dimensions: " + JSON.stringify({
        width: width,
        height: height
    }));
    if (Array.isArray(results)) return results.map(function(obj) {
        return resizeResults(obj, {
            width: width,
            height: height
        });
    });
    if (_withFaceLandmarks.isWithFaceLandmarks(results)) {
        var resizedDetection = results.detection.forSize(width, height);
        var resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);
        return _withFaceLandmarks.extendWithFaceLandmarks(_withFaceDetection.extendWithFaceDetection(results, resizedDetection), resizedLandmarks);
    }
    if (_withFaceDetection.isWithFaceDetection(results)) return _withFaceDetection.extendWithFaceDetection(results, results.detection.forSize(width, height));
    if (results instanceof _faceLandmarks.FaceLandmarks || results instanceof _faceDetection.FaceDetection) return results.forSize(width, height);
    return results;
}

},{"./classes":"6Yf93","./classes/FaceDetection":"f78Si","./classes/FaceLandmarks":"bin8I","./factories/WithFaceDetection":"bFfpU","./factories/WithFaceLandmarks":"136nl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"97bbV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>_v1JsDefault.default
);
parcelHelpers.export(exports, "v3", ()=>_v3JsDefault.default
);
parcelHelpers.export(exports, "v4", ()=>_v4JsDefault.default
);
parcelHelpers.export(exports, "v5", ()=>_v5JsDefault.default
);
parcelHelpers.export(exports, "NIL", ()=>_nilJsDefault.default
);
parcelHelpers.export(exports, "version", ()=>_versionJsDefault.default
);
parcelHelpers.export(exports, "validate", ()=>_validateJsDefault.default
);
parcelHelpers.export(exports, "stringify", ()=>_stringifyJsDefault.default
);
parcelHelpers.export(exports, "parse", ()=>_parseJsDefault.default
);
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":"8z45G","./v3.js":"dS5as","./v4.js":"hCW8k","./v5.js":"aGrzq","./nil.js":"xmjWK","./version.js":"9St2p","./validate.js":"je4XG","./stringify.js":"BHAb2","./parse.js":"8WpCF","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8z45G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js"); // **`v1()` - Generate time-based UUID**
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;
var _clockseq; // Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || new Array(16);
    options = options || {
    };
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rngJsDefault.default)();
        if (node == null) // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
        ];
        if (clockseq == null) // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) clockseq = clockseq + 1 & 16383;
     // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) nsecs = 0;
     // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    var tl = ((msecs & 268435455) * 10000 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255; // `time_mid`
    var tmh = msecs / 4294967296 * 10000 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 15 | 16; // include version
    b[i++] = tmh >>> 16 & 255; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 128; // `clock_seq_low`
    b[i++] = clockseq & 255; // `node`
    for(var n = 0; n < 6; ++n)b[i + n] = node[n];
    return buf || _stringifyJsDefault.default(b);
}
exports.default = v1;

},{"./rng.js":"5Yrlo","./stringify.js":"BHAb2","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5Yrlo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"BHAb2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var byteToHex = [];
for(var i = 0; i < 256; ++i)byteToHex.push((i + 256).toString(16).substr(1));
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!_validateJsDefault.default(uuid)) throw TypeError('Stringified UUID is invalid');
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"je4XG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"je4XG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === 'string' && _regexJsDefault.default.test(uuid);
}
exports.default = validate;

},{"./regex.js":"lpEFE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lpEFE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dS5as":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _md5Js = require("./md5.js");
var _md5JsDefault = parcelHelpers.interopDefault(_md5Js);
var v3 = _v35JsDefault.default('v3', 48, _md5JsDefault.default);
exports.default = v3;

},{"./v35.js":"8p0wf","./md5.js":"4CoPU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8p0wf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS", ()=>DNS
);
parcelHelpers.export(exports, "URL", ()=>URL1
);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    var bytes = [];
    for(var i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));
    return bytes;
}
var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.default = function(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if (typeof value === 'string') value = stringToBytes(value);
        if (typeof namespace === 'string') namespace = _parseJsDefault.default(namespace);
        if (namespace.length !== 16) throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
         // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        var bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
            offset = offset || 0;
            for(var i = 0; i < 16; ++i)buf[offset + i] = bytes[i];
            return buf;
        }
        return _stringifyJsDefault.default(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {
    } // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL1;
    return generateUUID;
};

},{"./stringify.js":"BHAb2","./parse.js":"8WpCF","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8WpCF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function parse(uuid) {
    if (!_validateJsDefault.default(uuid)) throw TypeError('Invalid UUID');
    var v;
    var arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
}
exports.default = parse;

},{"./validate.js":"je4XG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4CoPU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ function md5(bytes) {
    if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = new Uint8Array(msg.length);
        for(var i = 0; i < msg.length; ++i)bytes[i] = msg.charCodeAt(i);
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */ function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = '0123456789abcdef';
    for(var i = 0; i < length32; i += 8){
        var x = input[i >> 5] >>> i % 32 & 255;
        var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
    }
    return output;
}
/**
 * Calculate output length with padding and bit length
 */ function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */ function wordsToMd5(x, len) {
    /* append padding */ x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for(var i = 0; i < x.length; i += 16){
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [
        a,
        b,
        c,
        d
    ];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function bytesToWords(input) {
    if (input.length === 0) return [];
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for(var i = 0; i < length8; i += 8)output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */ function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports.default = md5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hCW8k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
function v4(options, buf, offset) {
    options = options || {
    };
    var rnds = options.random || (options.rng || _rngJsDefault.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return _stringifyJsDefault.default(rnds);
}
exports.default = v4;

},{"./rng.js":"5Yrlo","./stringify.js":"BHAb2","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aGrzq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _sha1Js = require("./sha1.js");
var _sha1JsDefault = parcelHelpers.interopDefault(_sha1Js);
var v5 = _v35JsDefault.default('v5', 80, _sha1JsDefault.default);
exports.default = v5;

},{"./v35.js":"8p0wf","./sha1.js":"4VYtK","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4VYtK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
    switch(s){
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    var K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    var H = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ];
    if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = [];
        for(var i = 0; i < msg.length; ++i)bytes.push(msg.charCodeAt(i));
    } else if (!Array.isArray(bytes)) // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for(var _i = 0; _i < N; ++_i){
        var arr = new Uint32Array(16);
        for(var j = 0; j < 16; ++j)arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
        M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for(var _i2 = 0; _i2 < N; ++_i2){
        var W = new Uint32Array(80);
        for(var t = 0; t < 16; ++t)W[t] = M[_i2][t];
        for(var _t = 16; _t < 80; ++_t)W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];
        for(var _t2 = 0; _t2 < 80; ++_t2){
            var s = Math.floor(_t2 / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [
        H[0] >> 24 & 255,
        H[0] >> 16 & 255,
        H[0] >> 8 & 255,
        H[0] & 255,
        H[1] >> 24 & 255,
        H[1] >> 16 & 255,
        H[1] >> 8 & 255,
        H[1] & 255,
        H[2] >> 24 & 255,
        H[2] >> 16 & 255,
        H[2] >> 8 & 255,
        H[2] & 255,
        H[3] >> 24 & 255,
        H[3] >> 16 & 255,
        H[3] >> 8 & 255,
        H[3] & 255,
        H[4] >> 24 & 255,
        H[4] >> 16 & 255,
        H[4] >> 8 & 255,
        H[4] & 255
    ];
}
exports.default = sha1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"xmjWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = '00000000-0000-0000-0000-000000000000';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9St2p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function version(uuid) {
    if (!_validateJsDefault.default(uuid)) throw TypeError('Invalid UUID');
    return parseInt(uuid.substr(14, 1), 16);
}
exports.default = version;

},{"./validate.js":"je4XG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}]},["kAaS7","i87aF"], "i87aF", "parcelRequire99b6")

//# sourceMappingURL=index.147655b4.js.map
